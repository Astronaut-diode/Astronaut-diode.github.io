<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>search-insert-position</title>
    <link href="/2024/12/23/Leetcode-search-insert-position/"/>
    <url>/2024/12/23/Leetcode-search-insert-position/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 5</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 2</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 7</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^4</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>nums</code> 为 <strong>无重复元素</strong> 的<strong>升序</strong> 排列数组</li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><h2 id="题解">2 题解</h2><h3 id="二分搜索">2.1 二分搜索</h3><p><strong>思路：</strong></p><p>只要记住，low左边的元素都是小于目标的，high右边的元素都是大于目标的。那么他们跳出循环的时候只有找到了相等值，或者high和low已经交错，这也意味着没有相等值，而high和low中间的间隙就是插入的标准位置。</p><p><strong>时间复杂度：</strong>O(log n)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// low左侧的元素都是小于当前目标的</span><br>    <span class="hljs-comment">// high右侧的元素都是大于当前目标的</span><br>    <span class="hljs-keyword">var</span> low, high <span class="hljs-type">int</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> ;low &lt;= high; &#123;<br>        <span class="hljs-keyword">var</span> mid <span class="hljs-type">int</span> = (low + high) / <span class="hljs-number">2</span><br><br>        <span class="hljs-keyword">if</span> nums[mid] == target &#123;<br>            <span class="hljs-keyword">return</span> mid<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &lt; target &#123;<br>            low = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            high = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 能跳出for但是没有返回值的情况只有一种，[....,high,low,...]，所以最佳的插入位置就是low。</span><br>    <span class="hljs-keyword">return</span> low<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>二分搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>majority-element</title>
    <link href="/2024/12/23/Leetcode-majority-element/"/>
    <url>/2024/12/23/Leetcode-majority-element/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code>，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong><code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [3,2,3]</span><br><span class="hljs-string">输出：3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[2,2,1,1,1,2,2]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><p><strong>进阶：</strong>尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。</p><h2 id="题解">2 题解</h2><h3 id="摩尔投票">2.1 摩尔投票</h3><p><strong>思路：</strong></p><p>将一个数组中的数字认为是两种，众数以及非众数。</p><p>那么每次投票数为0时，假设当前的数字为众数，只能得到两种结果：</p><p>1.这个数字就是众数，所以遍历数组时每次遇到众数就+1，否则就-1，最终结果还是大于0，遍历结束直接返回结果即可。</p><p>2.这个数字不是众数，那么这个数字会被其他的数字给投票替代掉，最终回到情况1。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> vote, x <span class="hljs-type">int</span> = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-comment">// 假设当前的数字就是众数，有以下两种情况：</span><br>        <span class="hljs-comment">// 1.当前数字就是众数，所以一直往后面进行投票，最终的投票数不会归零，所以一定会直接退出循环，返回x。</span><br>        <span class="hljs-comment">// 2.当前的数字不是众数，那么它的投票一定会被其他或者众数给归零。所以就会回到投票为0的时候，重新进行假设，最终得到情况1。值得注意的是，即便回到投票0的情况，对整体的结果并不会产生影响。</span><br>        <span class="hljs-keyword">if</span> vote == <span class="hljs-number">0</span> &#123;<br>            x = nums[i]<br>        &#125;<br>        <span class="hljs-keyword">if</span> nums[i] == x &#123;<br>            vote++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            vote--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>摩尔投票</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>minimum-size-subarray-sum</title>
    <link href="/2024/12/22/Leetcode-minimum-size-subarray-sum/"/>
    <url>/2024/12/22/Leetcode-minimum-size-subarray-sum/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数<code>target</code> <strong>。</strong></p><p>找出该数组中满足其总和大于等于 <code>target</code>的长度最小的连续子数组，<code>[nums[l], nums[l+1], ..., nums[r-1], nums[r]]</code>，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回<code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：target = 7, nums = <span class="hljs-comment">[2,3,1,2,4,3]</span><br>输出：2<br>解释：子数组 <span class="hljs-comment">[4,3]</span> 是该条件下的长度最小的子数组。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：<span class="hljs-keyword">target</span> = <span class="hljs-number">4</span>, nums = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：target = <span class="hljs-number">11</span>, nums = [<span class="hljs-number">1,1,1,1</span>,<span class="hljs-number">1,1,1,1</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 10^9</code></li><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^4</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>枚举右端点，每次在满足题目要求的情况下，试探性的移动左端点，然后更新总和计算答案。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(target <span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> ans, left, right <span class="hljs-type">int</span> = <span class="hljs-built_in">len</span>(nums) + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> right &lt; <span class="hljs-built_in">len</span>(nums) &#123;<br>        sum = sum + nums[right] <span class="hljs-comment">// 扩大右指针，更新总和</span><br>        right++<br>        <span class="hljs-keyword">for</span> sum - nums[left] &gt;= target &#123; <span class="hljs-comment">// 检查是否允许收缩左指针，更新总和</span><br>            sum = sum - nums[left]<br>            left++<br>        &#125;<br>        <span class="hljs-keyword">if</span> sum &gt;= target &amp;&amp; right - left &lt; ans &#123;<br>            ans = right - left<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ans == <span class="hljs-built_in">len</span>(nums) + <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125; <br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-sort-integers-by-the-power-value</title>
    <link href="/2024/12/22/Leetcode-sort-integers-by-the-power-value/"/>
    <url>/2024/12/22/Leetcode-sort-integers-by-the-power-value/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>我们将整数 <code>x</code> 的 <strong>权重</strong>定义为按照下述规则将 <code>x</code> 变成 <code>1</code>所需要的步数：</p><ul><li>如果 <code>x</code> 是偶数，那么 <code>x = x / 2</code></li><li>如果 <code>x</code> 是奇数，那么 <code>x = 3 * x + 1</code></li></ul><p>比方说，x=3 的权重为 7 。因为 3 需要 7 步变成 1 （3 --&gt; 10 --&gt;5 --&gt; 16 --&gt; 8 --&gt; 4 --&gt; 2 --&gt; 1）。</p><p>给你三个整数 <code>lo</code>， <code>hi</code> 和 <code>k</code>。你的任务是将区间 <code>[lo, hi]</code> 之间的整数按照它们的权重<strong>升序排序</strong> ，如果大于等于 2 个整数有<strong>相同</strong> 的权重，那么按照数字自身的数值<strong>升序排序</strong> 。</p><p>请你返回区间 <code>[lo, hi]</code> 之间的整数按权重排序后的第<code>k</code> 个数。</p><p>注意，题目保证对于任意整数 <code>x</code><code>（lo &lt;= x &lt;= hi）</code> ，它变成 <code>1</code>所需要的步数是一个 32 位有符号整数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：lo = 12, hi = 15, k = 2<br>输出：13<br>解释：12 的权重为 9（12 --&gt;<span class="hljs-number"> 6 </span>--&gt;<span class="hljs-number"> 3 </span>--&gt;<span class="hljs-number"> 10 </span>--&gt;<span class="hljs-number"> 5 </span>--&gt;<span class="hljs-number"> 16 </span>--&gt;<span class="hljs-number"> 8 </span>--&gt;<span class="hljs-number"> 4 </span>--&gt;<span class="hljs-number"> 2 </span>--&gt; 1）<br>13 的权重为 9<br>14 的权重为 17<br>15 的权重为 17<br>区间内的数按权重排序以后的结果为 [12,13,14,15] 。对于 k =<span class="hljs-number"> 2 </span>，答案是第二个整数也就是<span class="hljs-number"> 13 </span>。<br>注意，12 和<span class="hljs-number"> 13 </span>有相同的权重，所以我们按照它们本身升序排序。14 和<span class="hljs-number"> 15 </span>同理。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：lo = <span class="hljs-number">7</span>, hi = <span class="hljs-number">11</span>, k = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">7</span><br>解释：区间内整数 <span class="hljs-string">[7, 8, 9, 10, 11]</span> 对应的权重为 <span class="hljs-string">[16, 3, 19, 6, 14]</span> 。<br>按权重排序后得到的结果为 <span class="hljs-string">[8, 10, 11, 7, 9]</span> 。<br>排序后数组中第 <span class="hljs-number">4</span> 个数字为 <span class="hljs-number">7</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= lo &lt;= hi &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= hi - lo + 1</code></li></ul><h2 id="题解">2 题解</h2><h3 id="暴力解法">2.1 暴力解法</h3><p><strong>思路：</strong></p><p>求出1-1000这个区间中所有的权重，然后根据权重进行排序。</p><p><strong>时间复杂度：</strong>O(n)，因为计算权重每个数字都只计算了一次。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getKth</span><span class="hljs-params">(low <span class="hljs-type">int</span>, high <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> memo []<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1000001</span>)<br>    <span class="hljs-keyword">var</span> nums []<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1001</span>)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(memo); i = i * <span class="hljs-number">2</span> &#123; <span class="hljs-comment">// 初步计算出一部分的答案</span><br>        memo[i] = memo[i / <span class="hljs-number">2</span>] + <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">1001</span>; i++ &#123; <span class="hljs-comment">// 重新填写所有的答案。</span><br>        memo[i] = calMemo(memo, i)<br>        nums[i] = i<br>    &#125;<br>    nums = nums[low:high + <span class="hljs-number">1</span>]<br><br>    sort.Slice(nums, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(old <span class="hljs-type">int</span>, <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-comment">// 取出的是索引</span><br>        <span class="hljs-keyword">var</span> oldItme, newItme <span class="hljs-type">int</span> = nums[old], nums[<span class="hljs-built_in">new</span>] <span class="hljs-comment">// 将索引转换为原始数字</span><br>        <span class="hljs-keyword">var</span> oldItemWeight, newItemWeight <span class="hljs-type">int</span> = memo[oldItme], memo[newItme] <span class="hljs-comment">// 将原始数字转换为相应的权重</span><br>        <span class="hljs-comment">// 按照权重进行升序排序，如果权重相同，按照原始数字进行排序</span><br>        <span class="hljs-keyword">return</span> (oldItemWeight &lt; newItemWeight) || (oldItemWeight == newItemWeight &amp;&amp; oldItme &lt; newItme)<br>    &#125;)<br>    <span class="hljs-keyword">return</span> nums[k - <span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-comment">// 计算数字x需要多少次才能到1，memo是已经计算出来的结果。返回x需要的次数。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calMemo</span><span class="hljs-params">(memo []<span class="hljs-type">int</span>, x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> memo[x] == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 进行正向推演。</span><br>        <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>            memo[x] = calMemo(memo, x / <span class="hljs-number">2</span>) + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            memo[x] = calMemo(memo, x * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> memo[x]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>暴力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自制Bash脚本：tree命令</title>
    <link href="/2024/12/19/%E8%87%AA%E5%88%B6Shell%E8%84%9A%E6%9C%AC%EF%BC%9Atree%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/12/19/%E8%87%AA%E5%88%B6Shell%E8%84%9A%E6%9C%AC%EF%BC%9Atree%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="脚本详情">1 脚本详情</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#/bin/bash</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">print</span></span>() &#123;<br>    <span class="hljs-built_in">local</span> path=$(<span class="hljs-built_in">basename</span> <span class="hljs-variable">$1</span>) <span class="hljs-comment"># 通过$()，执行basename命令，获取文件的基础名字。</span><br>    <span class="hljs-built_in">local</span> depth=<span class="hljs-variable">$2</span><br>    <span class="hljs-built_in">local</span> bucket_array=(<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;@:3&#125;</span>&quot;</span>) <span class="hljs-comment"># 获取传入参数从3往后的所有内容。</span><br>    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$&#123;depth&#125;</span> -eq 0 ]; <span class="hljs-keyword">then</span> <span class="hljs-comment"># 判断条件，-eq表示相等。</span><br>        path=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;path&#125;</span>&quot;</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$&#123;bucket_array[$(( <span class="hljs-variable">$&#123;#bucket_array[@]&#125;</span> - 1 ))]&#125;</span> -eq 1 ]; <span class="hljs-keyword">then</span> <span class="hljs-comment"># 运用$(())进行计算。</span><br>            path=<span class="hljs-string">&quot;├── <span class="hljs-variable">$&#123;path&#125;</span>&quot;</span><br>        <span class="hljs-keyword">else</span><br>            path=<span class="hljs-string">&quot;└── <span class="hljs-variable">$&#123;path&#125;</span>&quot;</span><br>        <span class="hljs-keyword">fi</span><br>        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">seq</span> $(( <span class="hljs-variable">$&#123;#bucket_array[@]&#125;</span> - <span class="hljs-number">2</span> )) -1 0); <span class="hljs-keyword">do</span> <span class="hljs-comment"># 运用$(seq start step end)进行for循环。</span><br>            <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$&#123;bucket_array[index]&#125;</span> -eq 1 ]; <span class="hljs-keyword">then</span><br>                path=<span class="hljs-string">&quot;│   <span class="hljs-variable">$&#123;path&#125;</span>&quot;</span><br>            <span class="hljs-keyword">else</span><br>                path=<span class="hljs-string">&quot;    <span class="hljs-variable">$&#123;path&#125;</span>&quot;</span><br>            <span class="hljs-keyword">fi</span><br>        <span class="hljs-keyword">done</span><br>    <span class="hljs-keyword">fi</span>  <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;path&#125;</span>&quot;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">tree</span></span>() &#123;<br>    <span class="hljs-built_in">local</span> pos=<span class="hljs-variable">$1</span><br>    <span class="hljs-built_in">local</span> depth=<span class="hljs-variable">$2</span><br>    <span class="hljs-built_in">local</span> bucket_array=(<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;@:3&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span> <span class="hljs-variable">$&#123;pos&#125;</span> <span class="hljs-variable">$&#123;depth&#125;</span> <span class="hljs-variable">$&#123;bucket_array[@]&#125;</span><br>    <span class="hljs-built_in">local</span> files=(<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;pos&#125;</span>&quot;</span>/*) <span class="hljs-comment"># 获取目标目录下所有的内容，如果目标是个文件或者空目录，将直接返回&quot;原始路径/*&quot;的字符串。</span><br>    <span class="hljs-built_in">local</span> files_length=<span class="hljs-variable">$&#123;#files[@]&#125;</span><br>    <span class="hljs-keyword">if</span> [ ! -e <span class="hljs-variable">$&#123;files[0]&#125;</span> ]; <span class="hljs-keyword">then</span> <span class="hljs-comment"># 如果目标文件并不存在，那就意味着不需要递归了。-e 表示存在，! 表示取反。</span><br>        <span class="hljs-built_in">return</span>;<br>    <span class="hljs-keyword">fi</span>  <br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">seq</span> 0 1 $(( files_length - <span class="hljs-number">1</span> ))); <span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">local</span> tmp_array=(<span class="hljs-variable">$&#123;bucket_array[@]&#125;</span>) <span class="hljs-comment"># 将原始数组的内容全部读出来，再装载到()中，构成数组。</span><br>        <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$&#123;index&#125;</span> -eq $(( files_length - <span class="hljs-number">1</span> )) ]; <span class="hljs-keyword">then</span><br>            tmp_array+=(<span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment"># 向数组中追加内容。</span><br>        <span class="hljs-keyword">else</span><br>            tmp_array+=(<span class="hljs-string">&quot;1&quot;</span>)<br>        <span class="hljs-keyword">fi</span><br>        tree <span class="hljs-variable">$&#123;files[index]&#125;</span> $(( depth + <span class="hljs-number">1</span> )) <span class="hljs-variable">$&#123;tmp_array[@]&#125;</span><br>    <span class="hljs-keyword">done</span><br>&#125;<br><br><span class="hljs-built_in">pwd</span>=$(<span class="hljs-built_in">pwd</span>) <span class="hljs-comment"># 使用$()，可以执行命令，并将结果记录下来。</span><br>depth=0<br>bucket=() <span class="hljs-comment"># 创建数组的写法。</span><br>tree <span class="hljs-variable">$&#123;pwd&#125;</span> <span class="hljs-variable">$&#123;depth&#125;</span> <span class="hljs-variable">$&#123;bucket[@]&#125;</span> <span class="hljs-comment"># 调用函数的写法，注意这里还调用了一个数组中的全部元素，并且没有设置为字符串。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Script</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bash脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lua的文件操作</title>
    <link href="/2024/10/14/lua%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/10/14/lua%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="函数">1 函数</h2><table><thead><tr><th style="text-align: center;">函数</th><th style="text-align: center;">效果</th></tr></thead><tbody><tr><td style="text-align: center;">lfs.currentdir()</td><td style="text-align: center;">获取当前位置</td></tr><tr><td style="text-align: center;">lfs.attributes(filepath)</td><td style="text-align: center;">获取目标文件的属性</td></tr><tr><td style="text-align: center;">lfs.dir(filepath)</td><td style="text-align: center;">遍历目标目录</td></tr><tr><td style="text-align: center;">lfs.chdir(filepath)</td><td style="text-align: center;">切换工作目录</td></tr><tr><td style="text-align: center;">lfs.mkdir(dirname)</td><td style="text-align: center;">在当前目录创建目标文件夹</td></tr><tr><td style="text-align: center;">lfs.rmdir(dirname)</td><td style="text-align: center;">在当前目录下删除目标文件夹</td></tr></tbody></table><h2 id="代码">2 代码</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> lfs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;lfs&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMes</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">local</span> pwd = lfs.currentdir() <span class="hljs-comment">-- 获取当前位置</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;当前的所在位置为:%s&quot;</span>, pwd))<br><br><span class="hljs-keyword">local</span> attr = lfs.attributes(pwd) <span class="hljs-comment">-- 获取目标文件的属性</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;以下是当前文件夹的一些属性:&quot;</span>) <span class="hljs-comment">-- 获取目标的属性，可以用其中的mode属性判断是否是文件夹还是文件</span><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(attr) <span class="hljs-keyword">do</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;key:&quot;</span> .. key .. <span class="hljs-string">&quot;,value:&quot;</span> .. value)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;以下是当前文件夹中包含的文件:&quot;</span>)<br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> lfs.dir(pwd) <span class="hljs-keyword">do</span> <span class="hljs-comment">-- 遍历目标文件夹</span><br><span class="hljs-built_in">print</span>(file)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;创建了文件夹kukuku&quot;</span>)<br>lfs.mkdir(<span class="hljs-string">&quot;kukuku&quot;</span>)<br><span class="hljs-comment">-- 如果需要创建文件，使用普通io的手法进行创建。</span><br>showMes()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;删除了文件夹kukuku&quot;</span>)<br>lfs.rmdir(<span class="hljs-string">&quot;kukuku&quot;</span>)<br><span class="hljs-comment">-- 如果需要删除文件，那就使用os.execute()或者io.popen()去执行系统命令</span><br>showMes()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;切换目录以后&quot;</span> .. lfs.currentdir():<span class="hljs-built_in">gsub</span>(<span class="hljs-string">&quot;/%a+$&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))<br>lfs.chdir(lfs.currentdir():<span class="hljs-built_in">gsub</span>(<span class="hljs-string">&quot;/%a+$&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)) <span class="hljs-comment">-- 切换到上级目录，进而可用其他的命令，并且不在当前的目录下执行。</span><br>showMes()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua</tag>
      
      <tag>lfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lua导包的部分细节</title>
    <link href="/2024/10/13/lua%E5%AF%BC%E5%8C%85%E7%9A%84%E9%83%A8%E5%88%86%E7%BB%86%E8%8A%82/"/>
    <url>/2024/10/13/lua%E5%AF%BC%E5%8C%85%E7%9A%84%E9%83%A8%E5%88%86%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<p>在使用lua语言时，如果使用<code>require</code>引入其他模块，Lua会检测目标模块在当前进程是否是第一次加载。如果是第一次加载，Lua会将结果加入到全局缓存表<code>_LOADED</code>中；如果不是第一次加载，lua会从<code>_LOADED</code>中取出目标，不再重新加载。</p><h2 id="场景">1 场景</h2><p>假设有两个好朋友A和B，A最近完成了一道题目，然后喊B来写此题目。<code>question.lua</code>记录的是题目以及答题卷，而<code>A.lua</code>代表用户A，<code>B.lua</code>代表用户B。以下为相关的源代码：</p><p><strong>question.lua</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">_M = &#123;&#125;<br>_M.question = <span class="hljs-string">&quot;1 + 1 = ？&quot;</span><br>_M.ans = <span class="hljs-literal">nil</span><br><br><span class="hljs-keyword">return</span> _M<br></code></pre></td></tr></table></figure><p><strong>A.lua</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">question = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;question&quot;</span>)<br>B = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;B&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;A查看题目的内容:&quot;</span> .. question[<span class="hljs-string">&quot;question&quot;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;A在试卷上写下答案:&quot;</span> .. <span class="hljs-number">2</span>)<br>question[<span class="hljs-string">&quot;ans&quot;</span>] = <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;A喊来了自己的好朋友B一起写&quot;</span>)<br>B.answer()<br></code></pre></td></tr></table></figure><p><strong>B.lua</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua">_M = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.answer</span><span class="hljs-params">()</span></span><br>question = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;question&quot;</span>) <span class="hljs-comment">-- B加载试卷</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;B发话了，我先看看试卷&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;试卷上的题目为：&quot;</span> .. question[<span class="hljs-string">&quot;question&quot;</span>])<br><span class="hljs-keyword">if</span> question[<span class="hljs-string">&quot;ans&quot;</span>] ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;答题区域赫然写着：&quot;</span> .. question[<span class="hljs-string">&quot;ans&quot;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;B说：你都写完了，还让我写&quot;</span>)<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;B在新的答题试卷上写下了答案&quot;</span>)<br>question[<span class="hljs-string">&quot;ans&quot;</span>] = <span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> _M<br></code></pre></td></tr></table></figure><p>执行情况如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">diode@ubuntu:~/lua$ lua A.lua <br>A查看题目的内容:1 + 1 = ？<br>A在试卷上写下答案:2<br>A喊来了自己的好朋友B一起写<br>B发话了，我先看看试卷<br>试卷上的题目为：1 + 1 = ？<br>答题区域赫然写着：2<br>B说：你都写完了，还让我写<br></code></pre></td></tr></table></figure><p>出现这种情况的原因就是因为使用了require函数加载模块，所以当需要加载一张新试卷时，不应该继续使用require加载模块，而是使用<code>dofile("文件名")</code>去直接加载文件。所以当B.lua进行如下修改后，即可正确执行程序。</p><p><strong>B.lua</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua">_M = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.answer</span><span class="hljs-params">()</span></span><br>question = <span class="hljs-built_in">dofile</span>(<span class="hljs-string">&quot;question.lua&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;B发话了，我先看看试卷&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;试卷上的题目为：&quot;</span> .. question[<span class="hljs-string">&quot;question&quot;</span>])<br><span class="hljs-keyword">if</span> question[<span class="hljs-string">&quot;ans&quot;</span>] ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;答题区域赫然写着：&quot;</span> .. question[<span class="hljs-string">&quot;ans&quot;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;B说：你都写完了，还让我写&quot;</span>)<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;B在新的答题试卷上写下了答案&quot;</span>)<br>question[<span class="hljs-string">&quot;ans&quot;</span>] = <span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> _M<br></code></pre></td></tr></table></figure><p>执行结果如下： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">diode@ubuntu:~/lua$ lua A.lua <br>A查看题目的内容:1 + 1 = ？<br>A在试卷上写下答案:2<br>A喊来了自己的好朋友B一起写<br>B发话了，我先看看试卷<br>试卷上的题目为：1 + 1 = ？<br>B在新的答题试卷上写下了答案<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua</tag>
      
      <tag>require</tag>
      
      <tag>dofile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-find-the-longest-equal-subarray</title>
    <link href="/2024/10/06/Leetcode-find-the-longest-equal-subarray/"/>
    <url>/2024/10/06/Leetcode-find-the-longest-equal-subarray/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code>和一个整数 <code>k</code> 。</p><p>如果子数组中所有元素都相等，则认为子数组是一个<strong>等值子数组</strong> 。注意，空数组是 <strong>等值子数组</strong>。</p><p>从 <code>nums</code> 中删除最多 <code>k</code>个元素后，返回可能的最长等值子数组的长度。</p><p><strong>子数组</strong> 是数组中一个连续且可能为空的元素序列。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,3,2,3,1,3], k = 3<br>输出：3<br>解释：最优的方案是删除下标<span class="hljs-number"> 2 </span>和下标<span class="hljs-number"> 4 </span>的元素。<br>删除后，nums 等于 [1, 3, 3, 3] 。<br>最长等值子数组从 i =<span class="hljs-number"> 1 </span>开始到 j =<span class="hljs-number"> 3 </span>结束，长度等于<span class="hljs-number"> 3 </span>。<br>可以证明无法创建更长的等值子数组。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,1,2,2,1,1], k = 2<br>输出：4<br>解释：最优的方案是删除下标<span class="hljs-number"> 2 </span>和下标<span class="hljs-number"> 3 </span>的元素。 <br>删除后，nums 等于 [1, 1, 1, 1] 。 <br>数组自身就是等值子数组，长度等于<span class="hljs-number"> 4 </span>。 <br>可以证明无法创建更长的等值子数组。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= nums.length</code></li><li><code>0 &lt;= k &lt;= nums.length</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>将所有相同的元素记录到同一个数组中，记录的内容是目标元素在原始数组中的下标。对该数组进行滑动窗口，假设当前的滑动窗口是<code>[left, right)</code>，那么总元素个数为<code>pos[num][right - 1] - pos[num][left] + 1</code>，包含目标数字的个数为<code>right - left</code>，所以就能构造出需要的条件<code>pos[num][right - 1] - pos[num][left] + 1 - (right - left) &lt;= k</code>。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestEqualSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> numsSize = nums.<span class="hljs-built_in">size</span>(), left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; pos = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(numsSize + <span class="hljs-number">1</span>); <span class="hljs-comment">// 将每种数字，保存其出现的所有位置。比如数字3，保存在[1,3,5]代表在原始的下标1、3、5的位置上的数字为3。</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize; i++) &#123;<br>            pos[nums[i]].<span class="hljs-built_in">emplace_back</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pos.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 对每一种数字进行滑动窗口操作。</span><br>            left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (right &lt; pos[i].<span class="hljs-built_in">size</span>()) &#123; <span class="hljs-comment">// 枚举右指针</span><br>                right++; <span class="hljs-comment">// 当前的范围是[left, right)</span><br>                <span class="hljs-keyword">while</span> (!(pos[i][right - <span class="hljs-number">1</span>] - pos[i][left] + <span class="hljs-number">1</span> - (right - left) &lt;= k)) <span class="hljs-comment">// 条件是：根据left和right取出在pos[i]中的数字，代表的是在原始数组中的下标。然后right和left记录的是两个相同的数字，所以这个数组中有多少个相同的数字可以直接通过right - left计算出来。</span><br>                    left++;                <br>                ans = <span class="hljs-built_in">max</span>(ans, right - left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-take-k-of-each-character-from-left-and-right</title>
    <link href="/2024/10/05/Leetcode-take-k-of-each-character-from-left-and-right/"/>
    <url>/2024/10/05/Leetcode-take-k-of-each-character-from-left-and-right/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个由字符 <code>'a'</code>、<code>'b'</code>、<code>'c'</code>组成的字符串 <code>s</code> 和一个非负整数 <code>k</code>。每分钟，你可以选择取走 <code>s</code> <strong>最左侧</strong> 还是<strong>最右侧</strong> 的那个字符。</p><p>你必须取走每种字符 <strong>至少</strong> <code>k</code>个，返回需要的 <strong>最少</strong> 分钟数；如果无法取到，则返回<code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s <span class="hljs-punctuation">=</span> <span class="hljs-string">&quot;aabaaaacaabc&quot;</span><span class="hljs-punctuation">,</span> k <span class="hljs-punctuation">=</span> <span class="hljs-number">2</span><br>输出：<span class="hljs-number">8</span><br>解释：<br>从 s 的左侧取三个字符，现在共取到两个字符 &#x27;a&#x27; 、一个字符 &#x27;b&#x27; 。<br>从 s 的右侧取五个字符，现在共取到四个字符 &#x27;a&#x27; 、两个字符 &#x27;b&#x27; 和两个字符 &#x27;c&#x27; 。<br>共需要 <span class="hljs-number">3</span> <span class="hljs-punctuation">+</span> <span class="hljs-number">5</span> <span class="hljs-punctuation">=</span> <span class="hljs-number">8</span> 分钟。<br>可以证明需要的最少分钟数是 <span class="hljs-number">8</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s <span class="hljs-punctuation">=</span> <span class="hljs-string">&quot;a&quot;</span><span class="hljs-punctuation">,</span> k <span class="hljs-punctuation">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-punctuation">-</span><span class="hljs-number">1</span><br>解释：无法取到一个字符 &#x27;b&#x27; 或者 &#x27;c&#x27;，所以返回 <span class="hljs-punctuation">-</span><span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>s</code> 仅由字母<code>'a'</code>、<code>'b'</code>、<code>'c'</code> 组成</li><li><code>0 &lt;= k &lt;= s.length</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>先统计所有的字符分布情况，看看完全的字符串能否满足给出的任务，如果不行，返回-1.</p><p>假设包含alphaArray数组，记录了abc的分布。如果可以完成任务，将题目转换为，从字符串中提取子字符串，a和b和c都应该被提取出alphaArray['a']- k，alphaArray['b'] - k，alphaArray['c'] -k个。这是至多提取个数，提取多了就无法完成任务了。</p><p>而子字符串的目标要越长越好，这样操作的次数才会越来越少，更加贴合题目的要求。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">takeCharacters</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> alphaArray[<span class="hljs-number">100</span>] = &#123;&#125;;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sSize = s.<span class="hljs-built_in">size</span>(), left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sSize; i++) &#123; <span class="hljs-comment">// 统计所有的字符个数。</span><br>            alphaArray[s[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (alphaArray[<span class="hljs-string">&#x27;a&#x27;</span>] &lt; k || alphaArray[<span class="hljs-string">&#x27;b&#x27;</span>] &lt; k || alphaArray[<span class="hljs-string">&#x27;c&#x27;</span>] &lt; k) <span class="hljs-comment">// 先解决-1的答案。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <br>        alphaArray[<span class="hljs-string">&#x27;a&#x27;</span>] = alphaArray[<span class="hljs-string">&#x27;a&#x27;</span>] - k;<br>        alphaArray[<span class="hljs-string">&#x27;b&#x27;</span>] = alphaArray[<span class="hljs-string">&#x27;b&#x27;</span>] - k;<br>        alphaArray[<span class="hljs-string">&#x27;c&#x27;</span>] = alphaArray[<span class="hljs-string">&#x27;c&#x27;</span>] - k;<br>        <span class="hljs-comment">// 将题目转换为从中间取，至多取alphaArray[&#x27;a&#x27;],alphaArray[&#x27;b&#x27;],alphaArray[&#x27;c&#x27;]个a,b,c，并且子数组要求最长。</span><br>        <span class="hljs-keyword">while</span> (right &lt; sSize) &#123; <span class="hljs-comment">// 枚举右指针</span><br>            alphaArray[s[right++]]--;<br>            <span class="hljs-keyword">while</span> (!(alphaArray[s[right - <span class="hljs-number">1</span>]] &gt;= <span class="hljs-number">0</span>)) <span class="hljs-comment">// 条件：至多只能用这么多个，不能用超了。</span><br>                alphaArray[s[left++]]++;<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left); <span class="hljs-comment">// 答案要求越大越好，因为子数组越大，那么两边取走越少。</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> sSize - ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-frequency-of-the-most-frequent-element</title>
    <link href="/2024/10/05/Leetcode-frequency-of-the-most-frequent-element/"/>
    <url>/2024/10/05/Leetcode-frequency-of-the-most-frequent-element/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>元素的 <strong>频数</strong> 是该元素在一个数组中出现的次数。</p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。在一步操作中，你可以选择 <code>nums</code>的一个下标，并将该下标对应元素的值增加 <code>1</code> 。</p><p>执行最多 <code>k</code> 次操作后，返回数组中最高频元素的<strong>最大可能频数</strong> <em>。</em></p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,4], k = 5<br>输出：3<br>解释：对第一个元素执行<span class="hljs-number"> 3 </span>次递增操作，对第二个元素执<span class="hljs-number"> 2 </span>次递增操作，此时 nums = [4,4,4] 。<br>4 是数组中最高频元素，频数是<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,4,8,13], k = 5<br>输出：2<br>解释：存在多种最优解决方案：<br>- 对第一个元素执行<span class="hljs-number"> 3 </span>次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是<span class="hljs-number"> 2 </span>。<br>- 对第二个元素执行<span class="hljs-number"> 4 </span>次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是<span class="hljs-number"> 2 </span>。<br>- 对第三个元素执行<span class="hljs-number"> 5 </span>次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [3,9,6], k = 2</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li><li><code>1 &lt;= k &lt;= 10^5</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>先排序，然后开辟滑动窗口，每次<strong>准备</strong>移动right时，从left到right的位置可以认为已经都是nums[right]了，所以可以很轻易的计算出，需要将left到right范围内的数字全部改变为nums[right]所需要的代价。</p><p>当right移动完毕以后，判断代价是否超标，只要超标了，收缩左指针，直到不再超标。</p><p>紧接着计算答案。</p><p>要点：中间有一处计算，可能会溢出，所以使用long long最好。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxFrequency</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">begin</span>(nums), <span class="hljs-built_in">end</span>(nums), [](<span class="hljs-type">int</span> &amp;challenger, <span class="hljs-type">int</span> &amp;challengee)&#123;<br>            <span class="hljs-keyword">return</span> challengee &gt; challenger; <span class="hljs-comment">// 升序排序</span><br>        &#125;);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> numsSize = nums.<span class="hljs-built_in">size</span>(), left = <span class="hljs-number">0</span>, right = <span class="hljs-number">1</span>;<br>        ans = <span class="hljs-built_in">max</span>(ans, right - left); <span class="hljs-comment">// 答案默认是1。</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; numsSize) &#123; <span class="hljs-comment">// 枚举右端点</span><br>            sum = sum + (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(nums[right] - (nums[right - <span class="hljs-number">1</span>])) * (right - left);<br>            <span class="hljs-keyword">while</span> (!(sum &lt;= k)) <span class="hljs-comment">// 一直移动左端点，直到满足条件,条件就是使用的操作次数不允许操作k。</span><br>                sum = sum - (nums[right] - nums[left++]);<br>            right++;<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-minimum-operations-to-reduce-x-to-zero</title>
    <link href="/2024/10/05/Leetcode-minimum-operations-to-reduce-x-to-zero/"/>
    <url>/2024/10/05/Leetcode-minimum-operations-to-reduce-x-to-zero/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><h2 id="题解">2 题解</h2><h3 id="题解-1">2.1 题解</h3><p><strong>思路：</strong></p><p>因为只能从左右抽数字，换个思路就是只会留下中间部分，那就是直接找一个子数组，剩下的内容满足条件即可。</p><p>而真正的目标是最小次数，所以子数组需要最长，且目标和等于总和-x。</p><p>需要注意的是，如果sum本身就小于x，那会导致新目标总和为负数，会出现问题，所以需要提前处理。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minOperations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-built_in">accumulate</span>(<span class="hljs-built_in">begin</span>(nums), <span class="hljs-built_in">end</span>(nums), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (sum &lt; x) <span class="hljs-comment">// 如果总和都不够，那就返回-1。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        x = sum - x; <span class="hljs-comment">// 这是需要找的目标</span><br>        <span class="hljs-comment">// 题目转换为在nums中找到和为x的最长子数组</span><br>        <span class="hljs-type">int</span> numsSize = nums.<span class="hljs-built_in">size</span>(), left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; numsSize) &#123; <span class="hljs-comment">// 枚举右端点</span><br>            count = count + nums[right++];<br>            <span class="hljs-keyword">while</span> (!(count &lt;= x)) &#123; <span class="hljs-comment">// 只要和是不大于x的，都是符合条件的</span><br>                count = count - nums[left++];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count == x)<br>                ans = <span class="hljs-built_in">max</span>(ans, right - left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ans == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> numsSize - ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcide-maximize-the-confusion-of-an-exam</title>
    <link href="/2024/10/05/Leetcide-maximize-the-confusion-of-an-exam/"/>
    <url>/2024/10/05/Leetcide-maximize-the-confusion-of-an-exam/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>一位老师正在出一场由 <code>n</code>道判断题构成的考试，每道题的答案为 true （用 <code>'T'</code> 表示）或者false （用 <code>'F'</code>表示）。老师想增加学生对自己做出答案的不确定性，方法是<strong>最大化</strong> 有 <strong>连续相同</strong>结果的题数。（也就是连续出现 true 或者连续出现 false）。</p><p>给你一个字符串 <code>answerKey</code> ，其中<code>answerKey[i]</code> 是第 <code>i</code>个问题的正确结果。除此以外，还给你一个整数 <code>k</code>，表示你能进行以下操作的最多次数：</p><ul><li>每次操作中，将问题的正确答案改为 <code>'T'</code> 或者<code>'F'</code> （也就是将 <code>answerKey[i]</code> 改为<code>'T'</code> 或者 <code>'F'</code> ）。</li></ul><p>请你返回在不超过 <code>k</code> 次操作的情况下，<strong>最大</strong>连续 <code>'T'</code> 或者 <code>'F'</code> 的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：answerKey <span class="hljs-punctuation">=</span> <span class="hljs-string">&quot;TTFF&quot;</span><span class="hljs-punctuation">,</span> k <span class="hljs-punctuation">=</span> <span class="hljs-number">2</span><br>输出：<span class="hljs-number">4</span><br>解释：我们可以将两个 &#x27;F&#x27; 都变为 &#x27;T&#x27; ，得到 answerKey <span class="hljs-punctuation">=</span> <span class="hljs-string">&quot;TTTT&quot;</span> 。<br>总共有四个连续的 &#x27;T&#x27; 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：answerKey <span class="hljs-punctuation">=</span> <span class="hljs-string">&quot;TFFT&quot;</span><span class="hljs-punctuation">,</span> k <span class="hljs-punctuation">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">3</span><br>解释：我们可以将最前面的 &#x27;T&#x27; 换成 &#x27;F&#x27; ，得到 answerKey <span class="hljs-punctuation">=</span> <span class="hljs-string">&quot;FFFT&quot;</span> 。<br>或者，我们可以将第二个 &#x27;T&#x27; 换成 &#x27;F&#x27; ，得到 answerKey <span class="hljs-punctuation">=</span> <span class="hljs-string">&quot;TFFF&quot;</span> 。<br>两种情况下，都有三个连续的 &#x27;F&#x27; 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：answerKey <span class="hljs-punctuation">=</span> <span class="hljs-string">&quot;TTFTTFTT&quot;</span><span class="hljs-punctuation">,</span> k <span class="hljs-punctuation">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">5</span><br>解释：我们可以将第一个 &#x27;F&#x27; 换成 &#x27;T&#x27; ，得到 answerKey <span class="hljs-punctuation">=</span> <span class="hljs-string">&quot;TTTTTFTT&quot;</span> 。<br>或者我们可以将第二个 &#x27;F&#x27; 换成 &#x27;T&#x27; ，得到 answerKey <span class="hljs-punctuation">=</span> <span class="hljs-string">&quot;TTFTTTTT&quot;</span> 。<br>两种情况下，都有五个连续的 &#x27;T&#x27; 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == answerKey.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><code>answerKey[i]</code> 要么是 <code>'T'</code> ，要么是<code>'F'</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>不定长度的话滑动窗口，主要点在于判断是否T和F的数量是否至少有一者小于等于k，只有满足这个条件，才能将其转换为全部相同的字符。</p><p><strong>时间复杂度:</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxConsecutiveAnswers</span><span class="hljs-params">(string answerKey, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> answerKeySize = answerKey.<span class="hljs-built_in">size</span>(), left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> memo[<span class="hljs-number">200</span>] = &#123;&#125;;<br><br>        <span class="hljs-keyword">while</span> (right &lt; answerKeySize) &#123; <span class="hljs-comment">// 枚举右指针</span><br>            memo[answerKey[right++]]++;<br>            <span class="hljs-keyword">while</span> (!(memo[<span class="hljs-string">&#x27;T&#x27;</span>] &lt;= k || memo[<span class="hljs-string">&#x27;F&#x27;</span>] &lt;= k)) &#123; <span class="hljs-comment">// 移动左指针，直到满足条件。题目的条件是T和F的数目至少有一种小于等于k，否则无法同化为连续相同。</span><br>                memo[answerKey[left++]]--;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-maximum-beauty-of-an-array-after-applying-operation</title>
    <link href="/2024/10/05/Leetcode-maximum-beauty-of-an-array-after-applying-operation/"/>
    <url>/2024/10/05/Leetcode-maximum-beauty-of-an-array-after-applying-operation/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code>和一个 <strong>非负</strong> 整数 <code>k</code> 。</p><p>在一步操作中，你可以执行下述指令：</p><ul><li>在范围 <code>[0, nums.length - 1]</code> 中选择一个<strong>此前没有选过</strong> 的下标 <code>i</code> 。</li><li>将 <code>nums[i]</code> 替换为范围<code>[nums[i] - k, nums[i] + k]</code> 内的任一整数。</li></ul><p>数组的 <strong>美丽值</strong>定义为数组中由相等元素组成的最长子序列的长度。</p><p>对数组 <code>nums</code> 执行上述操作任意次后，返回数组可能取得的<strong>最大</strong> 美丽值。</p><p><strong>注意：</strong>你 <strong>只</strong> 能对每个下标执行<strong>一次</strong> 此操作。</p><p>数组的 <strong>子序列</strong>定义是：经由原数组删除一些元素（也可能不删除）得到的一个新数组，且在此过程中剩余元素的顺序不发生改变。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[4,6,1,2]</span>, k = 2<br>输出：3<br>解释：在这个示例中，我们执行下述操作：<br>- 选择下标 1 ，将其替换为 4（从范围 <span class="hljs-comment">[4,8]</span> 中选出），此时 nums = <span class="hljs-comment">[4,4,1,2]</span> 。<br>- 选择下标 3 ，将其替换为 4（从范围 <span class="hljs-comment">[0,4]</span> 中选出），此时 nums = <span class="hljs-comment">[4,4,1,4]</span> 。<br>执行上述操作后，数组的美丽值是 3（子序列由下标 0 、1 、3 对应的元素组成）。<br>可以证明 3 是我们可以得到的由相等元素组成的最长子序列长度。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,1,1,1</span>], k = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">4</span><br>解释：在这个示例中，我们无需执行任何操作。<br>数组 nums 的美丽值是 <span class="hljs-number">4</span>（整个数组）。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= nums[i], k &lt;= 10^5</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>先将数组进行升序排序，只要两个数字的差值小于等于2 *k，那就可以改变为相同的数字。所以在升序数组中，找到最大值和最小值差值不大于2* k的子数组即可，最长的子数组即为答案。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumBeauty</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">begin</span>(nums), <span class="hljs-built_in">end</span>(nums), [](<span class="hljs-type">int</span> &amp;challenger, <span class="hljs-type">int</span> &amp;challengee)&#123;<br>            <span class="hljs-keyword">return</span> challengee &gt; challenger; <span class="hljs-comment">// 按照升序排序。</span><br>        &#125;);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> numsSize = nums.<span class="hljs-built_in">size</span>(), left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; numsSize) &#123; <span class="hljs-comment">// 枚举右端点</span><br>            right++;<br>            <span class="hljs-keyword">while</span> (!(<span class="hljs-built_in">abs</span>(nums[right - <span class="hljs-number">1</span>] - nums[left]) &lt;= <span class="hljs-number">2</span> * k)) &#123; <span class="hljs-comment">// 只要最大和最小数字的差值小于2k，都是满足条件的</span><br>                left++;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-fruit-into-baskets</title>
    <link href="/2024/10/05/Leetcode-fruit-into-baskets/"/>
    <url>/2024/10/05/Leetcode-fruit-into-baskets/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组<code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第<code>i</code> 棵树上的水果 <strong>种类</strong> 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><ul><li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装<strong>单一类型</strong>的水果。每个篮子能够装的水果总量没有限制。</li><li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong>树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong>。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li><li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li></ul><p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的<strong>最大</strong> 数目。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：fruits </span>=<span class="hljs-string"> [1,2,1]</span><br><span class="hljs-string">输出：3</span><br><span class="hljs-string">解释：可以采摘全部 3 棵树。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：fruits = <span class="hljs-comment">[0,1,2,2]</span><br>输出：3<br>解释：可以采摘 <span class="hljs-comment">[1,2,2]</span> 这三棵树。<br>如果从第一棵树开始采摘，则只能采摘 <span class="hljs-comment">[0,1]</span> 这两棵树。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：fruits = <span class="hljs-comment">[1,2,3,2,2]</span><br>输出：4<br>解释：可以采摘 <span class="hljs-comment">[2,3,2,2]</span> 这四棵树。<br>如果从第一棵树开始采摘，则只能采摘 <span class="hljs-comment">[1,2]</span> 这两棵树。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：fruits = [<span class="hljs-number">3,3,3,1</span>,<span class="hljs-number">2,1,1,2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">5</span><br>解释：可以采摘 [<span class="hljs-number">1,2,1,1</span>,<span class="hljs-number">2</span>] 这五棵树。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= fruits.length &lt;= 10^5</code></li><li><code>0 &lt;= fruits[i] &lt; fruits.length</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>枚举右端点，将当前滑动窗口中有多少种类的水果，每种有多少个记录到哈希表中，判断条件时，直接看哈希表的长度即可。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fruits)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; basket; <span class="hljs-comment">// 记录水果类型-采摘个数</span><br>        <span class="hljs-type">int</span> fruitsSize = fruits.<span class="hljs-built_in">size</span>(), left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; fruitsSize) &#123; <span class="hljs-comment">// 枚举右端点</span><br>            basket[fruits[right++]]++;<br>            <span class="hljs-keyword">while</span> (!(basket.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>)) &#123; <span class="hljs-comment">// 不满足条件时，移动左端点</span><br>                basket[fruits[left]]--;<br>                <span class="hljs-keyword">if</span> (basket[fruits[left]] == <span class="hljs-number">0</span>) <br>                    basket.<span class="hljs-built_in">erase</span>(fruits[left]);<br>                left++;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-find-the-longest-semi-repetitive-substring</title>
    <link href="/2024/10/05/Leetcode-find-the-longest-semi-repetitive-substring/"/>
    <url>/2024/10/05/Leetcode-find-the-longest-semi-repetitive-substring/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code>，这个字符串只包含 <code>0</code> 到 <code>9</code> 的数字字符。</p><p>如果一个字符串 <code>t</code>中至多有一对相邻字符是相等的，那么称这个字符串 <code>t</code> 是<strong>半重复的</strong> 。例如，<code>"0010"</code>、<code>"002020"</code> 、<code>"0123"</code> 、<code>"2002"</code> 和<code>"54944"</code> 是半重复字符串，而 <code>"00101022"</code>（相邻的相同数字对是 00 和 22）和 <code>"1101234883"</code>（相邻的相同数字对是 11 和 88）不是半重复字符串。</p><p>请你返回 <code>s</code> 中最长 <strong>半重复</strong> 子字符串的长度。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>s = "52233"</p><p><strong>输出：</strong>4</p><p><strong>解释：</strong></p><p>最长的半重复子字符串是 "5223"。整个字符串 "52233"有两个相邻的相同数字对 22 和 33，但最多只能选取一个。</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>s = "5494"</p><p><strong>输出：</strong>4</p><p><strong>解释：</strong></p><p><code>s</code> 是一个半重复字符串。</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>s = "1111111"</p><p><strong>输出：</strong>2</p><p><strong>解释：</strong></p><p>最长的半重复子字符串是 "11"。子字符串 "111"有两个相邻的相同数字对，但最多允许选取一个。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 50</code></li><li><code>'0' &lt;= s[i] &lt;= '9'</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>枚举右指针，如果满足条件计算答案，不满足就先移动左指针，直到满足条件时计算答案。</p><p>条件也就是窗口内包含几处相邻字符是相同的。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestSemiRepetitiveSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sSize = s.<span class="hljs-built_in">size</span>(), left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; sSize) &#123;<br>            count = count + (right &gt; <span class="hljs-number">0</span> &amp;&amp; s[right - <span class="hljs-number">1</span>] == s[right]); <span class="hljs-comment">// 读入right</span><br>            right++;<br>            <span class="hljs-keyword">while</span> (!(count &lt;= <span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">// 不满足条件时弹出left</span><br>                count = count - (left &lt; sSize &amp;&amp; s[left] == s[left + <span class="hljs-number">1</span>]);<br>                left++;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-get-equal-substrings-within-budget</title>
    <link href="/2024/10/05/Leetcode-get-equal-substrings-within-budget/"/>
    <url>/2024/10/05/Leetcode-get-equal-substrings-within-budget/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你两个长度相同的字符串，<code>s</code> 和 <code>t</code>。</p><p>将 <code>s</code> 中的第 <code>i</code> 个字符变到 <code>t</code>中的第 <code>i</code> 个字符需要 <code>|s[i] - t[i]|</code>的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</p><p>用于变更字符串的最大预算是<code>maxCost</code>。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p><p>如果你可以将 <code>s</code> 的子字符串转化为它在 <code>t</code>中对应的子字符串，则返回可以转化的最大长度。</p><p>如果 <code>s</code> 中没有子字符串可以转化成 <code>t</code>中对应的子字符串，则返回 <code>0</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;bcdf&quot;</span>, maxCost = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：s 中的 <span class="hljs-string">&quot;abc&quot;</span> 可以变为 <span class="hljs-string">&quot;bcd&quot;</span>。开销为 <span class="hljs-number">3</span>，所以最大长度为 <span class="hljs-number">3</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;cdef&quot;</span>, maxCost = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">1</span><br>解释：s 中的任一字符要想变成 <span class="hljs-built_in">t</span> 中对应的字符，其开销都是 <span class="hljs-number">2</span>。因此，最大长度为 <span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入：s = <span class="hljs-string">&quot;abcd&quot;</span>, t = <span class="hljs-string">&quot;acde&quot;</span>, maxCost = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">1</span><br>解释：<span class="hljs-keyword">a</span> -&gt; <span class="hljs-keyword">a</span>, cost = <span class="hljs-number">0</span>，字符串未发生变化，所以最大长度为 <span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 10^5</code></li><li><code>0 &lt;= maxCost &lt;= 10^6</code></li><li><code>s</code> 和 <code>t</code> 都只含小写英文字母。</li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>枚举右指针</p><ul><li>如果符合条件，跳过第二步</li><li>移动左指针，直到符合条件</li><li>计算答案</li></ul><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">equalSubstring</span><span class="hljs-params">(string s, string t, <span class="hljs-type">int</span> maxCost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sSize = s.<span class="hljs-built_in">size</span>(), left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cost = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; sSize) &#123; <span class="hljs-comment">// 先枚举右端点</span><br>            cost = cost + <span class="hljs-built_in">abs</span>(s[right] - t[right]);<br>            right++;<br>            <span class="hljs-keyword">while</span> (!(cost &lt;= maxCost)) &#123; <span class="hljs-comment">// 不满足条件时，移动左端点</span><br>                cost = cost - (<span class="hljs-built_in">abs</span>(s[left] - t[left]));<br>                left++;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-longest-subarray-of-1s-after-deleting-one-element</title>
    <link href="/2024/10/05/Leetcode-longest-subarray-of-1s-after-deleting-one-element/"/>
    <url>/2024/10/05/Leetcode-longest-subarray-of-1s-after-deleting-one-element/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个二进制数组 <code>nums</code> ，你需要从中删掉一个元素。</p><p>请你在删掉元素的结果数组中，返回最长的且只包含 1的非空子数组的长度。</p><p>如果不存在这样的子数组，请返回 0 。</p><p><strong>提示 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,1,0,1]<br>输出：3<br>解释：删掉位置<span class="hljs-number"> 2 </span>的数后，[1,1,1] 包含<span class="hljs-number"> 3 </span>个<span class="hljs-number"> 1 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,1,1,1</span>,<span class="hljs-number">0,1,1,0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">5</span><br>解释：删掉位置 <span class="hljs-number">4</span> 的数字后，[<span class="hljs-number">0,1,1,1</span>,<span class="hljs-number">1,1,0,1</span>] 的最长全 <span class="hljs-number">1</span> 子数组为 [<span class="hljs-number">1,1,1,1</span>,<span class="hljs-number">1</span>] 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,1,1]</span><br><span class="hljs-string">输出：2</span><br><span class="hljs-string">解释：你必须要删除一个元素。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>nums[i]</code> 要么是 <code>0</code> 要么是 <code>1</code>。</li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>先枚举右端点，如果满足条件就计算答案，不满足条件时，不断移动左端点直到满足条件。其实也就是读入，弹出、计算答案。但是这里的弹出，需要看条件是否满足，所以可能弹出0或任意多次。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> numsSize = nums.<span class="hljs-built_in">size</span>(), left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录子字符串包含了几个0。</span><br><br>        <span class="hljs-keyword">while</span> (right &lt; numsSize) &#123; <span class="hljs-comment">// 枚举右端点</span><br>            count = count + (nums[right++] == <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">while</span> (!(count &lt;= <span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">// 当条件不符合时，移动左端点。</span><br>                count = count - (nums[left++] == <span class="hljs-number">0</span>);<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-longest-substring-without-repeating-characters</title>
    <link href="/2024/10/05/Leetcode-longest-substring-without-repeating-characters/"/>
    <url>/2024/10/05/Leetcode-longest-substring-without-repeating-characters/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的<strong>最长子串</strong> 的长度。</p><p><strong>子字符串</strong> <strong>是字符串中连续的</strong><strong>非空</strong> <strong>字符序列。</strong></p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 10^4</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>不是定长滑动窗口了，所以不需要构造初始窗口，直接开始移动右边界，直到不满足条件时，不断移动左边界直到可以满足条件，每一次满足条件时都计算一次答案。</p><p>进一步理解，可以看作是枚举右指针，如果出现问题，就不断移动左指针。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sSize = s.<span class="hljs-built_in">size</span>(), left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> alphaArray[<span class="hljs-number">200</span>] = &#123;&#125;; <span class="hljs-comment">// 每种字符上有多少次重复</span><br><br>        <span class="hljs-keyword">while</span> (right &lt; sSize) &#123; <span class="hljs-comment">// 移动右指针，直到不可计算答案</span><br>            alphaArray[s[right++]]++;<br>            <span class="hljs-keyword">while</span> (alphaArray[s[right - <span class="hljs-number">1</span>]] &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果发现不符合条件，移动左指针，直到可以计算答案</span><br>                alphaArray[s[left++]]--;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-contains-duplicate-iii</title>
    <link href="/2024/10/04/Leetcode-contains-duplicate-iii/"/>
    <url>/2024/10/04/Leetcode-contains-duplicate-iii/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个整数数组 <code>nums</code> 和两个整数 <code>indexDiff</code>和 <code>valueDiff</code> 。</p><p>找出满足下述条件的下标对 <code>(i, j)</code>：</p><ul><li><code>i != j</code>,</li><li><code>abs(i - j) &lt;= indexDiff</code></li><li><code>abs(nums[i] - nums[j]) &lt;= valueDiff</code></li></ul><p>如果存在，返回 <code>true</code> <em>；</em>否则，返回<code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[1,2,3,1]</span>, indexDiff = <span class="hljs-number">3</span>, valueDiff = <span class="hljs-number">0</span><br>输出：true<br>解释：可以找出 (<span class="hljs-selector-tag">i</span>, j) = (<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) 。<br>满足下述 <span class="hljs-number">3</span> 个条件：<br><span class="hljs-selector-tag">i</span> != j --&gt; <span class="hljs-number">0</span> != <span class="hljs-number">3</span><br><span class="hljs-function"><span class="hljs-title">abs</span><span class="hljs-params">(i - j)</span></span> &lt;= indexDiff --&gt; <span class="hljs-built_in">abs</span>(<span class="hljs-number">0</span> - <span class="hljs-number">3</span>) &lt;= <span class="hljs-number">3</span><br><span class="hljs-function"><span class="hljs-title">abs</span><span class="hljs-params">(nums[i] - nums[j])</span></span> &lt;= valueDiff --&gt; <span class="hljs-built_in">abs</span>(<span class="hljs-number">1</span> - <span class="hljs-number">1</span>) &lt;= <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>], <span class="hljs-attr">indexDiff</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">valueDiff</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-literal">false</span><br>解释：尝试所有可能的下标对 (i, j) ，均无法满足这 <span class="hljs-number">3</span> 个条件，因此返回 <span class="hljs-literal">false</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li><li><code>1 &lt;= indexDiff &lt;= nums.length</code></li><li><code>0 &lt;= valueDiff &lt;= 10^9</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>也就是用滑动窗口，但是需要使用set记录窗口内有哪些数字，通过滑动窗口可以满足下标范围的要求，通过set的查询，可以满足数值大小在绝对值范围内的要求。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> t)</span> </span>&#123; <span class="hljs-comment">// 滑动窗口的长度为k + 1，也即abs(i - j)只取一半。</span><br>        set&lt;<span class="hljs-type">int</span>&gt; memo;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">while</span> (right &lt;= k &amp;&amp; right &lt; n) &#123; <span class="hljs-comment">// 构建初始滑动窗口</span><br>            set&lt;<span class="hljs-type">int</span>&gt;::iterator ite = memo.<span class="hljs-built_in">lower_bound</span>(nums[right] - t);<br>            <span class="hljs-keyword">if</span> (ite != <span class="hljs-built_in">end</span>(memo) &amp;&amp; <span class="hljs-built_in">abs</span>(*ite - nums[right]) &lt;= t) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                memo.<span class="hljs-built_in">insert</span>(nums[right]);<br>            &#125;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123; <span class="hljs-comment">// 移动窗口</span><br>            memo.<span class="hljs-built_in">erase</span>(nums[left++]);<br>            set&lt;<span class="hljs-type">int</span>&gt;::iterator ite = memo.<span class="hljs-built_in">lower_bound</span>(nums[right] - t);<br>            <span class="hljs-keyword">if</span> (ite != <span class="hljs-built_in">end</span>(memo) &amp;&amp; <span class="hljs-built_in">abs</span>(*ite - nums[right]) &lt;= t) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                memo.<span class="hljs-built_in">insert</span>(nums[right]);<br>            &#125;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-find-the-k-beauty-of-a-number</title>
    <link href="/2024/10/03/Leetcode-find-the-k-beauty-of-a-number/"/>
    <url>/2024/10/03/Leetcode-find-the-k-beauty-of-a-number/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>一个整数 <code>num</code> 的 <strong>k</strong> 美丽值定义为<code>num</code> 中符合以下条件的 <strong>子字符串</strong> 数目：</p><ul><li>子字符串长度为 <code>k</code> 。</li><li>子字符串能整除 <code>num</code> 。</li></ul><p>给你整数 <code>num</code> 和 <code>k</code> ，请你返回<code>num</code> 的 k 美丽值。</p><p>注意：</p><ul><li>允许有 <strong>前缀</strong> <strong>0</strong> 。</li><li><code>0</code> 不能整除任何值。</li></ul><p>一个 <strong>子字符串</strong> 是一个字符串里的连续一段字符序列。</p><p><strong>示例 1：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">240</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br>解释：以下是 <span class="hljs-built_in">num</span> 里长度为 k 的子字符串：<br>- <span class="hljs-string">&quot;240&quot;</span> 中的 <span class="hljs-string">&quot;24&quot;</span> ：<span class="hljs-number">24</span> 能整除 <span class="hljs-number">240</span> 。<br>- <span class="hljs-string">&quot;240&quot;</span> 中的 <span class="hljs-string">&quot;40&quot;</span> ：<span class="hljs-number">40</span> 能整除 <span class="hljs-number">240</span> 。<br>所以，k 美丽值为 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">430043</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br>解释：以下是 <span class="hljs-built_in">num</span> 里长度为 k 的子字符串：<br>- <span class="hljs-string">&quot;430043&quot;</span> 中的 <span class="hljs-string">&quot;43&quot;</span> ：<span class="hljs-number">43</span> 能整除 <span class="hljs-number">430043</span> 。<br>- <span class="hljs-string">&quot;430043&quot;</span> 中的 <span class="hljs-string">&quot;30&quot;</span> ：<span class="hljs-number">30</span> 不能整除 <span class="hljs-number">430043</span> 。<br>- <span class="hljs-string">&quot;430043&quot;</span> 中的 <span class="hljs-string">&quot;00&quot;</span> ：<span class="hljs-number">0</span> 不能整除 <span class="hljs-number">430043</span> 。<br>- <span class="hljs-string">&quot;430043&quot;</span> 中的 <span class="hljs-string">&quot;04&quot;</span> ：<span class="hljs-number">4</span> 不能整除 <span class="hljs-number">430043</span> 。<br>- <span class="hljs-string">&quot;430043&quot;</span> 中的 <span class="hljs-string">&quot;43&quot;</span> ：<span class="hljs-number">43</span> 能整除 <span class="hljs-number">430043</span> 。<br>所以，k 美丽值为 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num &lt;= 10^9</code></li><li><code>1 &lt;= k &lt;= num.length</code> （将 <code>num</code>视为字符串）</li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>主要点就是创建初始滑动窗口还有滑动的时候如何快速复用上一轮的结果。因为是数组，并且要去除最后一个数字，往前头加上一个数字，所以我们需要一个变量记录(10^ (k - 1))，滑动的时候，只需要整除10，再加上新数字 * (10 ^ (k -1))。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">divisorSubstrings</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> power = <span class="hljs-number">10</span>, pPower = <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>, origin = num;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; k) &#123; <span class="hljs-comment">// 构建初始窗口</span><br>            sum = sum + num % <span class="hljs-number">10</span> * pPower;<br>            num = num / <span class="hljs-number">10</span>;<br>            right++;<br>            <span class="hljs-keyword">if</span> (right &lt; k) <span class="hljs-comment">// 最后一轮的时候，不再计算</span><br>                pPower = pPower * power;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum != <span class="hljs-number">0</span> &amp;&amp; origin % sum == <span class="hljs-number">0</span>) <span class="hljs-comment">// 计算答案</span><br>            ans++;<br>        <span class="hljs-keyword">while</span> (num != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 重复滑动窗口</span><br>            sum = sum / <span class="hljs-number">10</span> + num % <span class="hljs-number">10</span> * pPower;<br>            num = num / <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (sum != <span class="hljs-number">0</span> &amp;&amp; origin % sum == <span class="hljs-number">0</span>) <span class="hljs-comment">// 计算答案</span><br>                ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些数学性质</title>
    <link href="/2024/10/03/%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%A6%E6%80%A7%E8%B4%A8/"/>
    <url>/2024/10/03/%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%A6%E6%80%A7%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="同余运算">1 同余运算</h2><p><strong>（a+b）mod n=((a mod n)+(b mod n)) mod n</strong></p><p><strong>(a-b)mod n=((a mod n)-(b mod n)+n)mod n</strong></p><p><strong>ab mod n=(a mod n)(b mod n)mod n</strong></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-find-substring-with-given-hash-value</title>
    <link href="/2024/10/03/Leetcode-find-substring-with-given-hash-value/"/>
    <url>/2024/10/03/Leetcode-find-substring-with-given-hash-value/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给定整数 <code>p</code> 和 <code>m</code> ，一个长度为 <code>k</code>且下标从 <strong>0</strong> 开始的字符串 <code>s</code>的哈希值按照如下函数计算：</p><ul><li><code>hash(s, p, m) = (val(s[0]) * p^0 + val(s[1]) * p^1 + ... + val(s[k-1]) * p^(k-1)) mod m</code>.</li></ul><p>其中 <code>val(s[i])</code> 表示 <code>s[i]</code>在字母表中的下标，从 <code>val('a') = 1</code> 到<code>val('z') = 26</code> 。</p><p>给你一个字符串 <code>s</code> 和整数<code>power</code>，<code>modulo</code>，<code>k</code> 和<code>hashValue</code> 。请你返回 <code>s</code> 中<strong>第一个</strong> 长度为 <code>k</code> 的 <strong>子串</strong><code>sub</code> ，满足<code>hash(sub, power, modulo) == hashValue</code> 。</p><p>测试数据保证一定 <strong>存在</strong> 至少一个这样的子串。</p><p><strong>子串</strong> 定义为一个字符串中连续非空字符组成的序列。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-built_in">power</span> = <span class="hljs-number">7</span>, modulo = <span class="hljs-number">20</span>, k = <span class="hljs-number">2</span>, hashValue = <span class="hljs-number">0</span><br>输出：<span class="hljs-string">&quot;ee&quot;</span><br>解释：<span class="hljs-string">&quot;ee&quot;</span> 的哈希值为 hash(<span class="hljs-string">&quot;ee&quot;</span>, <span class="hljs-number">7</span>, <span class="hljs-number">20</span>) = (<span class="hljs-number">5</span> * <span class="hljs-number">1</span> + <span class="hljs-number">5</span> * <span class="hljs-number">7</span>) <span class="hljs-built_in">mod</span> <span class="hljs-number">20</span> = <span class="hljs-number">40</span> <span class="hljs-built_in">mod</span> <span class="hljs-number">20</span> = <span class="hljs-number">0</span> 。<br><span class="hljs-string">&quot;ee&quot;</span> 是长度为 <span class="hljs-number">2</span> 的第一个哈希值为 <span class="hljs-number">0</span> 的子串，所以我们返回 <span class="hljs-string">&quot;ee&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：s = &quot;fbxzaad&quot;, power = 31, modulo = 100, k = 3, hashValue = 32<br>输出：&quot;fbx&quot;<br>解释：&quot;fbx&quot; 的哈希值为 hash(&quot;fbx&quot;, 31, 100) = (6 *<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>*<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 24 </span>* 312) mod<span class="hljs-number"> 100 </span>=<span class="hljs-number"> 23132 </span>mod<span class="hljs-number"> 100 </span>=<span class="hljs-number"> 32 </span>。<br>&quot;bxz&quot; 的哈希值为 hash(&quot;bxz&quot;, 31, 100) = (2 *<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 24 </span>*<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 26 </span>* 312) mod<span class="hljs-number"> 100 </span>=<span class="hljs-number"> 25732 </span>mod<span class="hljs-number"> 100 </span>=<span class="hljs-number"> 32 </span>。<br>&quot;fbx&quot; 是长度为<span class="hljs-number"> 3 </span>的第一个哈希值为<span class="hljs-number"> 32 </span>的子串，所以我们返回 &quot;fbx&quot; 。<br>注意，&quot;bxz&quot; 的哈希值也为<span class="hljs-number"> 32 </span>，但是它在字符串中比 &quot;fbx&quot; 更晚出现。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= s.length &lt;= 2 * 10^4</code></li><li><code>1 &lt;= power, modulo &lt;= 10^9</code></li><li><code>0 &lt;= hashValue &lt; modulo</code></li><li><code>s</code> 只包含小写英文字母。</li><li>测试数据保证一定 <strong>存在</strong> 满足条件的子串。</li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>因为给定的公式是<code>hash(s, p, m) = (val(s[0]) * p^0 + val(s[1]) * p^1 + ... + val(s[k-1]) * p^(k-1)) mod m</code>.所以当我们可以先计算字符串中最后一个长度为k的子字符串hash(s[n- k], p, m)，作为初始窗口。</p><p>滑动窗口的过程中，先前的结果减去最后一个字符计算出的值val(s[n - 1] *p^(k - 1))，接着整体乘以p，再加上s[n - k -1]，就可以实现结果的复用。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">subStrHash</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> power, <span class="hljs-type">int</span> modulo, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> hashValue)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> pPower = <span class="hljs-number">1</span>; <span class="hljs-comment">// p的次方，用于记录p的k-1次</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 总和</span><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), left = n - k, right = n - <span class="hljs-number">1</span>, ans = n;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; i++) &#123;<br>            sum = (sum + (pPower * (s[i] - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>)) % modulo) % modulo;<br>            <span class="hljs-keyword">if</span> (i != right)<br>                pPower = (pPower * (power % modulo)) % modulo;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum == hashValue) &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, left); <span class="hljs-comment">// 不要直接读取字符串，浪费时间</span><br>        &#125;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span> &lt; left) &#123; <span class="hljs-comment">// 移动滑动窗口，重复读入、弹出、计算答案的三步骤</span><br>            sum = (sum - (pPower * (s[right--] - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>) % modulo) + modulo) % modulo;<br>            sum = (sum * power) % modulo;<br>            left--;<br>            sum = (sum + (s[left] - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>)) % modulo;<br>            <span class="hljs-keyword">if</span> (sum == hashValue) &#123;<br>                ans = <span class="hljs-built_in">min</span>(ans, left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(ans, k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>同余运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-substring-with-concatenation-of-all-words/submissions</title>
    <link href="/2024/10/02/Leetcode-substring-with-concatenation-of-all-words-submissions/"/>
    <url>/2024/10/02/Leetcode-substring-with-concatenation-of-all-words-submissions/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给定一个字符串 <code>s</code> 和一个字符串数组<code>words</code><strong>。</strong> <code>words</code> 中所有字符串<strong>长度相同</strong>。</p><p><code>s</code> 中的 <strong>串联子串</strong> 是指一个包含<code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p><ul><li>例如，如果 <code>words = ["ab","cd","ef"]</code>， 那么<code>"abcdef"</code>， <code>"abefcd"</code>，<code>"cdabef"</code>，<code>"cdefab"</code>，<code>"efabcd"</code>， 和 <code>"efcdab"</code>都是串联子串。 <code>"acdbef"</code> 不是串联子串，因为他不是任何<code>words</code> 排列的连接。</li></ul><p>返回所有串联子串在 <code>s</code> 中的开始索引。你可以以<strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：s = <span class="hljs-string">&quot;barfoothefoobarman&quot;</span>, words = <span class="hljs-selector-attr">[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>]</span><br>输出：<span class="hljs-selector-attr">[0,9]</span><br>解释：因为 words<span class="hljs-selector-class">.length</span> == <span class="hljs-number">2</span> 同时 words<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.length</span> == <span class="hljs-number">3</span>，连接的子字符串的长度必须为 <span class="hljs-number">6</span>。<br>子串 <span class="hljs-string">&quot;barfoo&quot;</span> 开始位置是 <span class="hljs-number">0</span>。它是 words 中以 <span class="hljs-selector-attr">[<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-string">&quot;foo&quot;</span>]</span> 顺序排列的连接。<br>子串 <span class="hljs-string">&quot;foobar&quot;</span> 开始位置是 <span class="hljs-number">9</span>。它是 words 中以 <span class="hljs-selector-attr">[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>]</span> 顺序排列的连接。<br>输出顺序无关紧要。返回 <span class="hljs-selector-attr">[9,0]</span> 也是可以的。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：s = <span class="hljs-string">&quot;wordgoodgoodgoodbestword&quot;</span>, <span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;word&quot;</span>,<span class="hljs-string">&quot;good&quot;</span>,<span class="hljs-string">&quot;best&quot;</span>,<span class="hljs-string">&quot;word&quot;</span>]<br>输出：[]<br>解释：因为 <span class="hljs-built_in">words</span>.<span class="hljs-built_in">length</span> == <span class="hljs-number">4</span> 并且 <span class="hljs-built_in">words</span>[i].<span class="hljs-built_in">length</span> == <span class="hljs-number">4</span>，所以串联子串的长度必须为 <span class="hljs-number">16</span>。<br>s 中没有子串长度为 <span class="hljs-number">16</span> 并且等于 <span class="hljs-built_in">words</span> 的任何顺序排列的连接。<br>所以我们返回一个空数组。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：s = <span class="hljs-string">&quot;barfoofoobarthefoobarman&quot;</span>, <span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;the&quot;</span>]<br>输出：[<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">12</span>]<br>解释：因为 <span class="hljs-built_in">words</span>.<span class="hljs-built_in">length</span> == <span class="hljs-number">3</span> 并且 <span class="hljs-built_in">words</span>[i].<span class="hljs-built_in">length</span> == <span class="hljs-number">3</span>，所以串联子串的长度必须为 <span class="hljs-number">9</span>。<br>子串 <span class="hljs-string">&quot;foobarthe&quot;</span> 开始位置是 <span class="hljs-number">6</span>。它是 <span class="hljs-built_in">words</span> 中以 [<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-string">&quot;the&quot;</span>] 顺序排列的连接。<br>子串 <span class="hljs-string">&quot;barthefoo&quot;</span> 开始位置是 <span class="hljs-number">9</span>。它是 <span class="hljs-built_in">words</span> 中以 [<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-string">&quot;the&quot;</span>,<span class="hljs-string">&quot;foo&quot;</span>] 顺序排列的连接。<br>子串 <span class="hljs-string">&quot;thefoobar&quot;</span> 开始位置是 <span class="hljs-number">12</span>。它是 <span class="hljs-built_in">words</span> 中以 [<span class="hljs-string">&quot;the&quot;</span>,<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>] 顺序排列的连接。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>1 &lt;= words.length &lt;= 5000</code></li><li><code>1 &lt;= words[i].length &lt;= 30</code></li><li><code>words[i]</code> 和 <code>s</code> 由小写英文字母组成</li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>因为所有的单词都是一样长度，如果可以将所有的单词都看作是一个字符，然后题目就变为了在字符串中找以这些字符组成的子字符串，就会简单。</p><p>我们用哈希表记录哪些单词需要多少次，然后创建定长的滑动窗口，每次加载一个单词长度的字符时，就改变一次哈希表，如果哈希表中的string登记次数为0，就将其erase，进而计算答案时就可以根据哈希表长度是否为0进行判断是否满足条件。</p><p>起始窗口应当从[0,wordLen)的区间进行枚举，这样才能找到所有的子字符串。</p><p><strong>时间复杂度：</strong>O(wordLen *sLen)，wordLen是单词的长度，sLen是字符串的长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findSubstring</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        <span class="hljs-type">int</span> wordLen = words[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(), wordsLen = words.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> sLen = s.<span class="hljs-built_in">size</span>(), left, right;<br>        unordered_map&lt;string, <span class="hljs-type">int</span>&gt; map; <span class="hljs-comment">// &lt;字符, 需要的次数&gt;，如果需要次数为0，删除。</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <br>        <span class="hljs-keyword">if</span> (wordLen * wordsLen &gt; sLen) <br>            <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; wordLen; i++) &#123; <span class="hljs-comment">// 遍历不同的起始位置,因为单词可以是从任意一个位置开始计算。</span><br>            left = i;<br>            right = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; wordsLen; j++) &#123; <span class="hljs-comment">// 登记需要哪些单词，需要多少次。</span><br>                map[words[j]]++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (right &lt; wordsLen * wordLen) &#123; <span class="hljs-comment">// 构建初始窗口</span><br>                string word = s.<span class="hljs-built_in">substr</span>(right, wordLen);<br>                right = right + wordLen;<br>                map[word]--; <span class="hljs-comment">// 窗口中加入了一个词，需要减少所需次数</span><br>                <span class="hljs-keyword">if</span> (map[word] == <span class="hljs-number">0</span>) <br>                    map.<span class="hljs-built_in">erase</span>(word);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-comment">// 计算答案</span><br>                ans.<span class="hljs-built_in">emplace_back</span>(left);<br>            <span class="hljs-keyword">while</span> (right &lt; sLen) &#123; <span class="hljs-comment">// 重复移动滑动窗口</span><br>                string word = s.<span class="hljs-built_in">substr</span>(left, wordLen);<br>                left = left + wordLen;<br>                map[word]++; <span class="hljs-comment">// 窗口中移除一个词，需要增加所需次数</span><br>                <span class="hljs-keyword">if</span> (map[word] == <span class="hljs-number">0</span>) <br>                    map.<span class="hljs-built_in">erase</span>(word);<br>                word = s.<span class="hljs-built_in">substr</span>(right, wordLen);<br>                right = right + wordLen;<br>                map[word]--; <span class="hljs-comment">// 窗口中加入一个词，需要减少所需次数</span><br>                <span class="hljs-keyword">if</span> (map[word] == <span class="hljs-number">0</span>) <br>                    map.<span class="hljs-built_in">erase</span>(word);<br>                <span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-comment">// 计算答案</span><br>                    ans.<span class="hljs-built_in">emplace_back</span>(left);<br>            &#125;<br>            map.<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-find-all-anagrams-in-a-string</title>
    <link href="/2024/10/02/Leetcode-find-all-anagrams-in-a-string/"/>
    <url>/2024/10/02/Leetcode-find-all-anagrams-in-a-string/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code>中所有 <code>p</code> 的 <strong>异位词</strong>的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。</strong></p><p><strong>示例 1:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;cbaebabacd&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出: <span class="hljs-selector-attr">[0,6]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;cba&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">&quot;bac&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;abab&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;ab&quot;</span><br>输出: <span class="hljs-selector-attr">[0,1,2]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">1</span> 的子串是 <span class="hljs-string">&quot;ba&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">2</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, p.length &lt;= 3 * 104</code></li><li><code>s</code> 和 <code>p</code> 仅包含小写字母</li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>先计算字符串p的字母分布，然后在字符串s中进行定长滑动窗口，检查滑动窗口中的分布和p的分布是否相同，相同就记录答案。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> pSize = p.<span class="hljs-built_in">size</span>(), pArray[<span class="hljs-number">26</span>] = &#123;&#125;, sSize = s.<span class="hljs-built_in">size</span>(), sArray[<span class="hljs-number">26</span>] = &#123;&#125;, left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; p.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pSize; i++) <span class="hljs-comment">// 计算p串分布</span><br>            pArray[p[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-keyword">while</span> (right &lt; pSize) <span class="hljs-comment">// 构建初始窗口</span><br>            sArray[s[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(pArray, sArray)) ans.<span class="hljs-built_in">emplace_back</span>(left); <span class="hljs-comment">// 检查结果</span><br>        <span class="hljs-keyword">while</span> (right &lt; sSize) &#123; <span class="hljs-comment">// 移动窗口并计算结果</span><br>            sArray[s[left++] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            sArray[s[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(pArray, sArray)) ans.<span class="hljs-built_in">emplace_back</span>(left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> pArray[], <span class="hljs-type">int</span> sArray[])</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (pArray[i] != sArray[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-permutation-in-string</title>
    <link href="/2024/10/02/Leetcode-permutation-in-string/"/>
    <url>/2024/10/02/Leetcode-permutation-in-string/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断<code>s2</code> 是否包含 <code>s1</code> 的 排列。如果是，返回<code>true</code> ；否则，返回 <code>false</code> 。</p><p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的<strong>子串</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;ab&quot;</span> <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;eidbaooo&quot;</span><br>输出：true<br>解释：<span class="hljs-built_in">s2</span> 包含 <span class="hljs-built_in">s1</span> 的排列之一 (<span class="hljs-string">&quot;ba&quot;</span>).<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s1<span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span> s2 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;eidboaoo&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s1.length, s2.length &lt;= 10^4</code></li><li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li></ul><h2 id="题解">2 题解</h2><p><strong>思路：</strong></p><p>先将s1中所有的字符分布记录到数组中，之后就是对s2进行定长的滑动窗口，每次滑完之后，就验证窗口中的分布和s1的分布是否相同。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &gt; s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> s1Alpha[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); i++) &#123;<br>            s1Alpha[s1[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125; <span class="hljs-comment">// 统计s1中各种字母的分布情况。</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, k = s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(), n = s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> s2Alpha[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <br>        <span class="hljs-keyword">while</span> (right &lt; k) &#123; <span class="hljs-comment">// 构造初始窗口</span><br>            s2Alpha[s2[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(s1Alpha, s2Alpha)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 计算答案</span><br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123; <span class="hljs-comment">// 移动左右指针</span><br>            s2Alpha[s2[left++] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            s2Alpha[s2[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(s1Alpha, s2Alpha)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 计算答案</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> s1Alpha[], <span class="hljs-type">int</span> s2Alpha[])</span> </span>&#123; <span class="hljs-comment">// 统计答案</span><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(s1Alpha[i] != s2Alpha[i]) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-minimum-swaps-to-group-all-1s-together-ii</title>
    <link href="/2024/10/02/Leetcode-minimum-swaps-to-group-all-1s-together-ii/"/>
    <url>/2024/10/02/Leetcode-minimum-swaps-to-group-all-1s-together-ii/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p><strong>交换</strong> 定义为选中一个数组中的两个<strong>互不相同</strong> 的位置并交换二者的值。</p><p><strong>环形</strong> 数组是一个数组，可以认为<strong>第一个</strong> 元素和 <strong>最后一个</strong> 元素<strong>相邻</strong> 。</p><p>给你一个 <strong>二进制环形</strong> 数组 <code>nums</code> ，返回在<strong>任意位置</strong> 将数组中的所有 <code>1</code>聚集在一起需要的最少交换次数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [0,1,0,1,1,0,0]<br>输出：1<br>解释：这里列出一些能够将所有<span class="hljs-number"> 1 </span>聚集在一起的方案：<br>[0,0,1,1,1,0,0] 交换<span class="hljs-number"> 1 </span>次。<br>[0,1,1,1,0,0,0] 交换<span class="hljs-number"> 1 </span>次。<br>[1,1,0,0,0,0,1] 交换<span class="hljs-number"> 2 </span>次（利用数组的环形特性）。<br>无法在交换<span class="hljs-number"> 0 </span>次的情况下将数组中的所有<span class="hljs-number"> 1 </span>聚集在一起。<br>因此，需要的最少交换次数为<span class="hljs-number"> 1 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [0,1,1,1,0,0,1,1,0]<br>输出：2<br>解释：这里列出一些能够将所有<span class="hljs-number"> 1 </span>聚集在一起的方案：<br>[1,1,1,0,0,0,0,1,1] 交换<span class="hljs-number"> 2 </span>次（利用数组的环形特性）。<br>[1,1,1,1,1,0,0,0,0] 交换<span class="hljs-number"> 2 </span>次。<br>无法在交换<span class="hljs-number"> 0 </span>次或<span class="hljs-number"> 1 </span>次的情况下将数组中的所有<span class="hljs-number"> 1 </span>聚集在一起。<br>因此，需要的最少交换次数为<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,1,0,0,1]<br>输出：0<br>解释：得益于数组的环形特性，所有的<span class="hljs-number"> 1 </span>已经聚集在一起。<br>因此，需要的最少交换次数为<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>nums[i]</code> 为 <code>0</code> 或者 <code>1</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>先找出数组中一共有多少个1，根据个数可以设定滑动窗口的长度，目标是找到一个位置，包含最少的0，然后将1换入即可。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSwaps</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> k = <span class="hljs-built_in">accumulate</span>(<span class="hljs-built_in">begin</span>(nums), <span class="hljs-built_in">end</span>(nums), <span class="hljs-number">0</span>); <span class="hljs-comment">// 一共有多少个1</span><br>        <span class="hljs-comment">// 接下来题目转换为在环形二进制数组中找出长度为k的所有定长子数组中，含有0最少的是多少。</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; k) &#123; <span class="hljs-comment">// 构建初始窗口</span><br>            count = count + !nums[right % n];<br>            right++;<br>        &#125;<br>        ans = count; <span class="hljs-comment">// 计算答案</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 滑动窗口</span><br>            count = count - !nums[left % n] + !nums[right % n];<br>            left++;<br>            right++;<br>            ans = <span class="hljs-built_in">min</span>(ans, count); <span class="hljs-comment">// 计算答案</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-sliding-subarray-beauty</title>
    <link href="/2024/10/02/Leetcode-sliding-subarray-beauty/"/>
    <url>/2024/10/02/Leetcode-sliding-subarray-beauty/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code>，请你求出每个长度为 <code>k</code> 的子数组的 <strong>美丽值</strong>。</p><p>一个子数组的 <strong>美丽值</strong> 定义为：如果子数组中第<code>x</code> <strong>小整数</strong> 是 <strong>负数</strong>，那么美丽值为第 <code>x</code> 小的数，否则美丽值为 <code>0</code>。</p><p>请你返回一个包含 <code>n - k + 1</code>个整数的数组，<strong>依次</strong>表示数组中从第一个下标开始，每个长度为 <code>k</code> 的子数组的<strong>美丽值</strong> 。</p><ul><li>子数组指的是数组中一段连续 <strong>非空</strong> 的元素序列。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,<span class="hljs-string">-1</span>,<span class="hljs-string">-3</span>,<span class="hljs-string">-2</span>,3], k = 3, x = 2<br>输出：[<span class="hljs-string">-1</span>,<span class="hljs-string">-2</span>,<span class="hljs-string">-2</span>]<br>解释：总共有 3 个 k = 3 的子数组。<br>第一个子数组是 [1, <span class="hljs-string">-1</span>, <span class="hljs-string">-3</span>] ，第二小的数是负数 <span class="hljs-string">-1</span> 。<br>第二个子数组是 [<span class="hljs-string">-1</span>, <span class="hljs-string">-3</span>, <span class="hljs-string">-2</span>] ，第二小的数是负数 <span class="hljs-string">-2</span> 。<br>第三个子数组是 [<span class="hljs-string">-3</span>, <span class="hljs-string">-2</span>, 3] ，第二小的数是负数 <span class="hljs-string">-2</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>,<span class="hljs-string">-4</span>,<span class="hljs-string">-5</span>], k = 2, x = 2<br>输出：[<span class="hljs-string">-1</span>,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>,<span class="hljs-string">-4</span>]<br>解释：总共有 4 个 k = 2 的子数组。<br>[<span class="hljs-string">-1</span>, <span class="hljs-string">-2</span>] 中第二小的数是负数 <span class="hljs-string">-1</span> 。<br>[<span class="hljs-string">-2</span>, <span class="hljs-string">-3</span>] 中第二小的数是负数 <span class="hljs-string">-2</span> 。<br>[<span class="hljs-string">-3</span>, <span class="hljs-string">-4</span>] 中第二小的数是负数 <span class="hljs-string">-3</span> 。<br>[<span class="hljs-string">-4</span>, <span class="hljs-string">-5</span>] 中第二小的数是负数 <span class="hljs-string">-4</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-3</span>,1,2,<span class="hljs-string">-3</span>,0,<span class="hljs-string">-3</span>], k = 2, x = 1<br>输出：[<span class="hljs-string">-3</span>,0,<span class="hljs-string">-3</span>,<span class="hljs-string">-3</span>,<span class="hljs-string">-3</span>]<br>解释：总共有 5 个 k = 2 的子数组。<br>[<span class="hljs-string">-3</span>, 1] 中最小的数是负数 <span class="hljs-string">-3</span> 。<br>[1, 2] 中最小的数不是负数，所以美丽值为 0 。<br>[2, <span class="hljs-string">-3</span>] 中最小的数是负数 <span class="hljs-string">-3</span> 。<br>[<span class="hljs-string">-3</span>, 0] 中最小的数是负数 <span class="hljs-string">-3</span> 。<br>[0, <span class="hljs-string">-3</span>] 中最小的数是负数 <span class="hljs-string">-3</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= k &lt;= n</code></li><li><code>1 &lt;= x &lt;= k</code></li><li><code>-50 &lt;= nums[i] &lt;= 50</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>因为本题出现的数字只能是[-50,50]，所以我们只要枚举即可，其他部分就是简单的滑动窗口。</p><p><strong>时间复杂度：</strong>O(101n)，也就是O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getSubarrayBeauty</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n - (k  - <span class="hljs-number">1</span>), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> array[<span class="hljs-number">101</span>] = &#123;<span class="hljs-number">0</span>&#125;, left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; k) &#123;<br>            array[nums[right++] + <span class="hljs-number">50</span>]++;<br>        &#125;<br>        tmp = x;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">101</span>; i++) &#123; <span class="hljs-comment">// 计算答案</span><br>            tmp = tmp - array[i];<br>            <span class="hljs-keyword">if</span> (tmp &lt;= <span class="hljs-number">0</span>) &#123;<br>                ans[left] = <span class="hljs-built_in">min</span>(i - <span class="hljs-number">50</span>, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123; <span class="hljs-comment">// 不断枚举左端点，移动右端点。</span><br>            array[nums[left++] + <span class="hljs-number">50</span>]--;<br>            array[nums[right++] + <span class="hljs-number">50</span>]++;<br>            tmp = x;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">101</span>; i++) &#123;<br>                tmp = tmp - array[i];<br>                <span class="hljs-keyword">if</span> (tmp &lt;= <span class="hljs-number">0</span>) &#123;<br>                    ans[left] = <span class="hljs-built_in">min</span>(i - <span class="hljs-number">50</span>, <span class="hljs-number">0</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-maximum-number-of-occurrences-of-a-substring</title>
    <link href="/2024/10/02/Leetcode-maximum-number-of-occurrences-of-a-substring/"/>
    <url>/2024/10/02/Leetcode-maximum-number-of-occurrences-of-a-substring/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个字符串 <code>s</code> ，请你返回满足以下条件且出现次数最大的<strong>任意</strong> 子串的出现次数：</p><ul><li>子串中不同字母的数目必须小于等于 <code>maxLetters</code> 。</li><li>子串的长度必须大于等于 <code>minSize</code> 且小于等于<code>maxSize</code> 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">输入：s = <span class="hljs-string">&quot;aababcaab&quot;</span>, <span class="hljs-keyword">max</span>Letters = <span class="hljs-number">2</span>, <span class="hljs-keyword">min</span>Size = <span class="hljs-number">3</span>, <span class="hljs-keyword">max</span>Size = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">2</span><br>解释：子串 <span class="hljs-string">&quot;aab&quot;</span> 在原字符串中出现了 <span class="hljs-number">2</span> 次。<br>它满足所有的要求：<span class="hljs-number">2</span> 个不同的字母，长度为 <span class="hljs-number">3</span> （在 <span class="hljs-keyword">min</span>Size 和 <span class="hljs-keyword">max</span>Size 范围内）。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">输入：s = <span class="hljs-string">&quot;aaaa&quot;</span>, <span class="hljs-keyword">max</span>Letters = <span class="hljs-number">1</span>, <span class="hljs-keyword">min</span>Size = <span class="hljs-number">3</span>, <span class="hljs-keyword">max</span>Size = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br>解释：子串 <span class="hljs-string">&quot;aaa&quot;</span> 在原字符串中出现了 <span class="hljs-number">2</span> 次，且它们有重叠部分。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf">输入：s = <span class="hljs-string">&quot;aabcabcab&quot;</span>, <span class="hljs-keyword">max</span>Letters = <span class="hljs-number">2</span>, <span class="hljs-keyword">min</span>Size = <span class="hljs-number">2</span>, <span class="hljs-keyword">max</span>Size = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf">输入：s = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-keyword">max</span>Letters = <span class="hljs-number">2</span>, <span class="hljs-keyword">min</span>Size = <span class="hljs-number">3</span>, <span class="hljs-keyword">max</span>Size = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>1 &lt;= maxLetters &lt;= 26</code></li><li><code>1 &lt;= minSize &lt;= maxSize &lt;= min(26, s.length)</code></li><li><code>s</code> 只包含小写英文字母。</li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>枚举长度为[minSize,maxSize]的滑动窗口，判断这些滑动窗口中的子字符串是否满足要求，满足就记录到哈希表中，分别使用一个string以及一个int记录出现次数最多的子字符串和出现次数。</p><p>但是进一步来说，我们只要进行长度为minSize的滑动窗口计算即可，长度更短的滑动窗口的答案一定是大于等于长度更长的滑动窗口的答案。因为长字符串出现了beta次时，短字符串也一定出现了beta次，但短字符串可能会有更多。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxFreq</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> maxLetters, <span class="hljs-type">int</span> minSize, <span class="hljs-type">int</span> maxSize)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">freqForK</span>(s, maxLetters, minSize);<br>    &#125;<br><br>    <span class="hljs-comment">// 计算固定长度为k的时候，满足条件的答案数量。</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">freqForK</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> maxLetters, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> alpha[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;, count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 字符出出现的次数，出现了多少种字符</span><br>        unordered_map&lt;string, <span class="hljs-type">int</span>&gt; map; <span class="hljs-comment">// 记录&lt;符合要求的子串, 出现次数&gt;</span><br>        string maxString = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">int</span> maxStringCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// 只记录出现次数最多的的字符串以及出现次数。</span><br>        <br>        <span class="hljs-keyword">while</span> (right &lt; k) &#123; <span class="hljs-comment">// 构造初始窗口</span><br>            count = count + (alpha[s[right] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>);<br>            alpha[s[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count &lt;= maxLetters) &#123; <span class="hljs-comment">// 如果符合条件，记录满足条件的子串以及出现的次数。</span><br>            maxString = s.<span class="hljs-built_in">substr</span>(left, right - left);<br>            maxStringCount = <span class="hljs-number">1</span>;<br>            map[maxString] = maxStringCount;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123; <span class="hljs-comment">// 读入-弹出-计算答案</span><br>            count = count - (alpha[s[left] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">1</span>);<br>            alpha[s[left++] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            count = count + (alpha[s[right] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>);<br>            alpha[s[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-keyword">if</span> (count &lt;= maxLetters) &#123;<br>                string tmpStr = s.<span class="hljs-built_in">substr</span>(left, right - left);<br>                map[tmpStr]++;<br>                <span class="hljs-keyword">if</span> (map[tmpStr] &gt; maxStringCount) &#123;<br>                    maxStringCount = map[tmpStr];<br>                    maxString = tmpStr;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxStringCount;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-maximum-points-you-can-obtain-from-cards</title>
    <link href="/2024/10/02/Leetcode-maximum-points-you-can-obtain-from-cards/"/>
    <url>/2024/10/02/Leetcode-maximum-points-you-can-obtain-from-cards/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>几张卡牌<strong>排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组<code>cardPoints</code> 给出。</p><p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿<code>k</code> 张卡牌。</p><p>你的点数就是你拿到手中的所有卡牌的点数之和。</p><p>给你一个整数数组 <code>cardPoints</code> 和整数<code>k</code>，请你返回可以获得的最大点数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cardPoints = [1,2,3,4,5,6,1], k = 3<br>输出：12<br>解释：第一次行动，不管拿哪张牌，你的点数总是<span class="hljs-number"> 1 </span>。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 12 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：cardPoints </span>=<span class="hljs-string"> [2,2,2], k = 2</span><br><span class="hljs-string">输出：4</span><br><span class="hljs-string">解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：cardPoints = <span class="hljs-string">[9,7,7,9,7,7,9]</span>, k = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">55</span><br>解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：cardPoints = [<span class="hljs-number">1,1000,1</span>], k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 <span class="hljs-number">1</span> 。 <br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：cardPoints = [<span class="hljs-number">1,79,80,1</span>,<span class="hljs-number">1,1,200,1</span>], k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">202</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= cardPoints.length &lt;= 10^5</code></li><li><code>1 &lt;= cardPoints[i] &lt;= 10^4</code></li><li><code>1 &lt;= k &lt;= cardPoints.length</code></li></ul><h2 id="题解">2 题解</h2><p><strong>思路：</strong></p><p>每次只能从头或者从尾取，说明最后会有中间一部分留下，转换思路，要求的就是剩余nums.size()- k的定长子数组最小和是多少。</p><p><strong>时间复杂的：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cardPoints, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = cardPoints.<span class="hljs-built_in">size</span>();<br>        k = n - k;<br>        <br>        <span class="hljs-comment">// 将题目转换成，从cardPoints中找到长度为k的子数组，但是值最小的结果。</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; k &amp;&amp; right &lt; n) &#123;<br>            sum = sum + cardPoints[right++];<br>        &#125;<br>        ans = sum;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            sum = sum - cardPoints[left++] + cardPoints[right++];<br>            ans = <span class="hljs-built_in">min</span>(ans, sum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(<span class="hljs-built_in">begin</span>(cardPoints), <span class="hljs-built_in">end</span>(cardPoints), <span class="hljs-number">0</span>) - ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-maximum-sum-of-almost-unique-subarray</title>
    <link href="/2024/10/02/Leetcode-maximum-sum-of-almost-unique-subarray/"/>
    <url>/2024/10/02/Leetcode-maximum-sum-of-almost-unique-subarray/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个整数数组 <code>nums</code> 和两个正整数 <code>m</code> 和<code>k</code> 。</p><p>请你返回 <code>nums</code> 中长度为 <code>k</code> 的<strong>几乎唯一</strong> 子数组的 <strong>最大和</strong>，如果不存在几乎唯一子数组，请你返回 <code>0</code> 。</p><p>如果 <code>nums</code> 的一个子数组有至少 <code>m</code>个互不相同的元素，我们称它是 <strong>几乎唯一</strong> 子数组。</p><p>子数组指的是一个数组中一段连续 <strong>非空</strong> 的元素序列。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[2,6,7,3,1,7]</span>, m = <span class="hljs-number">3</span>, k = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">18</span><br>解释：总共有 <span class="hljs-number">3</span> 个长度为 k = <span class="hljs-number">4</span> 的几乎唯一子数组。分别为 <span class="hljs-string">[2, 6, 7, 3]</span> ，<span class="hljs-string">[6, 7, 3, 1]</span> 和 <span class="hljs-string">[7, 3, 1, 7]</span> 。这些子数组中，和最大的是 <span class="hljs-string">[2, 6, 7, 3]</span> ，和为 <span class="hljs-number">18</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,9,9,2,4,5,4]</span>, m = 1, k = 3<br>输出：23<br>解释：总共有 5 个长度为 k = 3 的几乎唯一子数组。分别为 <span class="hljs-comment">[5, 9, 9]</span> ，<span class="hljs-comment">[9, 9, 2]</span> ，<span class="hljs-comment">[9, 2, 4]</span> ，<span class="hljs-comment">[2, 4, 5]</span> 和 <span class="hljs-comment">[4, 5, 4]</span> 。这些子数组中，和最大的是 <span class="hljs-comment">[5, 9, 9]</span> ，和为 23 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,1,2,1,2,1], m = 3, k = 3<br>输出：0<br>解释：输入数组中不存在长度为 k =<span class="hljs-number"> 3 </span>的子数组含有至少  m =<span class="hljs-number"> 3 </span>个互不相同元素的子数组。所以不存在几乎唯一子数组，最大和为<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li><li><code>1 &lt;= m &lt;= k &lt;= nums.length</code></li><li><code>1 &lt;= nums[i] &lt;= 10^9</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>使用sum记录滑动窗口的总和，map记录每种数字的出现次数，count记录有多少种数字。</p><p>先构造初始的窗口并计算答案，之后重复</p><ul><li>读入</li><li>弹出</li><li>计算答案</li></ul><p>但是需要注意的是，读入弹出的过程最好是一步步来。如果left和right指向的元素是同一个时，使用map直接判断个数，容易出错。比如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">count = count - (map[nums[left]] == <span class="hljs-number">1</span>) + (map[nums[right]] == <span class="hljs-number">0</span>); <span class="hljs-comment">// 当nums[left] === nums[right]时，并且map[nums[left]] = 1时，就会存在问题，count会被归零。</span><br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maxSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map; <span class="hljs-comment">// 记录&lt;数字，出现次数&gt;</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 已经存在多少种数字，因为map中可能会存在出现次数为0的情况，erase太麻烦了，直接用count记录更佳。</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (right &lt; k) &#123; <span class="hljs-comment">// 构造基础滑动窗口</span><br>            count = count + (map[nums[right]] == <span class="hljs-number">0</span>);<br>            sum = sum + nums[right];<br>            map[nums[right++]]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count &gt;= m) &#123; <span class="hljs-comment">// 计算答案</span><br>            ans = sum;;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            count = count - (map[nums[left]] == <span class="hljs-number">1</span>); <span class="hljs-comment">// 这部分的内容需要分两步走，因为nums[left]和nums[right]可能相同，每一次使用map[nums[xx]]判定是否等于0或1，就已经假定变化了。</span><br>            map[nums[left]]--;<br>            count = count + (map[nums[right]] == <span class="hljs-number">0</span>); <span class="hljs-comment">// 更新滑动窗口中的数值种类</span><br>            map[nums[right]]++; <span class="hljs-comment">// 更新每种数字的个数</span><br>        <br>            sum = sum - nums[left] + nums[right]; <span class="hljs-comment">// 更新滑动窗口的总和</span><br>            left++;<br>            right++;<br>            <span class="hljs-keyword">if</span> (count &gt;= m) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, sum);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-grumpy-bookstore-owner</title>
    <link href="/2024/10/02/Leetcode-grumpy-bookstore-owner/"/>
    <url>/2024/10/02/Leetcode-grumpy-bookstore-owner/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>有一个书店老板，他的书店开了 <code>n</code>分钟。每分钟都有一些顾客进入这家商店。给定一个长度为 <code>n</code>的整数数组 <code>customers</code> ，其中 <code>customers[i]</code>是在第 <code>i</code> 分钟开始时进入商店的顾客数量，所有这些顾客在第<code>i</code> 分钟结束后离开。</p><p>在某些分钟内，书店老板会生气。 如果书店老板在第 <code>i</code>分钟生气，那么 <code>grumpy[i] = 1</code>，否则<code>grumpy[i] = 0</code>。</p><p>当书店老板生气时，那一分钟的顾客就会不满意，若老板不生气则顾客是满意的。</p><p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续<code>minutes</code> 分钟不生气，但却只能使用一次。</p><p>请你返回 <em>这一天营业下来，最多有多少客户能够感到满意</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3<br>输出：16<br>解释：书店老板在最后<span class="hljs-number"> 3 </span>分钟保持冷静。<br>感到满意的最大客户数量 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 5 </span>= 16.<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：customers = <span class="hljs-comment">[1]</span>, grumpy = <span class="hljs-comment">[0]</span>, minutes = 1<br>输出：1<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == customers.length == grumpy.length</code></li><li><code>1 &lt;= minutes &lt;= n &lt;= 2 * 10^4</code></li><li><code>0 &lt;= customers[i] &lt;= 1000</code></li><li><code>grumpy[i] == 0 or 1</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>需要注意的是，不生气的时候是0，生气的时候是1。</p><p>先计算出所有不生气时候的基础答案是多少，接着将customers和grumpy对应相乘，根据定长滑动窗口进一步求出可以弥补的答案是多少，相加为最终答案。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSatisfied</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; customers, vector&lt;<span class="hljs-type">int</span>&gt;&amp; grumpy, <span class="hljs-type">int</span> minutes)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, n = customers.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 计算出所有本来就能够感到满意的客户。</span><br>            ans = ans + customers[i] * (!grumpy[i]); <span class="hljs-comment">// 这里需要将0和1取反，应该使用!而不是~,~是所有位全部取反。</span><br>            customers[i] = customers[i] * grumpy[i]; <span class="hljs-comment">// 更新customers为所有不会感觉满意的客户。</span><br>        &#125;<br>        <span class="hljs-comment">// 接下来变成找到定长为minutes的滑动窗口，目标数组是customers和grumpy对应相乘的结果，求出最大的结果。</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; minutes &amp;&amp; right &lt; n) &#123;<br>            count = count + customers[right++];<br>        &#125;<br>        res = count; <span class="hljs-comment">// 计算一次答案。</span><br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            count = count - customers[left++] + customers[right++];<br>            res = <span class="hljs-built_in">max</span>(res, count);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans + res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-defuse-the-bomb</title>
    <link href="/2024/10/02/Leetcode-defuse-the-bomb/"/>
    <url>/2024/10/02/Leetcode-defuse-the-bomb/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为<code>n</code> 的 <strong>循环</strong> 数组 <code>code</code>以及一个密钥 <code>k</code> 。</p><p>为了获得正确的密码，你需要替换掉每一个数字。所有数字会<strong>同时</strong> 被替换。</p><ul><li>如果 <code>k &gt; 0</code> ，将第 <code>i</code> 个数字用<strong>接下来</strong> <code>k</code> 个数字之和替换。</li><li>如果 <code>k &lt; 0</code> ，将第 <code>i</code> 个数字用<strong>之前</strong> <code>k</code> 个数字之和替换。</li><li>如果 <code>k == 0</code> ，将第 <code>i</code> 个数字用<code>0</code> 替换。</li></ul><p>由于 <code>code</code> 是循环的， <code>code[n-1]</code> 下一个元素是<code>code[0]</code> ，且 <code>code[0]</code> 前一个元素是<code>code[n-1]</code> 。</p><p>给你 <strong>循环</strong> 数组 <code>code</code> 和整数密钥<code>k</code> ，请你返回解密后的结果来拆除炸弹！</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：code = [5,7,1,4], k = 3<br>输出：[12,10,16,13]<br>解释：每个数字都被接下来 3 个数字之和替换。解密后的密码为 [7<span class="hljs-string">+1</span><span class="hljs-string">+4</span>, 1<span class="hljs-string">+4</span><span class="hljs-string">+5</span>, 4<span class="hljs-string">+5</span><span class="hljs-string">+7</span>, 5<span class="hljs-string">+7</span><span class="hljs-string">+1</span>]。注意到数组是循环连接的。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-tag">code</span> = <span class="hljs-selector-attr">[1,2,3,4]</span>, k = <span class="hljs-number">0</span><br>输出：<span class="hljs-selector-attr">[0,0,0,0]</span><br>解释：当 k 为 <span class="hljs-number">0</span> 时，所有数字都被 <span class="hljs-number">0</span> 替换。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：code = [2,4,9,3], k = <span class="hljs-string">-2</span><br>输出：[12,5,6,13]<br>解释：解密后的密码为 [3<span class="hljs-string">+9</span>, 2<span class="hljs-string">+3</span>, 4<span class="hljs-string">+2</span>, 9<span class="hljs-string">+4</span>] 。注意到数组是循环连接的。如果 k 是负数，那么和为 之前 的数字。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == code.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= code[i] &lt;= 100</code></li><li><code>-(n - 1) &lt;= k &lt;= n - 1</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><h3 id="思路">思路：</h3><p>一开始想比较麻烦的是需要处理k是大于0还是小于0，这需要找出对应下标，然后计算前k个元素的滑动窗口还是后k个元素的滑动窗口，需要分别处理。</p><p>其实只要计算k个元素的滑动窗口，根据k的大小，决定这个滑动窗口是哪个下标的结果即可。并且移动left和right时，注意是环形数组，需要取余操作。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">decrypt</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; code, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = code.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; <span class="hljs-built_in">abs</span>(k)) &#123; <span class="hljs-comment">// 计算出长度为k的滑动窗口值，k需要取绝对值。</span><br>            count = count + code[right++];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>            ans[(left - <span class="hljs-number">1</span> + n) % n] = count; <span class="hljs-comment">// 这里的移位操作可能越界，所以需要先右移n个单位</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans[right] = count;<br>        &#125; <span class="hljs-comment">// 计算一次答案，根据k的大小决定这个滑动窗口的答案是哪个元素的。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// 计算剩余n - 1个答案</span><br>            count = count - code[left++] + code[right++];<br>            left = left % n;<br>            right = right % n;<br>            <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>            ans[(left - <span class="hljs-number">1</span> + n) % n] = count;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans[right] = count;<br>            &#125; <span class="hljs-comment">// 计算一次答案，根据k的大小决定这个滑动窗口的答案是哪个元素的。</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-minimum-recolors-to-get-k-consecutive-black-blocks</title>
    <link href="/2024/10/01/Leetcode-minimum-recolors-to-get-k-consecutive-black-blocks/"/>
    <url>/2024/10/01/Leetcode-minimum-recolors-to-get-k-consecutive-black-blocks/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个长度为 <code>n</code> 下标从 <strong>0</strong> 开始的字符串<code>blocks</code> ，<code>blocks[i]</code> 要么是 <code>'W'</code>要么是 <code>'B'</code> ，表示第 <code>i</code> 块的颜色。字符<code>'W'</code> 和 <code>'B'</code> 分别表示白色和黑色。</p><p>给你一个整数 <code>k</code> ，表示想要 <strong>连续</strong>黑色块的数目。</p><p>每一次操作中，你可以选择一个白色块将它 <strong>涂成</strong>黑色块。</p><p>请你返回至少出现 <strong>一次</strong> 连续 <code>k</code> 个黑色块的<strong>最少</strong> 操作次数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：blocks = &quot;WBBWWBBWBW&quot;, k = 7<br>输出：3<br>解释：<br>一种得到<span class="hljs-number"> 7 </span>个连续黑色块的方法是把第<span class="hljs-number"> 0 </span>，3 和<span class="hljs-number"> 4 </span>个块涂成黑色。<br>得到 blocks = &quot;BBBBBBBWBW&quot; 。<br>可以证明无法用少于<span class="hljs-number"> 3 </span>次操作得到<span class="hljs-number"> 7 </span>个连续的黑块。<br>所以我们返回<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">输入：<span class="hljs-keyword">blocks </span>= <span class="hljs-string">&quot;WBWBBBW&quot;</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">0</span><br>解释：<br>不需要任何操作，因为已经有 <span class="hljs-number">2</span> 个连续的黑块。<br>所以我们返回 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == blocks.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>blocks[i]</code> 要么是 <code>'W'</code> ，要么是<code>'B'</code> 。</li><li><code>1 &lt;= k &lt;= n</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>计算每个长度为k的子字符串中包含的'W'个数。先构建最初始的滑动窗口，并计算答案，因为滑动窗口的长度题目限定小于字符串长度。后续过程重复：</p><ul><li>读入right，如果是'W'，增加计数</li><li>弹出left，如果是'W'，减少计数</li><li>计算答案</li></ul><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumRecolors</span><span class="hljs-params">(string blocks, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>, n = blocks.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">while</span> (right &lt; k) &#123;<br>            count = count + (blocks[right++] == <span class="hljs-string">&#x27;W&#x27;</span>);<br>        &#125;<br>        ans = count; <span class="hljs-comment">// 无条件计算一次答案。</span><br>        <span class="hljs-keyword">while</span>(right &lt; n) &#123;<br>            count = count - (blocks[left++] == <span class="hljs-string">&#x27;W&#x27;</span>) + (blocks[right++] == <span class="hljs-string">&#x27;W&#x27;</span>);<br>            ans = <span class="hljs-built_in">min</span>(ans, count);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-k-radius-subarray-averages</title>
    <link href="/2024/10/01/Leetcode-k-radius-subarray-averages/"/>
    <url>/2024/10/01/Leetcode-k-radius-subarray-averages/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code>，数组中有 <code>n</code> 个整数，另给你一个整数 <code>k</code> 。</p><p><strong>半径为 k 的子数组平均值</strong> 是指：<code>nums</code>中一个以下标 <code>i</code> 为 <strong>中心</strong> 且<strong>半径</strong> 为 <code>k</code>的子数组中所有元素的平均值，即下标在 <code>i - k</code> 和<code>i + k</code> 范围（<strong>含</strong> <code>i - k</code> 和<code>i + k</code>）内所有元素的平均值。如果在下标 <code>i</code>前或后不足 <code>k</code> 个元素，那么 <strong>半径为 k的子数组平均值</strong> 是 <code>-1</code> 。</p><p>构建并返回一个长度为 <code>n</code> 的数组 <code>avgs</code> ，其中<code>avgs[i]</code> 是以下标 <code>i</code> 为中心的子数组的<strong>半径为 k 的子数组平均值</strong> 。</p><p><code>x</code> 个元素的 <strong>平均值</strong> 是 <code>x</code>个元素相加之和除以 <code>x</code> ，此时使用截断式<strong>整数除法</strong> ，即需要去掉结果的小数部分。</p><ul><li>例如，四个元素 <code>2</code>、<code>3</code>、<code>1</code> 和<code>5</code> 的平均值是<code>(2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75</code>，截断后得到<code>2</code> 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [7,4,3,9,1,8,5,2,6], k = 3<br>输出：[-1,-1,-1,5,4,4,-1,-1,-1]<br>解释：<br>- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。<br>- 中心为下标<span class="hljs-number"> 3 </span>且半径为<span class="hljs-number"> 3 </span>的子数组的元素总和是：7 +<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 8 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 37 </span>。<br>  使用截断式 整数除法，avg[3] =<span class="hljs-number"> 37 </span>/<span class="hljs-number"> 7 </span>=<span class="hljs-number"> 5 </span>。<br>- 中心为下标<span class="hljs-number"> 4 </span>的子数组，avg[4] = (4 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 8 </span>+<span class="hljs-number"> 5 </span>+ 2) /<span class="hljs-number"> 7 </span>=<span class="hljs-number"> 4 </span>。<br>- 中心为下标<span class="hljs-number"> 5 </span>的子数组，avg[5] = (3 +<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 8 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 2 </span>+ 6) /<span class="hljs-number"> 7 </span>=<span class="hljs-number"> 4 </span>。<br>- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [100000], k = 0<br>输出：[100000]<br>解释：<br>- 中心为下标<span class="hljs-number"> 0 </span>且半径<span class="hljs-number"> 0 </span>的子数组的元素总和是：100000 。<br>  avg[0] =<span class="hljs-number"> 100000 </span>/<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 100000 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[8]</span>, k = 100000<br>输出：<span class="hljs-comment">[-1]</span><br>解释：<br>- avg<span class="hljs-comment">[0]</span> 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>0 &lt;= nums[i], k &lt;= 10^5</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>先将不可能存在半径k的节点全部设置为-1。</p><p>计算中心点在[k, n - 1 - k]内的所有总和，使用滑动窗口即可 。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getAverages</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k &amp;&amp; i &lt; n; i++) &#123; <span class="hljs-comment">// 先构造两边的-1。</span><br>            ans[i] = <span class="hljs-number">-1</span>;<br>            ans[n - <span class="hljs-number">1</span> - i] = <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, mid = k, right = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(right &lt; n &amp;&amp; right &lt; <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>) <span class="hljs-comment">// 构造初始的定长滑动窗口。</span><br>            count = count + nums[right++];<br>        <span class="hljs-keyword">if</span>(mid &lt; n - k) <span class="hljs-comment">// 结算答案，但是需要保证mid后面有k个位置不能被动。</span><br>            ans[mid++] = count / (<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span>(right &lt; n) &#123;<br>            count = count - nums[left++] + nums[right++];<br>            ans[mid++] = count / (<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold</title>
    <link href="/2024/10/01/Leetcode-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/"/>
    <url>/2024/10/01/Leetcode-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个整数数组 <code>arr</code> 和两个整数 <code>k</code> 和<code>threshold</code> 。</p><p>请你返回长度为 <code>k</code> 且平均值大于等于 <code>threshold</code>的子数组数目。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr = <span class="hljs-comment">[2,2,2,2,5,5,5,8]</span>, k = 3, threshold = 4<br>输出：3<br>解释：子数组 <span class="hljs-comment">[2,5,5]</span>,<span class="hljs-comment">[5,5,5]</span> 和 <span class="hljs-comment">[5,5,8]</span> 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5<br>输出：6<br>解释：前<span class="hljs-number"> 6 </span>个长度为<span class="hljs-number"> 3 </span>的子数组平均值都大于<span class="hljs-number"> 5 </span>。注意平均值不是整数。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= 10^4</code></li><li><code>1 &lt;= k &lt;= arr.length</code></li><li><code>0 &lt;= threshold &lt;= 10^4</code></li></ul><h2 id="题解">2 题解</h2><p><strong>思路：</strong></p><p>定长动态窗口，在构造了窗口之后，计算答案。接着重复：</p><ul><li>读入right</li><li>弹出left</li><li>计算答案</li></ul><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numOfSubarrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> threshold)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>, limit = threshold * k;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, n = arr.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">while</span> (right &lt; k) &#123;<br>            count = count + arr[right++];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count &gt;= limit) ans++;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            count = count - arr[left++] + arr[right++];<br>            <span class="hljs-keyword">if</span> (count &gt;= limit) ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-maximum-average-subarray-i</title>
    <link href="/2024/10/01/Leetcode-maximum-average-subarray-i/"/>
    <url>/2024/10/01/Leetcode-maximum-average-subarray-i/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个由 <code>n</code> 个元素组成的整数数组 <code>nums</code>和一个整数 <code>k</code> 。</p><p>请你找出平均数最大且 <strong>长度为 <code>k</code></strong>的连续子数组，并输出该最大平均数。</p><p>任何误差小于 <code>10-5</code> 的答案都将被视为正确答案。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,12,<span class="hljs-string">-5</span>,<span class="hljs-string">-6</span>,50,3], k = 4<br>输出：12.75<br>解释：最大平均数 (12<span class="hljs-string">-5</span><span class="hljs-string">-6</span><span class="hljs-string">+50</span>)/4 = 51/4 = 12.75<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">5</span>], k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">5.00000</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= k &lt;= n &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li></ul><h2 id="题解">2 题解</h2><p><strong>思路：</strong></p><p>定长滑动窗口题目，构造好初始窗口后，计算答案。接着重复</p><ul><li>读取right</li><li>弹出left</li><li>计算答案</li></ul><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMaxAverage</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">double</span> ans = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">while</span> (right &lt; k) &#123;<br>            count = count + nums[right++];<br>        &#125;<br>        ans = count;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            count = count - nums[left++] + nums[right++] ;<br>            ans = <span class="hljs-built_in">max</span>(ans, count);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans / k;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-maximum-number-of-vowels-in-a-substring-of-given-length</title>
    <link href="/2024/10/01/Leetcode-maximum-number-of-vowels-in-a-substring-of-given-length/"/>
    <url>/2024/10/01/Leetcode-maximum-number-of-vowels-in-a-substring-of-given-length/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你字符串 <code>s</code> 和整数 <code>k</code> 。</p><p>请返回字符串 <code>s</code> 中长度为 <code>k</code>的单个子字符串中可能包含的最大元音字母数。</p><p>英文中的 <strong>元音字母</strong> 为（<code>a</code>,<code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>）。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abciiidef&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：子字符串 <span class="hljs-string">&quot;iii&quot;</span> 包含 <span class="hljs-number">3</span> 个元音字母。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：s = &quot;aeiou&quot;, k = 2<br>输出：2<br>解释：任意长度为<span class="hljs-number"> 2 </span>的子字符串都包含<span class="hljs-number"> 2 </span>个元音字母。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-string">&quot;lee&quot;</span>、<span class="hljs-string">&quot;eet&quot;</span> 和 <span class="hljs-string">&quot;ode&quot;</span> 都包含 <span class="hljs-number">2</span> 个元音字母。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;rhythms&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">0</span><br>解释：字符串 s 中不含任何元音字母。<br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;tryhard&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>s</code> 由小写英文字母组成</li><li><code>1 &lt;= k &lt;= s.length</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>定长滑动窗口题目，构造好初始窗口后，计算答案。接着重复</p><ul><li>读取right</li><li>弹出left</li><li>计算答案</li></ul><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxVowels</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, n = s.<span class="hljs-built_in">size</span>(), memo[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;, ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(right &lt; k) &#123;<br>            memo[s[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        ans = <span class="hljs-built_in">max</span>(ans, memo[<span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>] + memo[<span class="hljs-string">&#x27;e&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>] + memo[<span class="hljs-string">&#x27;i&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>] + memo[<span class="hljs-string">&#x27;o&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>] + memo[<span class="hljs-string">&#x27;u&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>        <span class="hljs-keyword">while</span>(right &lt; n) &#123;<br>            memo[s[left++] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            memo[s[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            ans = <span class="hljs-built_in">max</span>(ans, memo[<span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>] + memo[<span class="hljs-string">&#x27;e&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>] + memo[<span class="hljs-string">&#x27;i&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>] + memo[<span class="hljs-string">&#x27;o&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>] + memo[<span class="hljs-string">&#x27;u&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-count-complete-substring</title>
    <link href="/2024/10/01/Leetcode-count-complete-substring/"/>
    <url>/2024/10/01/Leetcode-count-complete-substring/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个字符串 <code>word</code> 和一个整数 <code>k</code> 。</p><p>如果 <code>word</code> 的一个子字符串 <code>s</code>满足以下条件，我们称它是 <strong>完全字符串：</strong></p><ul><li><code>s</code> 中每个字符 <strong>恰好</strong> 出现 <code>k</code>次。</li><li>相邻字符在字母表中的顺序 <strong>至多</strong> 相差 <code>2</code>。也就是说，<code>s</code> 中两个相邻字符 <code>c1</code> 和<code>c2</code> ，它们在字母表中的位置相差 <strong>至多</strong> 为<code>2</code> 。</li></ul><p>请你返回 <code>word</code> 中 <strong>完全</strong>子字符串的数目。</p><p><strong>子字符串</strong> 指的是一个字符串中一段连续<strong>非空</strong> 的字符序列。</p><p><strong>示例 1：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">word</span> = <span class="hljs-string">&quot;igigee&quot;</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：完全子字符串需要满足每个字符恰好出现 <span class="hljs-number">2</span> 次，且相邻字符相差至多为 <span class="hljs-number">2</span> ：igigee, igigee, igigee 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">word</span> = <span class="hljs-string">&quot;aaabbbccc&quot;</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br>解释：完全子字符串需要满足每个字符恰好出现 <span class="hljs-number">3</span> 次，且相邻字符相差至多为 <span class="hljs-number">2</span> ：aaabbbccc, aaabbbccc, aaabbbccc, aaabbbccc, aaabbbccc, aaabbbccc 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word.length &lt;= 10^5</code></li><li><code>word</code> 只包含小写英文字母。</li><li><code>1 &lt;= k &lt;= word.length</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>先根据相邻字符相差不能超过2的性质，找出所有可能成为答案的子字符串。这里需要O(n)。</p><p>对每一个子字符串，进行枚举，假设出现了1种字符、2种字符...26种字符，每个字符都需要k个字母。所以我们就可以转换为定长的滑动窗口问题。这里需要O(26n)。</p><p><strong>时间复杂度：</strong>最终是O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countCompleteSubstrings</span><span class="hljs-params">(string word, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = word.<span class="hljs-built_in">size</span>(), ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; left &lt; n; left++) &#123; <span class="hljs-comment">// 枚举左端点</span><br>            <span class="hljs-type">int</span> right = left + <span class="hljs-number">1</span>; <span class="hljs-comment">// 右端点，起码要两个元素，所以是左端点的下一个元素。</span><br><br>            <span class="hljs-keyword">while</span> (right &lt; n &amp;&amp; <span class="hljs-built_in">abs</span>(word[right] - word[right - <span class="hljs-number">1</span>]) &lt;= <span class="hljs-number">2</span>) <span class="hljs-comment">// 尽可能的移动右端点，得到的结果是[left, right)</span><br>                right++;<br>            ans = ans + <span class="hljs-built_in">calAns</span>(word.<span class="hljs-built_in">substr</span>(left, right - left), k);<br>            left = right - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calAns</span><span class="hljs-params">(string word, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = word.<span class="hljs-built_in">size</span>(), res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">26</span> &amp;&amp; n &gt;= i * k; i++) &#123; <span class="hljs-comment">// 枚举可能出现的字符数量。定长动态窗口问题，长度为i * k。</span><br>            <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, memo[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 右端点和左端点可以从一处出发。</span><br><br>            <span class="hljs-keyword">while</span> (right &lt; i * k) <span class="hljs-comment">// 构建初始的滑动窗口,结束的时候，右指针指向的内容还没有记录。</span><br>                memo[word[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            res = res + <span class="hljs-built_in">check</span>(memo, k); <span class="hljs-comment">// 计算一次答案。</span><br>            <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>                memo[word[left++] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                memo[word[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                res = res + <span class="hljs-built_in">check</span>(memo, k);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> array[], <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>            <span class="hljs-keyword">if</span> (array[i] &gt; <span class="hljs-number">0</span> &amp;&amp; array[i] != k)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="滑动窗口优化">2.2 滑动窗口+优化</h3><p><strong>思路：</strong></p><p>在2.1的基础上，不用check函数，而是使用一个哈希表，记录出现&lt;出现次数，字符种类&gt;的哈希表。这样检测是否满足条件，只要检查定长滑动窗口的情况下，<code>map[k] == i</code>即可。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countCompleteSubstrings</span><span class="hljs-params">(string word, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = word.<span class="hljs-built_in">size</span>(), ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; left &lt; n; left++) &#123; <span class="hljs-comment">// 枚举左端点</span><br>            <span class="hljs-type">int</span> right = left + <span class="hljs-number">1</span>; <span class="hljs-comment">// 右端点，起码要两个元素，所以是左端点的下一个元素。</span><br><br>            <span class="hljs-keyword">while</span> (right &lt; n &amp;&amp; <span class="hljs-built_in">abs</span>(word[right] - word[right - <span class="hljs-number">1</span>]) &lt;= <span class="hljs-number">2</span>) <span class="hljs-comment">// 尽可能的移动右端点，得到的结果是[left, right)</span><br>                right++;<br>            ans = ans + <span class="hljs-built_in">calAns</span>(word.<span class="hljs-built_in">substr</span>(left, right - left), k);<br>            left = right - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calAns</span><span class="hljs-params">(string word, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = word.<span class="hljs-built_in">size</span>(), res = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map; <span class="hljs-comment">// 记录&lt;出现次数, 字符种类数&gt;</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">26</span> &amp;&amp; n &gt;= i * k; i++) &#123; <span class="hljs-comment">// 枚举可能出现的字符数量。定长动态窗口问题，长度为i * k。</span><br>            <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, memo[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 右端点和左端点可以从一处出发。</span><br><br>            <span class="hljs-keyword">while</span> (right &lt; i * k) &#123; <span class="hljs-comment">// 构建初始的滑动窗口,结束的时候，右指针指向的内容还没有记录。</span><br>                memo[word[right] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                map[memo[word[right] - <span class="hljs-string">&#x27;a&#x27;</span>]]++;<br>                right++;<br>            &#125;<br>            res = res + (map[k] == i); <span class="hljs-comment">// 计算一次答案。</span><br>            <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>                map[memo[word[left] - <span class="hljs-string">&#x27;a&#x27;</span>]]--;<br>                memo[word[left] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                memo[word[right] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                map[memo[word[right] - <span class="hljs-string">&#x27;a&#x27;</span>]]++;<br>                left++;<br>                right++;<br>                res = res + (map[k] == i); <span class="hljs-comment">// 计算一次答案。</span><br>            &#125;<br>            map.<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-longest-even-odd-subarray-with-threshold</title>
    <link href="/2024/10/01/Leetcode-longest-even-odd-subarray-with-threshold/"/>
    <url>/2024/10/01/Leetcode-longest-even-odd-subarray-with-threshold/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code>和一个整数 <code>threshold</code> 。</p><p>请你从 <code>nums</code> 的子数组中找出以下标 <code>l</code>开头、下标 <code>r</code> 结尾<code>(0 &lt;= l &lt;= r &lt; nums.length)</code> 且满足以下条件的<strong>最长子数组</strong> ：</p><ul><li><code>nums[l] % 2 == 0</code></li><li>对于范围 <code>[l, r - 1]</code> 内的所有下标 <code>i</code>，<code>nums[i] % 2 != nums[i + 1] % 2</code></li><li>对于范围 <code>[l, r]</code> 内的所有下标 <code>i</code>，<code>nums[i] &lt;= threshold</code></li></ul><p>以整数形式返回满足题目要求的最长子数组的长度。</p><p><strong>注意：子数组</strong> 是数组中的一个连续非空元素序列。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [3,2,5,4], threshold = 5<br>输出：3<br>解释：在这个示例中，我们选择从 l =<span class="hljs-number"> 1 </span>开始、到 r =<span class="hljs-number"> 3 </span>结束的子数组 =&gt; [2,5,4] ，满足上述条件。<br>因此，答案就是这个子数组的长度<span class="hljs-number"> 3 </span>。可以证明<span class="hljs-number"> 3 </span>是满足题目要求的最大长度。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2], threshold = 2<br>输出：1<br>解释：<br>在这个示例中，我们选择从 l =<span class="hljs-number"> 1 </span>开始、到 r =<span class="hljs-number"> 1 </span>结束的子数组 =&gt; [2] 。<br>该子数组满足上述全部条件。可以证明<span class="hljs-number"> 1 </span>是满足题目要求的最大长度。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,4,5], threshold = 4<br>输出：3<br>解释：<br>在这个示例中，我们选择从 l =<span class="hljs-number"> 0 </span>开始、到 r =<span class="hljs-number"> 2 </span>结束的子数组 =&gt; [2,3,4] 。 <br>该子数组满足上述全部条件。<br>因此，答案就是这个子数组的长度<span class="hljs-number"> 3 </span>。可以证明<span class="hljs-number"> 3 </span>是满足题目要求的最大长度。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li><li><code>1 &lt;= threshold &lt;= 100</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>解法：</strong></p><p>枚举左端点，需要是偶数并且不超过threshold。</p><p>在符合条件的情况下不断移动右指针，当不符合条件，即可计算一次答案。</p><p><strong>时间复杂度：</strong>虽然是双层循环，但是left和right加在一起也只会执行n次，所以时间复杂度是O(n)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestAlternatingSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> threshold)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; left &lt; n; left++) &#123; <span class="hljs-comment">// 枚举左下标</span><br>            <span class="hljs-keyword">if</span> (nums[left] &gt; threshold || nums[left] % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 不能以这个元素开头</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> right = left + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (right &lt; n &amp;&amp; nums[right - <span class="hljs-number">1</span>] % <span class="hljs-number">2</span> != nums[right] % <span class="hljs-number">2</span> &amp;&amp; nums[right] &lt;= threshold) &#123; <span class="hljs-comment">// 移动右指针，找出满足条件的最大范围</span><br>                right++;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left); <span class="hljs-comment">// 在不满足条件的时候计算答案。</span><br>            left = right - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-3sum</title>
    <link href="/2024/10/01/Leetcode-3sum/"/>
    <url>/2024/10/01/Leetcode-3sum/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组<code>[nums[i], nums[j], nums[k]]</code> 满足<code>i != j</code>、<code>i != k</code> 且 <code>j != k</code>，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code>。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-1,0,1,2,-1,-4]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-1,-1,2]</span>,<span class="hljs-comment">[-1,0,1]</span>]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = (-1) + 0 + 1 = 0 。<br>nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[4]</span> = 0 + 1 + (-1) = 0 。<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 <span class="hljs-comment">[-1,0,1]</span> 和 <span class="hljs-comment">[-1,-1,2]</span> 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0,1,1]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：唯一可能的三元组和不为 0 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[0,0,0]]</span><br>解释：唯一可能的三元组和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li></ul><h2 id="题解">2 题解</h2><h3 id="逆向双指针">2.1 逆向双指针</h3><p><strong>思路：</strong></p><p>对原始数组进行升序排序。</p><p>外层对数组进行遍历，在该元素下标之后的范围内进行逆向双指针，等价于两数之和的问题。</p><p>需要注意的是，为了避免出现重复结果，所以在遍历外层遍历或者内层逆向双指针遍历的过程之中，需要跳过重复的数字。</p><p><strong>时间复杂度：</strong>外层遍历元素是O(n)，内层逆向双指针是O(n)，所以最终结果是O(n^2)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">begin</span>(nums), <span class="hljs-built_in">end</span>(nums), [](<span class="hljs-type">int</span> &amp;challenger, <span class="hljs-type">int</span> &amp;challengee) &#123;<br>            <span class="hljs-keyword">return</span> challengee &gt; challenger;<br>        &#125;); <span class="hljs-comment">// 从小到大排序</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[left + <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 最小的三个数字之和都已经大于0，后面不会存在答案。</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[right - <span class="hljs-number">1</span>] + nums[right] &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 最大的三个数字之和都已经小于0，后面不会存在答案。</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i]) &#123; <span class="hljs-comment">// 跳过重复的数字，这只会造成重复结果。</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 移动左指针，扩大结果。</span><br>                    left++;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 移动右指针，减小结果。</span><br>                    right--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    vector&lt;<span class="hljs-type">int</span>&gt; res = &#123;nums[i], nums[left], nums[right]&#125;;<br>                    ans.<span class="hljs-built_in">push_back</span>(res);<br>                    left++;<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left - <span class="hljs-number">1</span>] == nums[left]) left++; <span class="hljs-comment">// 跳过相同的数字，这只会造成重复结果。</span><br>                    right--;<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="hljs-number">1</span>]) right--; <span class="hljs-comment">// 跳过相同的数字，这只会造成重复结果。</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>逆向双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-two-sum</title>
    <link href="/2024/10/01/Leetcode-two-sum/"/>
    <url>/2024/10/01/Leetcode-two-sum/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值<code>target</code>，请你在该数组中找出 <strong>和为目标值</strong><em><code>target</code></em> 的那 <strong>两个</strong>整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 10^4</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li><li><code>-10^9 &lt;= target &lt;= 10^9</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong>你可以想出一个时间复杂度小于<code>O(n^2)</code> 的算法吗？</p><h2 id="题解">2 题解</h2><h3 id="暴力解法">2.1 暴力解法</h3><p><strong>思路：</strong></p><p>进行双重for循环，在两个指针不重复的前提下计算两个元素之和是否满足条件。</p><p><strong>时间复杂度：</strong>O(n^2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (i != j &amp;&amp; nums[i] + nums[j] == target) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123;i, j&#125;;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="逆向双指针">2.2 逆向双指针</h3><p><strong>思路</strong>：</p><p>创建下标数组，在不破坏原始数组的前提下，对下标数组的内容进行升序排序。</p><p>对下标数组创建左右指针，根据左右指针指向的下标在原始数组中取出对应元素。</p><ul><li>求和后大于target左移右指针</li><li>求和后小于target右移左指针</li><li>求和后等于target返回结果</li></ul><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; index = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">iota</span>(<span class="hljs-built_in">begin</span>(index), <span class="hljs-built_in">end</span>(index), <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">begin</span>(index), <span class="hljs-built_in">end</span>(index), [nums](<span class="hljs-type">int</span> &amp;challenger, <span class="hljs-type">int</span> &amp;challengee) &#123;<br>            <span class="hljs-keyword">return</span> nums[challengee] &gt; nums[challenger];<br>        &#125;); <span class="hljs-comment">// 进行从小到大的排序,注意：不破坏原始的vector。</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (nums[index[left]] + nums[index[right]] &gt; target) &#123;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[index[left]] + nums[index[right]] &lt; target) &#123;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123;index[left], index[right]&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123;index[left], index[right]&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="哈希表">2.3 哈希表</h3><p><strong>解法：</strong></p><p>创建哈希表，记录元素值和下标的映射关系。</p><p>遍历数组的过程中，查看哈希表中是否存在和当前遍历元素相加等于target的键。</p><ul><li>存在，那就返回结果</li><li>不存在，将当前的元素值和下标记录到哈希表中</li></ul><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map; <span class="hljs-comment">// 映射&lt;num, index&gt;的关系</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">find</span>(target - nums[i]) != <span class="hljs-built_in">end</span>(map)) &#123; <span class="hljs-comment">// 找出target-nums[i]的元素是否记录在哈希表中。</span><br>                <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123;map[target - nums[i]], i&#125;;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(nums[i], i));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123; <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>逆向双指针</tag>
      
      <tag>暴力</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的常见数据结构</title>
    <link href="/2024/09/29/C++%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/09/29/C++%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>使用下述数据结构时，需要的头文件如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="数组">1 数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化:两种构造方法</span><br><span class="hljs-comment"> * 增:</span><br><span class="hljs-comment"> * 删:</span><br><span class="hljs-comment"> * 查:[]、begin、end</span><br><span class="hljs-comment"> * 改:赋值覆盖</span><br><span class="hljs-comment"> * 清空:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-type">int</span> array1[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;; <span class="hljs-comment">// 构造数值型数组的第一种方式。</span><br>    <span class="hljs-type">int</span> array2[n] = &#123;&#125;; <span class="hljs-comment">// 构造数值型数组的第二种方式，全部元素都是0。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        array2[i] = i;<br>    &#125;<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;hello,world&quot;</span>; <span class="hljs-comment">// 构造字符型数组的第一种方式,自带\0。</span><br>    <span class="hljs-type">char</span> str2[n] = &#123;&#125;; <span class="hljs-comment">// 构造字符型数组的第二种方式,全部元素都是\0。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        str2[i] = <span class="hljs-string">&#x27;a&#x27;</span> + i;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 遍历数组的第一种方式,使用数组的总大小除以数组首个元素的大小就能得到数组的总长度</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(array1) / <span class="hljs-built_in">sizeof</span>(array1[<span class="hljs-number">0</span>]); i++) &#123;<br>        std::cout &lt;&lt; array1[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 遍历数组的第二种方式,使用增强for循环的方式。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> array: array2) &#123;<br>        std::cout &lt;&lt; array &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 遍历数组的第三种方式，使用end和std::begin函数，求出容器的长度。(注意，这种方式只能够用在静态数组上，即一开始就长度已经定死的，不适用变量定义的。)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> *ite = std::<span class="hljs-built_in">begin</span>(array1); ite != std::<span class="hljs-built_in">end</span>(array1); ite++) &#123;<br>        std::cout &lt;&lt; *ite &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 字符型数组遍历的第一种方式,直接用sizeof求出数组的长度进行遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(str2) / <span class="hljs-built_in">sizeof</span>(str2[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>; i++) &#123;<br>        std::cout &lt;&lt; str2[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 字符型数组遍历的第二种方式，使用end和std::begin求出容器的长度。(注意，这种方式只能够用在静态数组上，即一开始就长度已经定死的，不适用变量定义的。)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> *ite = std::<span class="hljs-built_in">begin</span>(str1); ite != std::<span class="hljs-built_in">end</span>(str1) - <span class="hljs-number">1</span>; ite++) &#123;<br>        std::cout &lt;&lt; *ite &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">1 2 3 4 5 6 7 8 9 10 <br>0 1 2 3 4 5 6 7 8 9 <br>1 2 3 4 5 6 7 8 9 10 <br>a b c d e f g h i <br>h e l l o , w o r l d <br></code></pre></td></tr></table></figure><h2 id="vector">2 vector</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">echo</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> count)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;以下为nums&quot;</span> &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot;中的数据&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 普通方式循环。</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;nums&quot;</span> &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;] = &quot;</span> &lt;&lt; nums[i] &lt;&lt; (i == nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;.\n&quot;</span> : <span class="hljs-string">&quot;, &quot;</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num: nums) &#123; <span class="hljs-comment">// 增强for循环。</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;nums&quot;</span> &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;] = &quot;</span> &lt;&lt; nums[i] &lt;&lt; (i == nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;.\n&quot;</span> : <span class="hljs-string">&quot;, &quot;</span>);<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator ite = std::<span class="hljs-built_in">begin</span>(nums); ite != std::<span class="hljs-built_in">end</span>(nums); ite++) &#123; <span class="hljs-comment">// 使用迭代器循环。</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;nums&quot;</span> &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> &lt;&lt; ite - std::<span class="hljs-built_in">begin</span>(nums) &lt;&lt; <span class="hljs-string">&quot;] = &quot;</span> &lt;&lt; *ite &lt;&lt; (ite == std::<span class="hljs-built_in">end</span>(nums) - <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;.\n&quot;</span> : <span class="hljs-string">&quot;, &quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化:三种构造方法</span><br><span class="hljs-comment"> * 增:insert、push_back、emplace_back</span><br><span class="hljs-comment"> * 删:erase</span><br><span class="hljs-comment"> * 查:[]、empty、size、back、begin、end</span><br><span class="hljs-comment"> * 改:赋值覆盖</span><br><span class="hljs-comment"> * 清空:clear()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; nums1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">// 静态构造。</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; nums2 = std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">begin</span>(nums1), std::<span class="hljs-built_in">end</span>(nums1) - <span class="hljs-number">2</span>); <span class="hljs-comment">// 使用迭代器构造。</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; nums3 = std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">9</span>); <span class="hljs-comment">// 创建包含五个9的vector。</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; nums4;<br>    <span class="hljs-built_in">echo</span>(nums1, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">echo</span>(nums2, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">echo</span>(nums3, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">echo</span>(nums4, <span class="hljs-number">4</span>);<br>    nums<span class="hljs-number">4.</span><span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">begin</span>(nums4), <span class="hljs-number">2</span>);<br>    nums<span class="hljs-number">4.</span><span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">begin</span>(nums4), <span class="hljs-number">1</span>);<br>    nums<span class="hljs-number">4.</span><span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">begin</span>(nums4) + <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    nums<span class="hljs-number">4.</span><span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">end</span>(nums4), <span class="hljs-number">4</span>); <span class="hljs-comment">// 插入指定位置。</span><br>    nums<span class="hljs-number">4.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 插入结尾。</span><br>    nums<span class="hljs-number">4.</span><span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">6</span>); <span class="hljs-comment">// 插入结尾，速度更快。</span><br>    <span class="hljs-built_in">echo</span>(nums4, <span class="hljs-number">4</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;删除nums4中的元素4以后&quot;</span> &lt;&lt; std::endl;<br>    nums<span class="hljs-number">4.</span><span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">begin</span>(nums4) + <span class="hljs-number">3</span>); <span class="hljs-comment">// 删除元素。</span><br>    <span class="hljs-built_in">echo</span>(nums4, <span class="hljs-number">4</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;nums4的内容&quot;</span> &lt;&lt; (nums<span class="hljs-number">4.</span><span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;为空&quot;</span> : <span class="hljs-string">&quot;不为空&quot;</span>) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;nums4中包含了&quot;</span> &lt;&lt; nums<span class="hljs-number">4.</span><span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;个元素&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;nums4结尾的元素是&quot;</span> &lt;&lt; nums<span class="hljs-number">4.</span><span class="hljs-built_in">back</span>() &lt;&lt; std::endl;<br>nums<span class="hljs-number">4.</span><span class="hljs-built_in">clear</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;nums4的内容&quot;</span> &lt;&lt; (nums<span class="hljs-number">4.</span><span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;为空&quot;</span> : <span class="hljs-string">&quot;不为空&quot;</span>) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">以下为nums1中的数据<br>nums1[0] = 1, nums1[1] = 2, nums1[2] = 3, nums1[3] = 4, nums1[4] = 5.<br>nums1[0] = 1, nums1[1] = 2, nums1[2] = 3, nums1[3] = 4, nums1[4] = 5.<br>nums1[0] = 1, nums1[1] = 2, nums1[2] = 3, nums1[3] = 4, nums1[4] = 5.<br>以下为nums2中的数据<br>nums2[0] = 1, nums2[1] = 2, nums2[2] = 3.<br>nums2[0] = 1, nums2[1] = 2, nums2[2] = 3.<br>nums2[0] = 1, nums2[1] = 2, nums2[2] = 3.<br>以下为nums3中的数据<br>nums3[0] = 9, nums3[1] = 9, nums3[2] = 9, nums3[3] = 9, nums3[4] = 9.<br>nums3[0] = 9, nums3[1] = 9, nums3[2] = 9, nums3[3] = 9, nums3[4] = 9.<br>nums3[0] = 9, nums3[1] = 9, nums3[2] = 9, nums3[3] = 9, nums3[4] = 9.<br>以下为nums4中的数据<br>以下为nums4中的数据<br>nums4[0] = 1, nums4[1] = 2, nums4[2] = 3, nums4[3] = 4, nums4[4] = 5, nums4[5] = 6.<br>nums4[0] = 1, nums4[1] = 2, nums4[2] = 3, nums4[3] = 4, nums4[4] = 5, nums4[5] = 6.<br>nums4[0] = 1, nums4[1] = 2, nums4[2] = 3, nums4[3] = 4, nums4[4] = 5, nums4[5] = 6.<br>删除nums4中的元素4以后<br>以下为nums4中的数据<br>nums4[0] = 1, nums4[1] = 2, nums4[2] = 3, nums4[3] = 5, nums4[4] = 6.<br>nums4[0] = 1, nums4[1] = 2, nums4[2] = 3, nums4[3] = 5, nums4[4] = 6.<br>nums4[0] = 1, nums4[1] = 2, nums4[2] = 3, nums4[3] = 5, nums4[4] = 6.<br>nums4的内容不为空<br>nums4中包含了5个元素<br>nums4结尾的元素是6<br>nums4的内容为空<br></code></pre></td></tr></table></figure><h2 id="队列">3 队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化:一种构造方法</span><br><span class="hljs-comment"> * 增:push</span><br><span class="hljs-comment"> * 删:pop</span><br><span class="hljs-comment"> * 查:empty、size、front、back</span><br><span class="hljs-comment"> * 改:</span><br><span class="hljs-comment"> * 清空:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>);<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 将新元素压入队尾</span><br>    std::cout &lt;&lt; q.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 查看队列是否为空</span><br>        std::cout &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; q.<span class="hljs-built_in">back</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 查看队首以及队尾的元素</span><br>        q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 弹出队首元素</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">4<br>1 3<br>4 3<br>2 3<br>3 3<br></code></pre></td></tr></table></figure><h2 id="双端队列">4 双端队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化:一种构造方法</span><br><span class="hljs-comment"> * 增:push_front、push_back</span><br><span class="hljs-comment"> * 删:pop_front、pop_back</span><br><span class="hljs-comment"> * 查:empty、size、front、back</span><br><span class="hljs-comment"> * 改:</span><br><span class="hljs-comment"> * 清空:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::deque&lt;<span class="hljs-type">int</span>&gt; q;<br>    <br>    q.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 向队首插入元素</span><br>    q.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">4</span>);<br>    <br>    q.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 向队尾插入元素</span><br>    q.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    <br>    std::cout &lt;&lt; q.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 给出双端队列的长度</span><br>    <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 判断双端队列是否为空</span><br>        std::cout &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; q.<span class="hljs-built_in">back</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 查询双端队列的队首和队尾元素</span><br><br>        q.<span class="hljs-built_in">pop_front</span>(); <span class="hljs-comment">// 弹出双端队列的指定端。</span><br>        q.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">4<br>4 2<br>1 3<br></code></pre></td></tr></table></figure><h2 id="优先队列堆">5 优先队列（堆）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化:一种构造方法</span><br><span class="hljs-comment"> * 增:push</span><br><span class="hljs-comment"> * 删:pop</span><br><span class="hljs-comment"> * 查:empty、size、top</span><br><span class="hljs-comment"> * 改:</span><br><span class="hljs-comment"> * 清空:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>&gt; max_heap; <span class="hljs-comment">// 构建优先队列。</span><br>    max_heap.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 往优先队列中插入内容，同时会自动排序，默认是大顶堆。</span><br>    max_heap.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>);<br>    max_heap.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    max_heap.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>    std::cout &lt;&lt; max_heap.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 查看堆中有多少个元素。</span><br>    <span class="hljs-keyword">while</span>(!max_heap.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 查看堆是否为空。</span><br>        std::cout &lt;&lt; max_heap.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 查看堆顶的元素。</span><br>        max_heap.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 弹出堆顶元素。</span><br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-type">bool</span>(*)(<span class="hljs-type">int</span> &amp;, <span class="hljs-type">int</span> &amp;)&gt; <span class="hljs-built_in">min_heap</span>([](<span class="hljs-type">int</span> &amp;challenger, <span class="hljs-type">int</span> &amp;challengee)&#123;<br>        <span class="hljs-keyword">return</span> challenger &gt; challengee;<br>    &#125;); <span class="hljs-comment">// 构建最小堆,优先队列的比较函数和普通的sort函数中逻辑是不同的，优先队列的比较函数返回true时代表challenger的优先级更低，需要排到后面的位置。普通sort函数中返回true表示challenger应当和challengee交换位置。</span><br>    min_heap.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    min_heap.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    min_heap.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>    min_heap.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">while</span>(!min_heap.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; min_heap.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        min_heap.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">4<br>4 3 2 1 <br>1 2 3 4<br></code></pre></td></tr></table></figure><h2 id="栈">6 栈</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化:一种构造方法</span><br><span class="hljs-comment"> * 增:push</span><br><span class="hljs-comment"> * 删:pop</span><br><span class="hljs-comment"> * 查:empty、size、top</span><br><span class="hljs-comment"> * 改:</span><br><span class="hljs-comment"> * 清空:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; stack; <span class="hljs-comment">// 初始化栈。</span><br>    stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>);<br>    stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>    stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 压栈。</span><br>    std::cout &lt;&lt; stack.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 查看栈中有多少个元素。</span><br>    <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 判断栈是否为空。</span><br>        std::cout &lt;&lt; stack.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 查看栈顶元素。</span><br>        stack.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 出栈。</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">4<br>2<br>3<br>4<br>1<br></code></pre></td></tr></table></figure><h2 id="unordered_map">7 unordered_map</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化:一种构造方法</span><br><span class="hljs-comment"> * 增:insert、[]</span><br><span class="hljs-comment"> * 删:erase</span><br><span class="hljs-comment"> * 查:[]、empty、size、find、begin、end</span><br><span class="hljs-comment"> * 改:赋值覆盖</span><br><span class="hljs-comment"> * 清空:clear</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hashmap; <span class="hljs-comment">// 初始化。</span><br>    hashmap.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// 插入键值对元素方式一。</span><br>    hashmap[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">// 插入键值对方式二。</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;总长度为:&quot;</span> &lt;&lt; hashmap.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// hashmap的长度。</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;是否为空为:&quot;</span> &lt;&lt; hashmap.<span class="hljs-built_in">empty</span>() &lt;&lt; std::endl; <span class="hljs-comment">// hashmap是否为空。</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ite = std::<span class="hljs-built_in">begin</span>(hashmap); ite != std::<span class="hljs-built_in">end</span>(hashmap); ++ite) &#123; <span class="hljs-comment">// 遍历哈希表。</span><br>        std::cout &lt;&lt; ite-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ite-&gt;second &lt;&lt; std::endl; <span class="hljs-comment">// 分别获取当前键值对中的key和value。</span><br>        std::cout &lt;&lt; (hashmap.<span class="hljs-built_in">find</span>(ite-&gt;first) != std::<span class="hljs-built_in">end</span>(hashmap)) &lt;&lt; std::endl; <span class="hljs-comment">// 根据key查询元素</span><br>    &#125;<br>    hashmap.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 删除key为1的键值对。</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;删除了键为1的内容以后，还剩下&quot;</span> &lt;&lt; hashmap.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;对元素&quot;</span> &lt;&lt; std::endl;<br>    hashmap.<span class="hljs-built_in">clear</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;清空后size:&quot;</span> &lt;&lt; hashmap.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;清空后empty:&quot;</span> &lt;&lt; hashmap.<span class="hljs-built_in">empty</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">总长度为:2<br>是否为空为:0<br>2 2<br>1<br>1 1<br>1<br>删除了键为1的内容以后，还剩下1对元素<br>清空后size:0<br>清空后empty:1<br></code></pre></td></tr></table></figure><h2 id="unordered_set">8 unordered_set</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化:一种构造方法</span><br><span class="hljs-comment"> * 增:insert</span><br><span class="hljs-comment"> * 删:erase</span><br><span class="hljs-comment"> * 查:empty、size、find、begin、end</span><br><span class="hljs-comment"> * 改:</span><br><span class="hljs-comment"> * 清空:clear</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unordered_set&lt;<span class="hljs-type">int</span>&gt; hashset;<br>    hashset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);<br>    hashset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>);<br>    hashset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>    hashset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 插入内容</span><br>    std::cout &lt;&lt; hashset.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 获取元素个数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;是否为空为:&quot;</span> &lt;&lt; hashset.<span class="hljs-built_in">empty</span>() &lt;&lt; std::endl; <span class="hljs-comment">// hashmap是否为空。</span><br>    <span class="hljs-keyword">for</span> (std::unordered_set&lt;<span class="hljs-type">int</span>&gt;::iterator ite = std::<span class="hljs-built_in">begin</span>(hashset); ite != std::<span class="hljs-built_in">end</span>(hashset); ite++) &#123;<br>        std::cout &lt;&lt; *ite &lt;&lt; std::endl; <span class="hljs-comment">// 查询目标元素是否存在</span><br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;如果3存在，那么删除3&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">if</span> (hashset.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) != <span class="hljs-built_in">end</span>(hashset)) &#123;<br>        hashset.<span class="hljs-built_in">erase</span>(hashset.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 删除目标元素</span><br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;剩余元素个数：&quot;</span> &lt;&lt; hashset.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br><br>    hashset.<span class="hljs-built_in">clear</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;清空后size:&quot;</span> &lt;&lt; hashset.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;清空后empty:&quot;</span> &lt;&lt; hashset.<span class="hljs-built_in">empty</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">4<br>是否为空为:0<br>2<br>3<br>4<br>1<br>如果3存在，那么删除3<br>剩余元素个数：3<br>清空后size:0<br>清空后empty:1<br></code></pre></td></tr></table></figure><h2 id="bitset">9 bitset</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::bitset&lt;5&gt; <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    std::cout &lt;&lt; num &lt;&lt; std::endl;<br>    num.<span class="hljs-built_in">set</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 下标第i位变成1。</span><br>    std::cout &lt;&lt; num &lt;&lt; std::endl;<br>    num.<span class="hljs-built_in">set</span>();  <span class="hljs-comment">// 全部变为1</span><br>    std::cout &lt;&lt; num &lt;&lt; std::endl;<br>    num.<span class="hljs-built_in">reset</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 下标第i位复位。</span><br>    std::cout &lt;&lt; num &lt;&lt; std::endl;<br>    num.<span class="hljs-built_in">reset</span>();  <span class="hljs-comment">// 全体复位。</span><br>    std::cout &lt;&lt; num &lt;&lt; std::endl;<br>    std::cout &lt;&lt; num.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 该bitset的大小。</span><br>    num.<span class="hljs-built_in">set</span>(<span class="hljs-number">3</span>);<br>    std::cout &lt;&lt; num.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 有几个1。</span><br>    std::cout &lt;&lt; num.<span class="hljs-built_in">any</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 是否至少含有一个1吗。</span><br>    std::cout &lt;&lt; num.<span class="hljs-built_in">none</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 是否不含1。</span><br>    std::cout &lt;&lt; num.<span class="hljs-built_in">all</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 是否全部为1。</span><br>    std::cout &lt;&lt; num.<span class="hljs-built_in">test</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 下标为3的位置上是否是1。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">00001<br>00011<br>11111<br>11101<br>00000<br>5<br>1<br>1<br>0<br>0<br>1<br></code></pre></td></tr></table></figure><h2 id="string">10 string</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化:三种初始化方法</span><br><span class="hljs-comment"> * 增:</span><br><span class="hljs-comment"> * 删:erase（原地）</span><br><span class="hljs-comment"> * 查:[]、find、substr、compare、size、regex_match</span><br><span class="hljs-comment"> * 改:replace(原地)、regex_replace(非原地)</span><br><span class="hljs-comment"> * 清空:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>std::string str = <span class="hljs-string">&quot;hello,world!&quot;</span>; <span class="hljs-comment">// 初始化方式1</span><br>std::string str1 = std::<span class="hljs-built_in">string</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// 初始化方式2</span><br>std::string str2 = str1; <span class="hljs-comment">// 初始化方式3</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;str1=&quot;</span> &lt;&lt; str1 &lt;&lt; <span class="hljs-string">&quot;,str2=&quot;</span> &lt;&lt; str2 &lt;&lt; std::endl;<br><br><span class="hljs-type">int</span> e_pos = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;e&#x27;</span>);<br><span class="hljs-type">int</span> a_pos = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;ahead&quot;</span>); <span class="hljs-comment">// 查询方法</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;字符串的内容为:&quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;e_pos:&quot;</span> &lt;&lt; e_pos &lt;&lt; <span class="hljs-string">&quot;，是否等于std::string::npos===&gt;&quot;</span> &lt;&lt; (e_pos == std::string::npos) &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;ahead_pos:&quot;</span> &lt;&lt; a_pos &lt;&lt; <span class="hljs-string">&quot;，是否等于std::string::npos===&gt;&quot;</span> &lt;&lt; (a_pos == std::string::npos) &lt;&lt; std::endl;<br><span class="hljs-type">int</span> erase_len = <span class="hljs-number">3</span>;<br>str.<span class="hljs-built_in">erase</span>(e_pos, erase_len); <span class="hljs-comment">// 删除包含起始点的多个字符。</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;str删除内容以后，字符串内容变为:&quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;截取出[3,6]范围内的子串内容为:&quot;</span> &lt;&lt; str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>, <span class="hljs-number">6</span> - <span class="hljs-number">3</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 截取子串</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;替换了[3,6]范围内的字串内容为&#x27;abcde&#x27;,结果为&quot;</span> &lt;&lt; str.<span class="hljs-built_in">replace</span>(<span class="hljs-number">3</span>, <span class="hljs-number">6</span> - <span class="hljs-number">3</span>, <span class="hljs-string">&quot;abcde&quot;</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 替换子串</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;比较字符串str和str1的大小&quot;</span> &lt;&lt; str.<span class="hljs-built_in">compare</span>(<span class="hljs-number">0</span>, str.<span class="hljs-built_in">size</span>(), str1) &lt;&lt; std::endl; <span class="hljs-comment">// 字符串比较</span><br><br>std::smatch result;<br><span class="hljs-function">std::regex <span class="hljs-title">pattern</span><span class="hljs-params">(<span class="hljs-string">&quot;(h|w)o.*&quot;</span>)</span></span>;<br><span class="hljs-built_in">regex_match</span>(str, result, pattern); <span class="hljs-comment">// 进行正则匹配,必须要整串字符都可以匹配上。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; result.<span class="hljs-built_in">size</span>(); i++) &#123;<br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;的内容是:&quot;</span> &lt;&lt; result[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>std::cout &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;替换以后的内容为:&quot;</span> &lt;&lt; <span class="hljs-built_in">regex_replace</span>(str, pattern, <span class="hljs-string">&quot;clean&quot;</span>) &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">str1=aaaaaaaaaa,str2=aaaaaaaaaa<br>字符串的内容为:hello,world!<br>e_pos:1，是否等于std::string::npos===&gt;0<br>ahead_pos:-1，是否等于std::string::npos===&gt;1<br>str删除内容以后，字符串内容变为:ho,world!<br>截取出[3,6]范围内的子串内容为:wor<br>替换了[3,6]范围内的字串内容为<span class="hljs-string">&#x27;abcde&#x27;</span>,结果为ho,abcdeld!<br>比较字符串str和str1的大小1<br>0的内容是:ho,abcdeld! 1的内容是:h<br>替换以后的内容为:clean<br></code></pre></td></tr></table></figure><h2 id="set">11 set</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化：一种初始化方法</span><br><span class="hljs-comment"> * 增：insert</span><br><span class="hljs-comment"> * 删：erase</span><br><span class="hljs-comment"> * 查：size、empty、find、begin、end、lower_bound、upper_bound</span><br><span class="hljs-comment"> * 改：</span><br><span class="hljs-comment"> * 清空：clear</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;challenger, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;challengee) &#123;<br>            <span class="hljs-keyword">return</span> challengee &gt; challenger; <span class="hljs-comment">// 升序排序</span><br>        &#125;;<br>        <span class="hljs-function">std::set&lt;<span class="hljs-type">int</span>, <span class="hljs-title">bool</span><span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;)</span>&gt; <span class="hljs-title">mySet</span><span class="hljs-params">(cmp)</span></span>;<br><br>        mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);<br>        mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;val : mySet) &#123;<br>            std::cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        std::cout &lt;&lt; std::endl;<br>        mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);<br>        mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;val : mySet) &#123;<br>            std::cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        std::cout &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;*mySet.lower_bound(3)&quot;</span> &lt;&lt; *mySet.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-number">3</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 查询大于等于</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;*mySet.upper_bound(3)&quot;</span> &lt;&lt; *mySet.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-number">3</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 查询大于</span><br>    &#125;<br>    <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;challenger, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;challengee) &#123;<br>        <span class="hljs-keyword">return</span> challengee &lt; challenger; <span class="hljs-comment">// 降序排序</span><br>    &#125;;<br>    <span class="hljs-function">std::set&lt;<span class="hljs-type">int</span>, <span class="hljs-title">bool</span><span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;)</span>&gt; <span class="hljs-title">mySet</span><span class="hljs-params">(cmp)</span></span>;<br><br>    mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);<br>    mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;val : mySet) &#123;<br>        std::cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);<br>    mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;val : mySet) &#123;<br>        std::cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;删除了3以后剩余的内容:&quot;</span> &lt;&lt; std::endl;<br>    mySet.<span class="hljs-built_in">erase</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">for</span> (std::set&lt;<span class="hljs-type">int</span>&gt;::iterator ite = <span class="hljs-built_in">begin</span>(mySet); ite != <span class="hljs-built_in">end</span>(mySet); ite++) &#123;<br>        std::cout &lt;&lt; *ite &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl &lt;&lt; <span class="hljs-string">&quot;3还存在吗？&quot;</span> &lt;&lt; (mySet.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) != <span class="hljs-built_in">end</span>(mySet)) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;*mySet.lower_bound(1)&quot;</span> &lt;&lt; *mySet.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 查询大于等于</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;*mySet.upper_bound(1)&quot;</span> &lt;&lt; *mySet.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 查询大于</span><br><br>    mySet.<span class="hljs-built_in">clear</span>();<br>    std::cout &lt;&lt; std::endl &lt;&lt; <span class="hljs-string">&quot;清空以后的结果:&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;size:&quot;</span> &lt;&lt; mySet.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;empty:&quot;</span> &lt;&lt; mySet.<span class="hljs-built_in">empty</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">1 3<br>1 2 3 4<br>*mySet.lower_bound(3)3<br>*mySet.upper_bound(3)4<br>3 1<br>4 3 2 1<br>删除了3以后剩余的内容:<br>4 2 1<br>3还存在吗？0<br>*mySet.lower_bound(1)1<br>*mySet.upper_bound(1)3<br><br>清空以后的结果:<br>size:0<br>empty:1<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Usage</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令grep详解</title>
    <link href="/2024/09/07/Linux%E5%91%BD%E4%BB%A4grep%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/09/07/Linux%E5%91%BD%E4%BB%A4grep%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="grep基本命令格式">1 grep基本命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep [options] pattern [input]<br></code></pre></td></tr></table></figure><p>这条命令的功能就是对<strong>输入源</strong>按照设定的<strong>正则表达式</strong>进行过滤，根据<strong>选项</strong>对结果进行强化，当一段内容已经找到一部分后，会立即从该位置接着重新进行过滤任务，也即前面已经匹配的内容是不再使用的。</p><h2 id="输入源">2 输入源</h2><p>输入源的情况共分为三种，分别是文件、管道符带来的输入、键盘带来的标准输入。为了进行后续测试，我预先创建了两个文件，内容如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> user1.txt <br>user1.txt<br>name: feng.<br>telephone number: 177****2269.<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> user2.txt <br>user2.txt<br>name: lijian.<br>qq: 123456789.<br></code></pre></td></tr></table></figure><h3 id="使用文件">2.1 使用文件</h3><p>grep可以同时指定<strong>任意多个文件</strong>作为输入源，以下是对两个预先准备好的文件执行grep的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ grep <span class="hljs-string">&#x27;1&#x27;</span> user1.txt user2.txt <span class="hljs-comment"># 对多个文件进行过滤，过滤条件很简单，只要目标行包含了&quot;1&quot;这个字符，就会被筛选出来。</span><br>user1.txt:user1.txt<br>user1.txt:telephone number: 177****2269.<br>user2.txt:qq: 123456789.<br></code></pre></td></tr></table></figure><p>若给定的输入源包含<strong>目录</strong>，此时就需要使用选项<code>-r</code>递归地在目录及其子目录下的所有文件中搜索。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ grep -r <span class="hljs-string">&#x27;1&#x27;</span> user1.txt user2.txt ../tmp <span class="hljs-comment"># 不仅在user1.txt和user2.txt两个文件进行过滤，还在tmp这个目录下进行了递归的过滤，所以从结果中可以发现，过滤结果是翻了一倍。</span><br>user1.txt:user1.txt<br>user1.txt:telephone number: 177****2269.<br>user2.txt:qq: 123456789.<br>../tmp/user2.txt:qq: 123456789.<br>../tmp/user1.txt:user1.txt<br>../tmp/user1.txt:telephone number: 177****2269.<br></code></pre></td></tr></table></figure><h3 id="使用管道符">2.2 使用管道符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> user1.txt user2.txt | grep <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-comment"># 通过cat命令读取这两个文件的内容，并以管道符的形式发送给grpe命令。我们可以发现，过滤以后的结果较2.1相比，少了来源文件的信息。</span><br>user1.txt<br>telephone number: 177****2269.<br>qq: 123456789.<br></code></pre></td></tr></table></figure><h3 id="使用标准输入">2.3 使用标准输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ grep <span class="hljs-string">&#x27;1&#x27;</span> - <span class="hljs-comment"># 当需要对键盘输入进行过滤时，只需要将输入源设置为&#x27;-&#x27;即可，若输入的内容符合正则表达式，会重新在界面上输出目标语句。</span><br>user1.txt<br>user1.txt<br>name: feng.<br>telephone number: 177****2269.<br>telephone number: 177****2269.<br></code></pre></td></tr></table></figure><h2 id="正则表达式">3 正则表达式</h2><p>因为以下的部分内容是拓展正则，所以建议使用正则时最好都加上选项<strong>-E</strong>，使用拓展正则的模式。</p><h3 id="锚点">3.1 锚点</h3><ul><li><strong>^word</strong>：匹配的内容必须以word开头。</li><li><strong>word$</strong>：匹配的内容必须以$结尾。</li></ul><h3 id="字符类">3.2 字符类</h3><ul><li><p><strong>[list]</strong>：将list字符串中的每个字符看作是单个元素，进而得到一个集合，匹配的内容必须包含集合中的某个元素。</p></li><li><p><strong>[n1-n2]</strong>：将一个范围内的同类型字符组合为list，例如[0-9]、[a-z]、[A-Z]。还可以和list混用，例如[abc0-2]代表abc012组成的集合。</p></li><li><p><strong>[^list]</strong>：对于集合取反。</p></li><li><p><strong>\w</strong>:英文字母和数字组成的集合。</p></li><li><p><strong>\W</strong>:对<strong>\w</strong>取反以后的结果。</p></li><li><p><strong>(|)</strong>：相较于<strong>[]</strong>使用单个字符作为元素，<strong>()</strong>使用字符串作为元素，进而组成集合，划分元素的方法是使用符合，这里匹配到的结果可以作为<strong>捕获</strong>，在后续根据<strong>\number</strong>取出第number个捕获的结果进行复用。</p></li><li><p>为了匹配一些特殊字符，<strong>[]</strong>中还提供了一些特殊的写法。</p><ul><li><p><strong>[:alnum:]</strong>：文字数字，这里的文字还包含了中文。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> user1.txt <br>user1.txt<br>name: feng.<br>telephone number: 177****2269.<br><br>西江月·世事一场大梦<br>    作者：苏轼<br>世事一场大梦，人生几度新〔秋〕凉？夜来风叶已鸣廊，看取眉头鬓上。<br>酒贱常愁客少，月明多被云妨。中秋谁与共孤光，把盏凄然北望。<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> user1.txt | grep -E <span class="hljs-string">&#x27;[[:alnum:]]*&#x27;</span><br>user1.txt<br>name: feng.<br>telephone number: 177****2269.<br><br>西江月·世事一场大梦<br>    作者：苏轼<br>世事一场大梦，人生几度新〔秋〕凉？夜来风叶已鸣廊，看取眉头鬓上。<br>酒贱常愁客少，月明多被云妨。中秋谁与共孤光，把盏凄然北望。<br></code></pre></td></tr></table></figure></li><li><p><strong>[:alpha:]</strong>：文字，这里的文字也包含中文。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> user1.txt <br>user1.txt<br>name: feng.<br>telephone number: 177****2269.<br><br>西江月·世事一场大梦<br>    作者：苏轼<br>世事一场大梦，人生几度新〔秋〕凉？夜来风叶已鸣廊，看取眉头鬓上。<br>酒贱常愁客少，月明多被云妨。中秋谁与共孤光，把盏凄然北望。<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> user1.txt | grep -E <span class="hljs-string">&#x27;[[:alpha:]]*&#x27;</span><br>user1.txt<br>name: feng.<br>telephone number: 177****2269.<br><br>西江月·世事一场大梦<br>    作者：苏轼<br>世事一场大梦，人生几度新〔秋〕凉？夜来风叶已鸣廊，看取眉头鬓上。<br>酒贱常愁客少，月明多被云妨。中秋谁与共孤光，把盏凄然北望。<br></code></pre></td></tr></table></figure></li><li><p><strong>[:punct:]</strong>：标点符号</p></li><li><p><strong>[:digit:]</strong>：数字</p></li><li><p><strong>[:xdigit:]</strong>：十六进制数字（0-9，a-f，A-F）</p></li><li><p><strong>[:graph:]</strong>：非空字符（不包括空格，不包括控制字符）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> user3.txt <br>namelibai<br>age 13<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ grep -E <span class="hljs-string">&#x27;[[:graph:]]*[[:cntrl:]][[:graph:]]*&#x27;</span> user3.txt -x <span class="hljs-comment"># 中间的制表符用cntrl匹配了，说明两边的graph，不仅不带空格，还不带控制字符。</span><br>namelibai<br></code></pre></td></tr></table></figure></li><li><p><strong>[:print:]</strong>：非空字符（包括空格，不包括控制字符）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> user3.txt <br>namelibai<br>age 13<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ grep -E <span class="hljs-string">&#x27;[[:print:]]*&#x27;</span> user3.txt -x <span class="hljs-comment"># 整行都匹配上的情况只有第二行，也就是集合中有空格，但是没有控制字符。</span><br>age 13<br></code></pre></td></tr></table></figure></li><li><p><strong>[:space:]</strong>：所有空白字符（换行，空格，制表符）</p></li><li><p><strong>[:lower:]</strong>：小写字符</p></li><li><p><strong>[:upper:]</strong>：大写字符</p></li><li><p><strong>[:cntrl:]</strong>：控制字符</p></li></ul></li></ul><h3 id="通配符">3.3 通配符</h3><ul><li><strong>.</strong>：用于匹配任意的单个字符</li><li><strong>\&lt;hell</strong>：用于匹配hello开头的单词。</li><li><strong>llo\&gt;</strong>：用于匹配llo结尾的单词。</li></ul><h3 id="量词">3.4 量词</h3><ul><li><strong>{N}</strong>：匹配前一个集合N次。集合的情况包含单个字符，使用<strong>[]</strong>组成以单个字符为元素的集合，使用<strong>()</strong>组成的以字符串为元素的集合。</li><li><strong>{N,M}</strong>：匹配前一个集合，至少N次，至多M次。</li><li><strong>{N,}</strong>：匹配前一个集合，至少N次，不设置上限。</li><li><strong>?</strong>：匹配前一个集合，零次或一次。</li><li><strong>*</strong>：匹配前一个集合，零次或多次。</li><li><strong>+</strong>：匹配前一个集合，一次或多次。</li></ul><h2 id="选项">4 选项</h2><p>接下来将会对<strong>/etc/hosts</strong>中的内容进行过滤，内容如下，后续不再赘述：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts<br>127.0.0.1localhost<br>127.0.1.1ubuntu<br>20.205.243.166  github.com<br><span class="hljs-comment"># The following lines are desirable for IPv6 capable hosts</span><br>::1     ip6-localhost ip6-loopback<br>fe00::0 ip6-localnet<br>ff00::0 ip6-mcastprefix<br>ff02::1 ip6-allnodes<br>ff02::2 ip6-allrouters<br></code></pre></td></tr></table></figure><ul><li><p><strong>-a</strong>或<strong>--text</strong>：不要忽略二进制的内容。</p></li><li><p><strong>-Anumber</strong>或<strong>--after-context=number</strong>：在查询到匹配行之后，顺势给出后number行的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;github&#x27;</span> -A 3<br>20.205.243.166  github.com<br><span class="hljs-comment"># The following lines are desirable for IPv6 capable hosts</span><br>::1     ip6-localhost ip6-loopback<br>fe00::0 ip6-localnet<br></code></pre></td></tr></table></figure></li><li><p><strong>-b</strong>或<strong>--byte-offset</strong>：查询到结果时，给出该行第一个字符在整个文件中的字符偏移量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;localhost&#x27;</span> -b<br>0:127.0.0.1localhost<br>123:::1     ip6-localhost ip6-loopback<br></code></pre></td></tr></table></figure></li><li><p><strong>-Bnumber</strong>或<strong>--before-context=number</strong>：查询到结果时，顺势给出前number行的内容，与-A相反。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;loopback&#x27;</span> -B 3<br>127.0.1.1ubuntu<br>20.205.243.166  github.com<br><span class="hljs-comment"># The following lines are desirable for IPv6 capable hosts</span><br>::1     ip6-localhost ip6-loopback<br></code></pre></td></tr></table></figure></li><li><p><strong>-c</strong>或<strong>--count</strong>：计算匹配成功的行数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;localhost&#x27;</span> -c<br>2<br></code></pre></td></tr></table></figure></li><li><p><strong>-Cnumber</strong>或<strong>--context=number</strong>：查询到结果时，顺势给出上下各number行的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;loopback&#x27;</span> -C 3<br>127.0.1.1ubuntu<br>20.205.243.166  github.com<br><span class="hljs-comment"># The following lines are desirable for IPv6 capable hosts</span><br>::1     ip6-localhost ip6-loopback<br>fe00::0 ip6-localnet<br>ff00::0 ip6-mcastprefix<br>ff02::1 ip6-allnodes<br></code></pre></td></tr></table></figure></li><li><p><strong>-d动作</strong>或<strong>--directories=动作</strong>：当指定要查找的是目录而非文件时，必须使用此参数，动作一般使用recurse。但是这一项不怎么使用，可以直接使用-r实现该效果。</p></li><li><p><strong>-e正则表达式</strong>或<strong>--regexp=正则表达式</strong>：指定字符串做为查找文件内容的样式。这个选项的主要作用是可以同时使用多个正则表达式做匹配，进而获取并集的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E -e <span class="hljs-string">&#x27;local&#x27;</span>  -e <span class="hljs-string">&#x27;1&#x27;</span><br>127.0.0.1localhost<br>127.0.1.1ubuntu<br>20.205.243.166  github.com<br>::1     ip6-localhost ip6-loopback<br>fe00::0 ip6-localnet<br>ff02::1 ip6-allnodes<br></code></pre></td></tr></table></figure></li><li><p><strong>-E</strong>或<strong>--extended-regexp</strong>：本次使用的正则表达式按照拓展正则进行解析。</p></li><li><p><strong>-f文件名字</strong>或<strong>--file=文件名字</strong>：指定规则文件，其内容含有一个或多个正则表达式样式，让grep查找符合条件的文件内容。注意，写到规则文件中的内容，并不需要单引号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> regul.txt <br><span class="hljs-built_in">local</span><br>1<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E -f regul.txt <br>127.0.0.1localhost<br>127.0.1.1ubuntu<br>20.205.243.166  github.com<br>::1     ip6-localhost ip6-loopback<br>fe00::0 ip6-localnet<br>ff02::1 ip6-allnodes<br></code></pre></td></tr></table></figure></li><li><p><strong>-F</strong>或<strong>--fixed-regexp</strong>：将匹配模式视为固定字符串的列表，而不当作正则表达式使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;u.*tu&#x27;</span> <span class="hljs-comment"># 直接使用这个正则表达式时是可以匹配成功的。</span><br>127.0.1.1ubuntu<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E -F <span class="hljs-string">&#x27;u.*tu&#x27;</span> <span class="hljs-comment"># 同时使用-E和-F存在冲突。</span><br>grep: conflicting matchers specified<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -F <span class="hljs-string">&#x27;u.*tu&#x27;</span> <span class="hljs-comment"># 使用-F匹配该表达式以后，就匹配失败了，因为没有这样的字符串。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>-G</strong>或<strong>--basic-regexp</strong>：将匹配模式当作普通的正则表达式使用，并不会按照拓展模式使用。</p></li><li><p><strong>-h</strong>或<strong>--no-filename</strong>：在显示匹配成功的结果时，不标识该行属于哪个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;u.*tu&#x27;</span> -h<br>127.0.1.1ubuntu<br></code></pre></td></tr></table></figure></li><li><p><strong>-H</strong>或<strong>--with-filename</strong>：在显示匹配成功的结果时，标识该行属于哪个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;u.*tu&#x27;</span> -H <span class="hljs-comment"># 这里给定的是管道符的输入，所以标识的来源为标准输入。</span><br>(standard input):127.0.1.1ubuntu<br></code></pre></td></tr></table></figure></li><li><p><strong>-i</strong>或<strong>--ignore-case</strong>：忽略字符串大小写的匹配。</p></li><li><p><strong>-l</strong>或<strong>--file-with-matches</strong>：在匹配成功后，并不是给出匹配成功的行，而是直接给文件的名称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;u.*tu&#x27;</span> -l<br>(standard input)<br></code></pre></td></tr></table></figure></li><li><p><strong>-L</strong>或<strong>--files-without-match</strong>：找出没有一处匹配成功的文件。</p></li><li><p><strong>-n</strong>或<strong>--line-number</strong>：在显示匹配成功的结果之前，标识该行所处的行数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;u.*tu&#x27;</span> -n<br>2:127.0.1.1ubuntu<br></code></pre></td></tr></table></figure></li><li><p><strong>-o</strong>或<strong>--only-matching</strong>：仅显示匹配成功的结果，而不是显示一整行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;u.*tu&#x27;</span> -o<br>ubuntu<br></code></pre></td></tr></table></figure></li><li><p><strong>-P</strong>：进入Perl风格的正则表达式，功能更加强大可以额外使用的功能包含如下几点：</p><ol type="1"><li><p><code>\K</code>用于需要匹配一部分内容，但是只想返回特定部分时，避免使用捕获组的场景。</p><p>例如，需要查询前缀前跟着的后缀值的场景，当只关心后缀值的情况下，可以使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;age: 13&quot;</span> | grep -P -o <span class="hljs-string">&quot;age: \K\d+&quot;</span> <span class="hljs-comment"># 此时会匹配到整段内容，虽然加了-o,但是也应该显示一段全部的内容，所以加了\k,可以忽略\K前面的内容。</span><br>13<br></code></pre></td></tr></table></figure></li></ol></li><li><p><strong>-q</strong>或<strong>--quiet</strong>或<strong>--silent</strong>：不显示任何信息，即便匹配成功。</p></li><li><p><strong>-r</strong>或<strong>--recursive</strong>：在输入源包含<strong>目录</strong>时使用，递归处理目录中的每一个文件。</p></li><li><p><strong>-v</strong>或<strong>--invert-match</strong>：将结果取反，匹配成功的不要了，只取匹配失败的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;u.*tu&#x27;</span> -v<br>127.0.0.1localhost<br>20.205.243.166  github.com<br><span class="hljs-comment"># The following lines are desirable for IPv6 capable hosts</span><br>::1     ip6-localhost ip6-loopback<br>fe00::0 ip6-localnet<br>ff00::0 ip6-mcastprefix<br>ff02::1 ip6-allnodes<br>ff02::2 ip6-allrouters<br></code></pre></td></tr></table></figure></li><li><p><strong>-w</strong>或<strong>--word-regexp</strong>：只有整个单词都匹配上了，才算匹配成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;ubun&#x27;</span><br>127.0.1.1ubuntu<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;ubun&#x27;</span> -w <span class="hljs-comment"># 这里虽然能找到127.0.1.1ubuntu存在ubun，但没有匹配上整个单词，所以还是匹配失败。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>-x</strong>或<strong>--line-regexp</strong>：只有整行匹配上了，才算匹配成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;127\.0\.1\.1[[:space:]]ubu&#x27;</span><br>127.0.1.1ubuntu<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;127\.0\.1\.1[[:space:]]ubu&#x27;</span> -x <span class="hljs-comment"># 这里虽然能够匹配上部分，但是没有匹配成功一整行，所以匹配失败。</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Usage</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub个人网站搭建,使用fluid主题</title>
    <link href="/2024/09/07/GitHub%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/09/07/GitHub%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="安装node.jsgithexopandoc">1 安装node.js、git、hexo、pandoc</h2><h3 id="安装node.js以及npm">1.1 安装node.js以及npm</h3><p>在<ahref="http://nodejs.cn/download/">node.js官网</a>下载对应的windows系统下安装包一路安装后，会附带npm的安装。</p><p>安装完成后，使用<code>node -v</code>测试node.js的安装情况，使用<code>npm -v</code>测试npm的安装情况。</p><h3 id="修改npm的配置路径">1.2 修改npm的配置路径</h3><p>使用命令<code>npm list -global</code>查看当前npm的默认存储位置。</p><p>在自定义的位置下新建两个文件夹node_global以及node_cache。</p><p>使用以下命令设置，并再次使用<code>npm list -global</code>检查。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> prefix <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;node_gloabl文件夹的全路径&#125;</span>&quot;</span><br>npm config <span class="hljs-built_in">set</span> cache <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;node_cache文件夹的全路径&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><p>使用命令<code>npm install express -g</code>测试，如果下载过程中出现问题，改用管理员身份进行下载，安装完成后使用再次使用<code>npm list -global</code>发现结果发生改变，并且在node_global文件夹下也出现了安装的内容，说明以后安装的内容都会在这个文件夹中。</p><h3 id="修改npm环境变量">1.3 修改npm环境变量</h3><p>打开windows下的环境变量设置，对<strong>Administrator的用户变量</strong>中Path进行修改，将原始的npm路径修改为node_global的路径；对<strong>系统变量</strong>进行新增，插入变量名为NODE_PATH，变量值为node_global下node_modules文件夹的全路径。</p><h3 id="安装git">1.4 安装git</h3><p>设置ssh，起码可以拉取自己的仓库，这部分不做详述。</p><h3 id="安装hexo以及依赖">1.5 安装hexo以及依赖</h3><p>使用命令<code>npm install hexo -g</code>安装hexo，使用命令<code>hexo -v</code>检验。</p><p>使用命令<code>npm install --save hexo-deployer-git</code>安装hexo依赖。</p><p>使用命令<code>npm install hexo-renderer-pandoc --save</code>安装pandoc渲染的依赖。</p><h3 id="安装pandoc">1.6 安装pandoc</h3><p>因为使用默认的markdown渲染工具可能会存在渲染不达预期的情况，比如粗体斜体或者公式等等，所以这里安装一下<strong>pandoc</strong>。</p><p>下载<ahref="https://github.com/jgm/pandoc/releases/tag/3.3">pandoc-3.3-windows-x86_64.zip</a>，在解压缩之后，将执行路径加入到环境变量的用户变量中。也即在用户变量的Path中新建一个pandoc.exe的全路径即可。</p><h2 id="建立个人博客">2 建立个人博客</h2><h3 id="创建git项目">2.1 创建git项目</h3><p>创建一个名为<code>$&#123;username&#125;.github.io</code>的git项目,并记录其<strong>ssh</strong>地址。</p><h3 id="初始化hexo">2.2 初始化hexo</h3><p>在系统上创建博客文件夹，并在其目录下执行<code>hexo init</code>,这会将hexo的项目从github上拉取下来。</p><p>接着将项目中的<strong>_config.yml</strong>配置文件中的deploy配置项按照如下规则进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">$&#123;2.1步中记录的ssh地址&#125;</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">$&#123;需要部署的分支的名字，自己决定是main还是master&#125;</span><br></code></pre></td></tr></table></figure><h3 id="设置网站主题">2.3 设置网站主题</h3><p>找一个自己喜欢的hexo主题，进行自定义设置。</p><p>可以在<a href="https://hexo.io/themes/">Themes |Hexo</a>搜索，也可以直接在GitHub上搜索hexo-theme开头的仓库，一般都是hexo的主题仓库。一般仓库中都会给出对应的安装教程。</p><h4 id="设置hexo-theme-fluid主题过程">2.3.1设置hexo-theme-fluid主题过程</h4><p>下载<ahref="https://github.com/fluid-dev/hexo-theme-fluid/releases">1.9.8版本的fluid</a>解压到<strong>themes</strong>目录下，并将解压出的文件夹重命名为<code>fluid</code>。</p><p>修改_config.yml中的相关配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><p>执行命令<code>hexo new page "about"</code>新建<strong>关于页</strong>，进而在<strong>/source/about/index.md</strong>中编辑<strong>关于页</strong>的内容，按照如下修改<strong>front-matter</strong>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br></code></pre></td></tr></table></figure><p>执行命令<code>hexo new page "archives"</code>，创建<strong>归档</strong>页面，按照如下修改<strong>front-matter</strong>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">archives</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">archive</span><br></code></pre></td></tr></table></figure><p>执行命令<code>hexo new page "tags"</code>，创建<strong>标签</strong>页面，后续在文章中使用标签tags，即可在<strong>标签</strong>页分类，按照如下修改<strong>front-matter</strong>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">tags</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">tag</span><br></code></pre></td></tr></table></figure><p>执行命令<code>hexo new page "categories"</code>，创建<strong>目录</strong>页面，后续在文章中使用标签categories，即可在<strong>目录</strong>页分类，按照如下修改<strong>front-matter</strong>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">categories</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">category</span><br></code></pre></td></tr></table></figure><p>执行命令<code>npm install --save hexo-theme-fluid</code>，替换为<strong>fluid</strong>主题。</p><h3 id="发布博客">2.4 发布博客</h3><h4 id="建立新的博客">2.4.1 建立新的博客</h4><p>执行命令<code>hexo new $&#123;博客名字&#125;</code>，即可在<strong>source/_posts</strong>下创建文章，进而编写自己的博客内容。</p><h4 id="发布博客-1">2.4.2 发布博客</h4><p>执行命令<code>hexo clean</code>清除缓存。</p><p>执行命令<code>hexo generate</code>生成静态文件。</p><p>执行命令<code>hexo deploy</code>推送项目到自己的github仓库中。</p><p>只要执行以上三步，就可以将本地的博客文件夹下的内容全部推送到刚刚新建的个人博客仓库中去。</p><h4 id="访问页面">2.4.3 访问页面</h4><p>此时，只要访问<code>$&#123;username&#125;.github.io</code>即可得到最终的结果。</p><h2 id="fluid主题优化">3 fluid主题优化</h2><h3 id="创建配置文件_config.fluid.yml">3.1创建配置文件<code>_config.fluid.yml</code></h3><p>因为_config.fluid.yml中的配置项优先级比_config.yml中更高，所以一些自定义修改内容，以后直接在这个配置文件中进行修改即可。如果修改完配置，并提交到了github仓库，可能并不会立即生效，可以稍等一会。</p><h3 id="网站通用配置">3.2 网站通用配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">index:</span> <span class="hljs-comment"># 首页资源</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/bg/index_background.png</span> <span class="hljs-comment"># 背景图的路径,默认拼接到/source目录下</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">100</span> <span class="hljs-comment"># 背景图的高度，范围是[0, 100]</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.0</span> <span class="hljs-comment"># 背景图的透明度</span><br>  <span class="hljs-attr">slogan:</span> <span class="hljs-comment"># 设置首页大图中的标题文字，就是打字机打出来的那个。</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">text:</span> <span class="hljs-string">Hi</span><br>  <span class="hljs-attr">auto_excerpt:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 设置是否显示摘要，以下是编写摘要的格式</span><br><br><span class="hljs-attr">post:</span> <span class="hljs-comment"># 博客页面的设置</span><br>  <span class="hljs-attr">default_index_img:</span> <span class="hljs-string">/img/bg/blog_index_background.png</span> <span class="hljs-comment"># 博客页面在首页显示的封面图,在front-matter中设置的优先级更高。</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/bg/blog_banner_background.png</span> <span class="hljs-comment"># 博客页面的背景图，在front-matter中设置的优先级更高。</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">100</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br>  <span class="hljs-attr">meta:</span><br>    <span class="hljs-attr">author:</span>  <span class="hljs-comment"># 作者，优先根据 front-matter 里 author 字段，其次是 hexo 配置中 author 值</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">date:</span>  <span class="hljs-comment"># 文章日期，优先根据 front-matter 里 date 字段，其次是 md 文件日期</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;dddd, MMMM Do YYYY, h:mm a&quot;</span>  <span class="hljs-comment"># 格式参照 ISO-8601 日期格式化</span><br>    <span class="hljs-attr">wordcount:</span>  <span class="hljs-comment"># 字数统计</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 字&quot;</span>  <span class="hljs-comment"># 显示的文本，&#123;&#125;是数字的占位符（必须包含)，下同</span><br>    <span class="hljs-attr">min2read:</span>  <span class="hljs-comment"># 阅读时间</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 分钟&quot;</span><br><br>  <span class="hljs-attr">category_bar:</span> <span class="hljs-comment"># 侧边栏展示当前分类下的文章</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 开启后，只有在文章 Front-matter 里指定 `category_bar: true` 才会展示分类，也可以通过 `category_bar: [&quot;分类A&quot;]` 来指定分类</span><br>    <span class="hljs-comment"># If true, only set `category_bar: true` in Front-matter will enable sidebar of category, also set `category_bar: [&quot;CategoryA&quot;]` to specify categories</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># 置于板块的左侧或右侧</span><br>    <span class="hljs-comment"># place in the board</span><br>    <span class="hljs-comment"># Options: left | right</span><br>    <span class="hljs-attr">placement:</span> <span class="hljs-string">right</span><br><br>    <span class="hljs-comment"># 文章的排序字段，前面带减号是倒序，不带减号是正序</span><br>    <span class="hljs-comment"># Sort field for posts, with a minus sign is reverse order</span><br>    <span class="hljs-comment"># Options: date | title | or other field of front-matter</span><br>    <span class="hljs-attr">post_order_by:</span> <span class="hljs-string">&quot;title&quot;</span><br><br>    <span class="hljs-comment"># 单个分类中折叠展示文章数的最大值，超过限制会显示 More，0 则不限制</span><br>    <span class="hljs-comment"># The maximum number of posts in a single category. If the limit is exceeded, it will be displayed More. If 0 no limit</span><br>    <span class="hljs-attr">post_limit:</span> <span class="hljs-number">0</span><br><br>  <span class="hljs-comment"># 侧边栏展示文章目录</span><br>  <span class="hljs-comment"># Table of contents (TOC) in the sidebar</span><br>  <span class="hljs-attr">toc:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 置于板块的左侧或右侧</span><br>    <span class="hljs-comment"># place in the board</span><br>    <span class="hljs-comment"># Options: left | right</span><br>    <span class="hljs-attr">placement:</span> <span class="hljs-string">left</span><br><br>    <span class="hljs-comment"># 目录会选择这些节点作为标题</span><br>    <span class="hljs-comment"># TOC will select these nodes as headings</span><br>    <span class="hljs-attr">headingSelector:</span> <span class="hljs-string">&quot;h1,h2,h3,h4,h5,h6&quot;</span><br><br>    <span class="hljs-comment"># 层级的折叠深度，0 是全部折叠，大于 0 后如果存在下级标题则默认展开</span><br>    <span class="hljs-comment"># Collapse depth. If 0, all headings collapsed. If greater than 0, it will be expanded by default if there are sub headings</span><br>    <span class="hljs-attr">collapseDepth:</span> <span class="hljs-number">6</span><br><br>  <span class="hljs-comment"># 版权声明，会显示在每篇文章的结尾</span><br>  <span class="hljs-comment"># Copyright, will be displayed at the end of each post</span><br>  <span class="hljs-attr">copyright:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># CreativeCommons license</span><br>    <span class="hljs-comment"># Options: BY | BY-SA | BY-ND | BY-NC | BY-NC-SA | BY-NC-ND</span><br>    <span class="hljs-attr">license:</span> <span class="hljs-string">&#x27;BY&#x27;</span><br><br>    <span class="hljs-comment"># 显示作者</span><br>    <span class="hljs-attr">author:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 显示发布日期</span><br>    <span class="hljs-comment"># Show post date</span><br>    <span class="hljs-attr">post_date:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;LL&quot;</span><br><br>    <span class="hljs-comment"># 显示更新日期</span><br>    <span class="hljs-comment"># Show update date</span><br>    <span class="hljs-attr">update_date:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;LL&quot;</span><br><br>  <span class="hljs-comment"># 文章底部上一篇下一篇功能</span><br>  <span class="hljs-comment"># Link to previous/next post</span><br>  <span class="hljs-attr">prev_next:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 文章图片标题</span><br>  <span class="hljs-comment"># Image caption</span><br>  <span class="hljs-attr">image_caption:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 文章图片可点击放大</span><br>  <span class="hljs-comment"># Zoom feature of images</span><br>  <span class="hljs-attr">image_zoom:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># 放大后图片链接替换规则，可用于将压缩图片链接替换为原图片链接，如 [&#x27;-slim&#x27;, &#x27;&#x27;] 是将链接中 `-slim` 移除；如果想使用正则请使用 `re:` 前缀，如 [&#x27;re:\\d&#123;3,4&#125;\\/\\d&#123;3,4&#125;\\/&#x27;, &#x27;&#x27;]</span><br>    <span class="hljs-comment"># The image url replacement when zooming, the feature can be used to replace the compressed image to the original image, eg: [&#x27;-slim&#x27;, &#x27;&#x27;] removes `-slim` from the image url when zooming; if you want to use regular, use prefix `re:`, eg: [&#x27;re:\\d&#123;3,4&#125;\\/\\d&#123;3,4&#125;\\/&#x27;,&#x27;&#x27;]</span><br>    <span class="hljs-attr">img_url_replace:</span> [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>]<br><br><span class="hljs-attr">archive:</span> <span class="hljs-comment"># 归档页面</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/bg/archives_background.png</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">100</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br><span class="hljs-attr">category:</span> <span class="hljs-comment"># 分类页面</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/bg/categories_background.png</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">60</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br><span class="hljs-attr">tag:</span> <span class="hljs-comment"># 标签页面</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/bg/tags_background.png</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br>  <span class="hljs-attr">tagcloud:</span> <span class="hljs-comment"># 改变标签显示的方式。</span><br>    <span class="hljs-attr">min_font:</span> <span class="hljs-number">15</span><br>    <span class="hljs-attr">max_font:</span> <span class="hljs-number">30</span><br>    <span class="hljs-attr">unit:</span> <span class="hljs-string">px</span><br>    <span class="hljs-attr">start_color:</span> <span class="hljs-string">&quot;#BBBBEE&quot;</span> <span class="hljs-comment"># 最开始的颜色</span><br>    <span class="hljs-attr">end_color:</span> <span class="hljs-string">&quot;#337ab7&quot;</span> <span class="hljs-comment"># 鼠标移上去以后的颜色</span><br><br><span class="hljs-attr">about:</span> <span class="hljs-comment"># 关于页面</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/bg/about_background.png</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">60</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br>  <span class="hljs-attr">avatar:</span> <span class="hljs-string">/img/bg/avatar.png</span> <span class="hljs-comment"># 设置头像</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;锋&quot;</span><br>  <span class="hljs-attr">intro:</span> <span class="hljs-string">&quot;Hi&quot;</span><br>  <span class="hljs-attr">icons:</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&quot;iconfont icon-github-fill&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;https://github.com/Astronaut-diode&quot;</span>, <span class="hljs-attr">tip:</span> <span class="hljs-string">&quot;GitHub&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&quot;iconfont icon-bilibili-fill&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;https://space.bilibili.com/415812264&quot;</span>, <span class="hljs-attr">tip:</span> <span class="hljs-string">&quot;Bilibili&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&quot;iconfont icon-wechat-fill&quot;</span>, <span class="hljs-attr">qrcode:</span> <span class="hljs-string">&quot;/img/bg/wechat_qrcode.jpg&quot;</span> &#125;<br><br><span class="hljs-attr">navbar:</span> <span class="hljs-comment"># 导航栏设置</span><br>  <span class="hljs-attr">blog_title:</span> <span class="hljs-string">锋的博客</span> <span class="hljs-comment"># 博客标题</span><br><br><span class="hljs-attr">footer:</span><br>  <span class="hljs-comment"># 页脚第一行文字的 HTML，最好是不设置，但是有点强迫症，还是隐了。</span><br>  <span class="hljs-attr">content:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-attr">code:</span> <span class="hljs-comment"># 代码块的配置</span><br>  <span class="hljs-attr">copy_btn:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否开启复制代码的按钮</span><br>  <span class="hljs-attr">highlight:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否开启代码高亮</span><br>    <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否开启行号</span><br>    <span class="hljs-attr">lib:</span> <span class="hljs-string">&quot;highlightjs&quot;</span> <span class="hljs-comment"># 高亮的代码风格</span><br>    <span class="hljs-attr">highlightjs:</span><br>      <span class="hljs-attr">style:</span> <span class="hljs-string">&#x27;Github Gist&#x27;</span><br>      <span class="hljs-attr">bg_color:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">prismjs:</span><br>      <span class="hljs-attr">style:</span> <span class="hljs-string">&quot;default&quot;</span><br>      <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br><br><br><span class="hljs-comment"># 用于浏览器标签的图标</span><br><span class="hljs-comment"># Icon for browser tab</span><br><span class="hljs-attr">favicon:</span> <span class="hljs-string">/img/bg/favicon.png</span><br><br><span class="hljs-comment"># 用于苹果设备的图标</span><br><span class="hljs-comment"># Icon for Apple touch</span><br><span class="hljs-attr">apple_touch_icon:</span> <span class="hljs-string">/img/bg/favicon.png</span><br></code></pre></td></tr></table></figure><h3 id="front-matter配置">3.3 front-matter配置</h3><p>front-matter指的就是每篇博客前面写的那段配置内容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">author:</span> <span class="hljs-string">作者名字</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">博客标题</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">摘要内容</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2035-04-07 00:00:00</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/bg/blog_index_background.png</span> <span class="hljs-comment"># 博客在首页的封面图</span><br><span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/bg/blog_banner_background.png</span> <span class="hljs-comment"># 博客页面的背景图</span><br><span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">100</span><br><span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><span class="hljs-attr">tags:</span> <span class="hljs-comment"># 这里的标签是同级别的</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">标签A</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">标签B</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">标签C</span><br><span class="hljs-attr">categories:</span> <span class="hljs-comment"># 这里是多级分类的写法</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">分类1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">分类1的子分类1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">分类1的子分类1的子分类1</span><br></code></pre></td></tr></table></figure><h3 id="config.yml">3.4 _config.yml</h3><p>这里保存一下改动过的_config.yml，以作备份。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Hexo Configuration</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="hljs-comment">## Source: https://github.com/hexojs/hexo/</span><br><br><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">锋的博客</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">keywords:</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">锋</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://astronaut-diode.github.io/</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br><span class="hljs-attr">permalink_defaults:</span><br><span class="hljs-attr">pretty_urls:</span><br>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br><br><span class="hljs-comment"># Directory</span><br><span class="hljs-attr">source_dir:</span> <span class="hljs-string">source</span><br><span class="hljs-attr">public_dir:</span> <span class="hljs-string">public</span><br><span class="hljs-attr">tag_dir:</span> <span class="hljs-string">tags</span><br><span class="hljs-attr">archive_dir:</span> <span class="hljs-string">archives</span><br><span class="hljs-attr">category_dir:</span> <span class="hljs-string">categories</span><br><span class="hljs-attr">code_dir:</span> <span class="hljs-string">downloads/code</span><br><span class="hljs-attr">i18n_dir:</span> <span class="hljs-string">:lang</span><br><span class="hljs-attr">skip_render:</span><br><br><span class="hljs-comment"># Writing</span><br><span class="hljs-attr">new_post_name:</span> <span class="hljs-string">:title.md</span> <span class="hljs-comment"># File name of new posts</span><br><span class="hljs-attr">default_layout:</span> <span class="hljs-string">post</span><br><span class="hljs-attr">titlecase:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Transform title into titlecase</span><br><span class="hljs-attr">external_link:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Open external links in new tab</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">site</span> <span class="hljs-comment"># Apply to the whole site</span><br>  <span class="hljs-attr">exclude:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">filename_case:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">render_drafts:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">relative_link:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">future:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">syntax_highlighter:</span> <span class="hljs-string">highlight.js</span><br><span class="hljs-attr">highlight:</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">auto_detect:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">wrap:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">hljs:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">prismjs:</span><br>  <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-comment"># Home page setting</span><br><span class="hljs-comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class="hljs-comment"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="hljs-comment"># order_by: Posts order. (Order by date descending by default)</span><br><span class="hljs-attr">index_generator:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">order_by:</span> <span class="hljs-string">-date</span><br><br><span class="hljs-comment"># Category &amp; Tag</span><br><span class="hljs-attr">default_category:</span> <span class="hljs-string">uncategorized</span><br><span class="hljs-attr">category_map:</span><br><span class="hljs-attr">tag_map:</span><br><br><span class="hljs-comment"># Metadata elements</span><br><span class="hljs-comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span><br><span class="hljs-attr">meta_generator:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># Date / Time format</span><br><span class="hljs-comment">## Hexo uses Moment.js to parse and display date</span><br><span class="hljs-comment">## You can customize the date format as defined in</span><br><span class="hljs-comment">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="hljs-attr">date_format:</span> <span class="hljs-string">YYYY-MM-DD</span><br><span class="hljs-attr">time_format:</span> <span class="hljs-string">HH:mm:ss</span><br><span class="hljs-comment">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span><br><span class="hljs-attr">updated_option:</span> <span class="hljs-string">&#x27;mtime&#x27;</span><br><br><span class="hljs-comment"># Pagination</span><br><span class="hljs-comment">## Set per_page to 0 to disable pagination</span><br><span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">pagination_dir:</span> <span class="hljs-string">page</span><br><br><span class="hljs-comment"># Include / Exclude file(s)</span><br><span class="hljs-comment">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><span class="hljs-attr">include:</span><br><span class="hljs-attr">exclude:</span><br><span class="hljs-attr">ignore:</span><br><br><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br><br><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:Astronaut-diode/Astronaut-diode.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><h2 id="添加评论功能">4 添加评论功能</h2><p>因为本次评论功能使用的组件是utterances，所以需要先去<ahref="%5BGitHub%20Apps%20-%20utterances%5D(https://github.com/apps/utterances)">install</a>。进去以后点击install，选择相应的配置后，再点击底部的install按钮，即可完成认证。</p><p>接下来直接在配置文件_config.fliud.yml中添加如下配置（repo的仓库需要改为自己的博客仓库），这样可以保证每个博客的评论是使用Github的Issue，并且是相互独立的，并且这些评论是可以被随意删除的，直接去自己的GitHub仓库删除相应的Issue即可。yaml配置中utterances中除了repo是指明目标仓库的，其余的是评论的外观设置，可以自己搜索对应的设置改写。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">comments:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">utterances</span><br><br><span class="hljs-attr">utterances:</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">Astronaut-diode/Astronaut-diode.github.io</span><br>  <span class="hljs-attr">issue_term:</span> <span class="hljs-string">pathname</span><br>  <span class="hljs-attr">label:</span> <span class="hljs-string">utterances</span><br>  <span class="hljs-attr">theme:</span> <span class="hljs-string">github-light</span><br>  <span class="hljs-attr">theme_dark:</span> <span class="hljs-string">github-dark</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>部署安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>Fluid</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

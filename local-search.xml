<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一些数学性质</title>
    <link href="/2024/10/03/%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%A6%E6%80%A7%E8%B4%A8/"/>
    <url>/2024/10/03/%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%A6%E6%80%A7%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="同余运算">1 同余运算</h2><p><strong>（a+b）mod n=((a mod n)+(b mod n)) mod n</strong></p><p><strong>(a-b)mod n=((a mod n)-(b mod n)+n)mod n</strong></p><p><strong>ab mod n=(a mod n)(b mod n)mod n</strong></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-find-substring-with-given-hash-value</title>
    <link href="/2024/10/03/Leetcode-find-substring-with-given-hash-value/"/>
    <url>/2024/10/03/Leetcode-find-substring-with-given-hash-value/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给定整数 <code>p</code> 和 <code>m</code> ，一个长度为 <code>k</code>且下标从 <strong>0</strong> 开始的字符串 <code>s</code>的哈希值按照如下函数计算：</p><ul><li><code>hash(s, p, m) = (val(s[0]) * p^0 + val(s[1]) * p^1 + ... + val(s[k-1]) * p^(k-1)) mod m</code>.</li></ul><p>其中 <code>val(s[i])</code> 表示 <code>s[i]</code>在字母表中的下标，从 <code>val('a') = 1</code> 到<code>val('z') = 26</code> 。</p><p>给你一个字符串 <code>s</code> 和整数<code>power</code>，<code>modulo</code>，<code>k</code> 和<code>hashValue</code> 。请你返回 <code>s</code> 中<strong>第一个</strong> 长度为 <code>k</code> 的 <strong>子串</strong><code>sub</code> ，满足<code>hash(sub, power, modulo) == hashValue</code> 。</p><p>测试数据保证一定 <strong>存在</strong> 至少一个这样的子串。</p><p><strong>子串</strong> 定义为一个字符串中连续非空字符组成的序列。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-built_in">power</span> = <span class="hljs-number">7</span>, modulo = <span class="hljs-number">20</span>, k = <span class="hljs-number">2</span>, hashValue = <span class="hljs-number">0</span><br>输出：<span class="hljs-string">&quot;ee&quot;</span><br>解释：<span class="hljs-string">&quot;ee&quot;</span> 的哈希值为 hash(<span class="hljs-string">&quot;ee&quot;</span>, <span class="hljs-number">7</span>, <span class="hljs-number">20</span>) = (<span class="hljs-number">5</span> * <span class="hljs-number">1</span> + <span class="hljs-number">5</span> * <span class="hljs-number">7</span>) <span class="hljs-built_in">mod</span> <span class="hljs-number">20</span> = <span class="hljs-number">40</span> <span class="hljs-built_in">mod</span> <span class="hljs-number">20</span> = <span class="hljs-number">0</span> 。<br><span class="hljs-string">&quot;ee&quot;</span> 是长度为 <span class="hljs-number">2</span> 的第一个哈希值为 <span class="hljs-number">0</span> 的子串，所以我们返回 <span class="hljs-string">&quot;ee&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：s = &quot;fbxzaad&quot;, power = 31, modulo = 100, k = 3, hashValue = 32<br>输出：&quot;fbx&quot;<br>解释：&quot;fbx&quot; 的哈希值为 hash(&quot;fbx&quot;, 31, 100) = (6 *<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>*<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 24 </span>* 312) mod<span class="hljs-number"> 100 </span>=<span class="hljs-number"> 23132 </span>mod<span class="hljs-number"> 100 </span>=<span class="hljs-number"> 32 </span>。<br>&quot;bxz&quot; 的哈希值为 hash(&quot;bxz&quot;, 31, 100) = (2 *<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 24 </span>*<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 26 </span>* 312) mod<span class="hljs-number"> 100 </span>=<span class="hljs-number"> 25732 </span>mod<span class="hljs-number"> 100 </span>=<span class="hljs-number"> 32 </span>。<br>&quot;fbx&quot; 是长度为<span class="hljs-number"> 3 </span>的第一个哈希值为<span class="hljs-number"> 32 </span>的子串，所以我们返回 &quot;fbx&quot; 。<br>注意，&quot;bxz&quot; 的哈希值也为<span class="hljs-number"> 32 </span>，但是它在字符串中比 &quot;fbx&quot; 更晚出现。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= s.length &lt;= 2 * 10^4</code></li><li><code>1 &lt;= power, modulo &lt;= 10^9</code></li><li><code>0 &lt;= hashValue &lt; modulo</code></li><li><code>s</code> 只包含小写英文字母。</li><li>测试数据保证一定 <strong>存在</strong> 满足条件的子串。</li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>因为给定的公式是<code>hash(s, p, m) = (val(s[0]) * p^0 + val(s[1]) * p^1 + ... + val(s[k-1]) * p^(k-1)) mod m</code>.所以当我们可以先计算字符串中最后一个长度为k的子字符串hash(s[n- k], p, m)，作为初始窗口。</p><p>滑动窗口的过程中，先前的结果减去最后一个字符计算出的值val(s[n - 1] *p^(k - 1))，接着整体乘以p，再加上s[n - k -1]，就可以实现结果的复用。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">subStrHash</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> power, <span class="hljs-type">int</span> modulo, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> hashValue)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> pPower = <span class="hljs-number">1</span>; <span class="hljs-comment">// p的次方，用于记录p的k-1次</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 总和</span><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), left = n - k, right = n - <span class="hljs-number">1</span>, ans = n;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; i++) &#123;<br>            sum = (sum + (pPower * (s[i] - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>)) % modulo) % modulo;<br>            <span class="hljs-keyword">if</span> (i != right)<br>                pPower = (pPower * (power % modulo)) % modulo;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum == hashValue) &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, left); <span class="hljs-comment">// 不要直接读取字符串，浪费时间</span><br>        &#125;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span> &lt; left) &#123; <span class="hljs-comment">// 移动滑动窗口，重复读入、弹出、计算答案的三步骤</span><br>            sum = (sum - (pPower * (s[right--] - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>) % modulo) + modulo) % modulo;<br>            sum = (sum * power) % modulo;<br>            left--;<br>            sum = (sum + (s[left] - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>)) % modulo;<br>            <span class="hljs-keyword">if</span> (sum == hashValue) &#123;<br>                ans = <span class="hljs-built_in">min</span>(ans, left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(ans, k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>同余运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-substring-with-concatenation-of-all-words/submissions</title>
    <link href="/2024/10/02/Leetcode-substring-with-concatenation-of-all-words-submissions/"/>
    <url>/2024/10/02/Leetcode-substring-with-concatenation-of-all-words-submissions/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给定一个字符串 <code>s</code> 和一个字符串数组<code>words</code><strong>。</strong> <code>words</code> 中所有字符串<strong>长度相同</strong>。</p><p><code>s</code> 中的 <strong>串联子串</strong> 是指一个包含<code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p><ul><li>例如，如果 <code>words = ["ab","cd","ef"]</code>， 那么<code>"abcdef"</code>， <code>"abefcd"</code>，<code>"cdabef"</code>，<code>"cdefab"</code>，<code>"efabcd"</code>， 和 <code>"efcdab"</code>都是串联子串。 <code>"acdbef"</code> 不是串联子串，因为他不是任何<code>words</code> 排列的连接。</li></ul><p>返回所有串联子串在 <code>s</code> 中的开始索引。你可以以<strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：s = <span class="hljs-string">&quot;barfoothefoobarman&quot;</span>, words = <span class="hljs-selector-attr">[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>]</span><br>输出：<span class="hljs-selector-attr">[0,9]</span><br>解释：因为 words<span class="hljs-selector-class">.length</span> == <span class="hljs-number">2</span> 同时 words<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.length</span> == <span class="hljs-number">3</span>，连接的子字符串的长度必须为 <span class="hljs-number">6</span>。<br>子串 <span class="hljs-string">&quot;barfoo&quot;</span> 开始位置是 <span class="hljs-number">0</span>。它是 words 中以 <span class="hljs-selector-attr">[<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-string">&quot;foo&quot;</span>]</span> 顺序排列的连接。<br>子串 <span class="hljs-string">&quot;foobar&quot;</span> 开始位置是 <span class="hljs-number">9</span>。它是 words 中以 <span class="hljs-selector-attr">[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>]</span> 顺序排列的连接。<br>输出顺序无关紧要。返回 <span class="hljs-selector-attr">[9,0]</span> 也是可以的。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：s = <span class="hljs-string">&quot;wordgoodgoodgoodbestword&quot;</span>, <span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;word&quot;</span>,<span class="hljs-string">&quot;good&quot;</span>,<span class="hljs-string">&quot;best&quot;</span>,<span class="hljs-string">&quot;word&quot;</span>]<br>输出：[]<br>解释：因为 <span class="hljs-built_in">words</span>.<span class="hljs-built_in">length</span> == <span class="hljs-number">4</span> 并且 <span class="hljs-built_in">words</span>[i].<span class="hljs-built_in">length</span> == <span class="hljs-number">4</span>，所以串联子串的长度必须为 <span class="hljs-number">16</span>。<br>s 中没有子串长度为 <span class="hljs-number">16</span> 并且等于 <span class="hljs-built_in">words</span> 的任何顺序排列的连接。<br>所以我们返回一个空数组。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：s = <span class="hljs-string">&quot;barfoofoobarthefoobarman&quot;</span>, <span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;the&quot;</span>]<br>输出：[<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">12</span>]<br>解释：因为 <span class="hljs-built_in">words</span>.<span class="hljs-built_in">length</span> == <span class="hljs-number">3</span> 并且 <span class="hljs-built_in">words</span>[i].<span class="hljs-built_in">length</span> == <span class="hljs-number">3</span>，所以串联子串的长度必须为 <span class="hljs-number">9</span>。<br>子串 <span class="hljs-string">&quot;foobarthe&quot;</span> 开始位置是 <span class="hljs-number">6</span>。它是 <span class="hljs-built_in">words</span> 中以 [<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-string">&quot;the&quot;</span>] 顺序排列的连接。<br>子串 <span class="hljs-string">&quot;barthefoo&quot;</span> 开始位置是 <span class="hljs-number">9</span>。它是 <span class="hljs-built_in">words</span> 中以 [<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-string">&quot;the&quot;</span>,<span class="hljs-string">&quot;foo&quot;</span>] 顺序排列的连接。<br>子串 <span class="hljs-string">&quot;thefoobar&quot;</span> 开始位置是 <span class="hljs-number">12</span>。它是 <span class="hljs-built_in">words</span> 中以 [<span class="hljs-string">&quot;the&quot;</span>,<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>] 顺序排列的连接。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>1 &lt;= words.length &lt;= 5000</code></li><li><code>1 &lt;= words[i].length &lt;= 30</code></li><li><code>words[i]</code> 和 <code>s</code> 由小写英文字母组成</li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>因为所有的单词都是一样长度，如果可以将所有的单词都看作是一个字符，然后题目就变为了在字符串中找以这些字符组成的子字符串，就会简单。</p><p>我们用哈希表记录哪些单词需要多少次，然后创建定长的滑动窗口，每次加载一个单词长度的字符时，就改变一次哈希表，如果哈希表中的string登记次数为0，就将其erase，进而计算答案时就可以根据哈希表长度是否为0进行判断是否满足条件。</p><p>起始窗口应当从[0,wordLen)的区间进行枚举，这样才能找到所有的子字符串。</p><p><strong>时间复杂度：</strong>O(wordLen *sLen)，wordLen是单词的长度，sLen是字符串的长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findSubstring</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        <span class="hljs-type">int</span> wordLen = words[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(), wordsLen = words.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> sLen = s.<span class="hljs-built_in">size</span>(), left, right;<br>        unordered_map&lt;string, <span class="hljs-type">int</span>&gt; map; <span class="hljs-comment">// &lt;字符, 需要的次数&gt;，如果需要次数为0，删除。</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <br>        <span class="hljs-keyword">if</span> (wordLen * wordsLen &gt; sLen) <br>            <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; wordLen; i++) &#123; <span class="hljs-comment">// 遍历不同的起始位置,因为单词可以是从任意一个位置开始计算。</span><br>            left = i;<br>            right = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; wordsLen; j++) &#123; <span class="hljs-comment">// 登记需要哪些单词，需要多少次。</span><br>                map[words[j]]++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (right &lt; wordsLen * wordLen) &#123; <span class="hljs-comment">// 构建初始窗口</span><br>                string word = s.<span class="hljs-built_in">substr</span>(right, wordLen);<br>                right = right + wordLen;<br>                map[word]--; <span class="hljs-comment">// 窗口中加入了一个词，需要减少所需次数</span><br>                <span class="hljs-keyword">if</span> (map[word] == <span class="hljs-number">0</span>) <br>                    map.<span class="hljs-built_in">erase</span>(word);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-comment">// 计算答案</span><br>                ans.<span class="hljs-built_in">emplace_back</span>(left);<br>            <span class="hljs-keyword">while</span> (right &lt; sLen) &#123; <span class="hljs-comment">// 重复移动滑动窗口</span><br>                string word = s.<span class="hljs-built_in">substr</span>(left, wordLen);<br>                left = left + wordLen;<br>                map[word]++; <span class="hljs-comment">// 窗口中移除一个词，需要增加所需次数</span><br>                <span class="hljs-keyword">if</span> (map[word] == <span class="hljs-number">0</span>) <br>                    map.<span class="hljs-built_in">erase</span>(word);<br>                word = s.<span class="hljs-built_in">substr</span>(right, wordLen);<br>                right = right + wordLen;<br>                map[word]--; <span class="hljs-comment">// 窗口中加入一个词，需要减少所需次数</span><br>                <span class="hljs-keyword">if</span> (map[word] == <span class="hljs-number">0</span>) <br>                    map.<span class="hljs-built_in">erase</span>(word);<br>                <span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-comment">// 计算答案</span><br>                    ans.<span class="hljs-built_in">emplace_back</span>(left);<br>            &#125;<br>            map.<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-find-all-anagrams-in-a-string</title>
    <link href="/2024/10/02/Leetcode-find-all-anagrams-in-a-string/"/>
    <url>/2024/10/02/Leetcode-find-all-anagrams-in-a-string/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code>中所有 <code>p</code> 的 <strong>异位词</strong>的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。</strong></p><p><strong>示例 1:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;cbaebabacd&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出: <span class="hljs-selector-attr">[0,6]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;cba&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">&quot;bac&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;abab&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;ab&quot;</span><br>输出: <span class="hljs-selector-attr">[0,1,2]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">1</span> 的子串是 <span class="hljs-string">&quot;ba&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">2</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, p.length &lt;= 3 * 104</code></li><li><code>s</code> 和 <code>p</code> 仅包含小写字母</li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>先计算字符串p的字母分布，然后在字符串s中进行定长滑动窗口，检查滑动窗口中的分布和p的分布是否相同，相同就记录答案。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> pSize = p.<span class="hljs-built_in">size</span>(), pArray[<span class="hljs-number">26</span>] = &#123;&#125;, sSize = s.<span class="hljs-built_in">size</span>(), sArray[<span class="hljs-number">26</span>] = &#123;&#125;, left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; p.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pSize; i++) <span class="hljs-comment">// 计算p串分布</span><br>            pArray[p[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-keyword">while</span> (right &lt; pSize) <span class="hljs-comment">// 构建初始窗口</span><br>            sArray[s[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(pArray, sArray)) ans.<span class="hljs-built_in">emplace_back</span>(left); <span class="hljs-comment">// 检查结果</span><br>        <span class="hljs-keyword">while</span> (right &lt; sSize) &#123; <span class="hljs-comment">// 移动窗口并计算结果</span><br>            sArray[s[left++] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            sArray[s[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(pArray, sArray)) ans.<span class="hljs-built_in">emplace_back</span>(left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> pArray[], <span class="hljs-type">int</span> sArray[])</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (pArray[i] != sArray[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-permutation-in-string</title>
    <link href="/2024/10/02/Leetcode-permutation-in-string/"/>
    <url>/2024/10/02/Leetcode-permutation-in-string/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断<code>s2</code> 是否包含 <code>s1</code> 的</p><p>排列</p><p>。如果是，返回 <code>true</code> ；否则，返回 <code>false</code>。</p><p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的<strong>子串</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;ab&quot;</span> <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;eidbaooo&quot;</span><br>输出：true<br>解释：<span class="hljs-built_in">s2</span> 包含 <span class="hljs-built_in">s1</span> 的排列之一 (<span class="hljs-string">&quot;ba&quot;</span>).<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s1<span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span> s2 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;eidboaoo&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s1.length, s2.length &lt;= 10^4</code></li><li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li></ul><h2 id="题解">2 题解</h2><p><strong>思路：</strong></p><p>先将s1中所有的字符分布记录到数组中，之后就是对s2进行定长的滑动窗口，每次滑完之后，就验证窗口中的分布和s1的分布是否相同。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &gt; s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> s1Alpha[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); i++) &#123;<br>            s1Alpha[s1[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125; <span class="hljs-comment">// 统计s1中各种字母的分布情况。</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, k = s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(), n = s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> s2Alpha[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <br>        <span class="hljs-keyword">while</span> (right &lt; k) &#123; <span class="hljs-comment">// 构造初始窗口</span><br>            s2Alpha[s2[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(s1Alpha, s2Alpha)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 计算答案</span><br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123; <span class="hljs-comment">// 移动左右指针</span><br>            s2Alpha[s2[left++] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            s2Alpha[s2[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(s1Alpha, s2Alpha)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 计算答案</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> s1Alpha[], <span class="hljs-type">int</span> s2Alpha[])</span> </span>&#123; <span class="hljs-comment">// 统计答案</span><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(s1Alpha[i] != s2Alpha[i]) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-minimum-swaps-to-group-all-1s-together-ii</title>
    <link href="/2024/10/02/Leetcode-minimum-swaps-to-group-all-1s-together-ii/"/>
    <url>/2024/10/02/Leetcode-minimum-swaps-to-group-all-1s-together-ii/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p><strong>交换</strong> 定义为选中一个数组中的两个<strong>互不相同</strong> 的位置并交换二者的值。</p><p><strong>环形</strong> 数组是一个数组，可以认为<strong>第一个</strong> 元素和 <strong>最后一个</strong> 元素<strong>相邻</strong> 。</p><p>给你一个 <strong>二进制环形</strong> 数组 <code>nums</code> ，返回在<strong>任意位置</strong> 将数组中的所有 <code>1</code>聚集在一起需要的最少交换次数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [0,1,0,1,1,0,0]<br>输出：1<br>解释：这里列出一些能够将所有<span class="hljs-number"> 1 </span>聚集在一起的方案：<br>[0,0,1,1,1,0,0] 交换<span class="hljs-number"> 1 </span>次。<br>[0,1,1,1,0,0,0] 交换<span class="hljs-number"> 1 </span>次。<br>[1,1,0,0,0,0,1] 交换<span class="hljs-number"> 2 </span>次（利用数组的环形特性）。<br>无法在交换<span class="hljs-number"> 0 </span>次的情况下将数组中的所有<span class="hljs-number"> 1 </span>聚集在一起。<br>因此，需要的最少交换次数为<span class="hljs-number"> 1 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [0,1,1,1,0,0,1,1,0]<br>输出：2<br>解释：这里列出一些能够将所有<span class="hljs-number"> 1 </span>聚集在一起的方案：<br>[1,1,1,0,0,0,0,1,1] 交换<span class="hljs-number"> 2 </span>次（利用数组的环形特性）。<br>[1,1,1,1,1,0,0,0,0] 交换<span class="hljs-number"> 2 </span>次。<br>无法在交换<span class="hljs-number"> 0 </span>次或<span class="hljs-number"> 1 </span>次的情况下将数组中的所有<span class="hljs-number"> 1 </span>聚集在一起。<br>因此，需要的最少交换次数为<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,1,0,0,1]<br>输出：0<br>解释：得益于数组的环形特性，所有的<span class="hljs-number"> 1 </span>已经聚集在一起。<br>因此，需要的最少交换次数为<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>nums[i]</code> 为 <code>0</code> 或者 <code>1</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>先找出数组中一共有多少个1，根据个数可以设定滑动窗口的长度，目标是找到一个位置，包含最少的0，然后将1换入即可。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSwaps</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> k = <span class="hljs-built_in">accumulate</span>(<span class="hljs-built_in">begin</span>(nums), <span class="hljs-built_in">end</span>(nums), <span class="hljs-number">0</span>); <span class="hljs-comment">// 一共有多少个1</span><br>        <span class="hljs-comment">// 接下来题目转换为在环形二进制数组中找出长度为k的所有定长子数组中，含有0最少的是多少。</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; k) &#123; <span class="hljs-comment">// 构建初始窗口</span><br>            count = count + !nums[right % n];<br>            right++;<br>        &#125;<br>        ans = count; <span class="hljs-comment">// 计算答案</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 滑动窗口</span><br>            count = count - !nums[left % n] + !nums[right % n];<br>            left++;<br>            right++;<br>            ans = <span class="hljs-built_in">min</span>(ans, count); <span class="hljs-comment">// 计算答案</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-sliding-subarray-beauty</title>
    <link href="/2024/10/02/Leetcode-sliding-subarray-beauty/"/>
    <url>/2024/10/02/Leetcode-sliding-subarray-beauty/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code>，请你求出每个长度为 <code>k</code> 的子数组的 <strong>美丽值</strong>。</p><p>一个子数组的 <strong>美丽值</strong> 定义为：如果子数组中第<code>x</code> <strong>小整数</strong> 是 <strong>负数</strong>，那么美丽值为第 <code>x</code> 小的数，否则美丽值为 <code>0</code>。</p><p>请你返回一个包含 <code>n - k + 1</code>个整数的数组，<strong>依次</strong>表示数组中从第一个下标开始，每个长度为 <code>k</code> 的子数组的<strong>美丽值</strong> 。</p><ul><li>子数组指的是数组中一段连续 <strong>非空</strong> 的元素序列。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,<span class="hljs-string">-1</span>,<span class="hljs-string">-3</span>,<span class="hljs-string">-2</span>,3], k = 3, x = 2<br>输出：[<span class="hljs-string">-1</span>,<span class="hljs-string">-2</span>,<span class="hljs-string">-2</span>]<br>解释：总共有 3 个 k = 3 的子数组。<br>第一个子数组是 [1, <span class="hljs-string">-1</span>, <span class="hljs-string">-3</span>] ，第二小的数是负数 <span class="hljs-string">-1</span> 。<br>第二个子数组是 [<span class="hljs-string">-1</span>, <span class="hljs-string">-3</span>, <span class="hljs-string">-2</span>] ，第二小的数是负数 <span class="hljs-string">-2</span> 。<br>第三个子数组是 [<span class="hljs-string">-3</span>, <span class="hljs-string">-2</span>, 3] ，第二小的数是负数 <span class="hljs-string">-2</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>,<span class="hljs-string">-4</span>,<span class="hljs-string">-5</span>], k = 2, x = 2<br>输出：[<span class="hljs-string">-1</span>,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>,<span class="hljs-string">-4</span>]<br>解释：总共有 4 个 k = 2 的子数组。<br>[<span class="hljs-string">-1</span>, <span class="hljs-string">-2</span>] 中第二小的数是负数 <span class="hljs-string">-1</span> 。<br>[<span class="hljs-string">-2</span>, <span class="hljs-string">-3</span>] 中第二小的数是负数 <span class="hljs-string">-2</span> 。<br>[<span class="hljs-string">-3</span>, <span class="hljs-string">-4</span>] 中第二小的数是负数 <span class="hljs-string">-3</span> 。<br>[<span class="hljs-string">-4</span>, <span class="hljs-string">-5</span>] 中第二小的数是负数 <span class="hljs-string">-4</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-3</span>,1,2,<span class="hljs-string">-3</span>,0,<span class="hljs-string">-3</span>], k = 2, x = 1<br>输出：[<span class="hljs-string">-3</span>,0,<span class="hljs-string">-3</span>,<span class="hljs-string">-3</span>,<span class="hljs-string">-3</span>]<br>解释：总共有 5 个 k = 2 的子数组。<br>[<span class="hljs-string">-3</span>, 1] 中最小的数是负数 <span class="hljs-string">-3</span> 。<br>[1, 2] 中最小的数不是负数，所以美丽值为 0 。<br>[2, <span class="hljs-string">-3</span>] 中最小的数是负数 <span class="hljs-string">-3</span> 。<br>[<span class="hljs-string">-3</span>, 0] 中最小的数是负数 <span class="hljs-string">-3</span> 。<br>[0, <span class="hljs-string">-3</span>] 中最小的数是负数 <span class="hljs-string">-3</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= k &lt;= n</code></li><li><code>1 &lt;= x &lt;= k</code></li><li><code>-50 &lt;= nums[i] &lt;= 50</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>因为本题出现的数字只能是[-50,50]，所以我们只要枚举即可，其他部分就是简单的滑动窗口。</p><p><strong>时间复杂度：</strong>O(101n)，也就是O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getSubarrayBeauty</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n - (k  - <span class="hljs-number">1</span>), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> array[<span class="hljs-number">101</span>] = &#123;<span class="hljs-number">0</span>&#125;, left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; k) &#123;<br>            array[nums[right++] + <span class="hljs-number">50</span>]++;<br>        &#125;<br>        tmp = x;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">101</span>; i++) &#123; <span class="hljs-comment">// 计算答案</span><br>            tmp = tmp - array[i];<br>            <span class="hljs-keyword">if</span> (tmp &lt;= <span class="hljs-number">0</span>) &#123;<br>                ans[left] = <span class="hljs-built_in">min</span>(i - <span class="hljs-number">50</span>, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123; <span class="hljs-comment">// 不断枚举左端点，移动右端点。</span><br>            array[nums[left++] + <span class="hljs-number">50</span>]--;<br>            array[nums[right++] + <span class="hljs-number">50</span>]++;<br>            tmp = x;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">101</span>; i++) &#123;<br>                tmp = tmp - array[i];<br>                <span class="hljs-keyword">if</span> (tmp &lt;= <span class="hljs-number">0</span>) &#123;<br>                    ans[left] = <span class="hljs-built_in">min</span>(i - <span class="hljs-number">50</span>, <span class="hljs-number">0</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-maximum-number-of-occurrences-of-a-substring</title>
    <link href="/2024/10/02/Leetcode-maximum-number-of-occurrences-of-a-substring/"/>
    <url>/2024/10/02/Leetcode-maximum-number-of-occurrences-of-a-substring/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个字符串 <code>s</code> ，请你返回满足以下条件且出现次数最大的<strong>任意</strong> 子串的出现次数：</p><ul><li>子串中不同字母的数目必须小于等于 <code>maxLetters</code> 。</li><li>子串的长度必须大于等于 <code>minSize</code> 且小于等于<code>maxSize</code> 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">输入：s = <span class="hljs-string">&quot;aababcaab&quot;</span>, <span class="hljs-keyword">max</span>Letters = <span class="hljs-number">2</span>, <span class="hljs-keyword">min</span>Size = <span class="hljs-number">3</span>, <span class="hljs-keyword">max</span>Size = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">2</span><br>解释：子串 <span class="hljs-string">&quot;aab&quot;</span> 在原字符串中出现了 <span class="hljs-number">2</span> 次。<br>它满足所有的要求：<span class="hljs-number">2</span> 个不同的字母，长度为 <span class="hljs-number">3</span> （在 <span class="hljs-keyword">min</span>Size 和 <span class="hljs-keyword">max</span>Size 范围内）。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">输入：s = <span class="hljs-string">&quot;aaaa&quot;</span>, <span class="hljs-keyword">max</span>Letters = <span class="hljs-number">1</span>, <span class="hljs-keyword">min</span>Size = <span class="hljs-number">3</span>, <span class="hljs-keyword">max</span>Size = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br>解释：子串 <span class="hljs-string">&quot;aaa&quot;</span> 在原字符串中出现了 <span class="hljs-number">2</span> 次，且它们有重叠部分。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf">输入：s = <span class="hljs-string">&quot;aabcabcab&quot;</span>, <span class="hljs-keyword">max</span>Letters = <span class="hljs-number">2</span>, <span class="hljs-keyword">min</span>Size = <span class="hljs-number">2</span>, <span class="hljs-keyword">max</span>Size = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf">输入：s = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-keyword">max</span>Letters = <span class="hljs-number">2</span>, <span class="hljs-keyword">min</span>Size = <span class="hljs-number">3</span>, <span class="hljs-keyword">max</span>Size = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>1 &lt;= maxLetters &lt;= 26</code></li><li><code>1 &lt;= minSize &lt;= maxSize &lt;= min(26, s.length)</code></li><li><code>s</code> 只包含小写英文字母。</li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>枚举长度为[minSize,maxSize]的滑动窗口，判断这些滑动窗口中的子字符串是否满足要求，满足就记录到哈希表中，分别使用一个string以及一个int记录出现次数最多的子字符串和出现次数。</p><p>但是进一步来说，我们只要进行长度为minSize的滑动窗口计算即可，长度更短的滑动窗口的答案一定是大于等于长度更长的滑动窗口的答案。因为长字符串出现了beta次时，短字符串也一定出现了beta次，但短字符串可能会有更多。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxFreq</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> maxLetters, <span class="hljs-type">int</span> minSize, <span class="hljs-type">int</span> maxSize)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">freqForK</span>(s, maxLetters, minSize);<br>    &#125;<br><br>    <span class="hljs-comment">// 计算固定长度为k的时候，满足条件的答案数量。</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">freqForK</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> maxLetters, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> alpha[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;, count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 字符出出现的次数，出现了多少种字符</span><br>        unordered_map&lt;string, <span class="hljs-type">int</span>&gt; map; <span class="hljs-comment">// 记录&lt;符合要求的子串, 出现次数&gt;</span><br>        string maxString = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">int</span> maxStringCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// 只记录出现次数最多的的字符串以及出现次数。</span><br>        <br>        <span class="hljs-keyword">while</span> (right &lt; k) &#123; <span class="hljs-comment">// 构造初始窗口</span><br>            count = count + (alpha[s[right] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>);<br>            alpha[s[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count &lt;= maxLetters) &#123; <span class="hljs-comment">// 如果符合条件，记录满足条件的子串以及出现的次数。</span><br>            maxString = s.<span class="hljs-built_in">substr</span>(left, right - left);<br>            maxStringCount = <span class="hljs-number">1</span>;<br>            map[maxString] = maxStringCount;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123; <span class="hljs-comment">// 读入-弹出-计算答案</span><br>            count = count - (alpha[s[left] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">1</span>);<br>            alpha[s[left++] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            count = count + (alpha[s[right] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>);<br>            alpha[s[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-keyword">if</span> (count &lt;= maxLetters) &#123;<br>                string tmpStr = s.<span class="hljs-built_in">substr</span>(left, right - left);<br>                map[tmpStr]++;<br>                <span class="hljs-keyword">if</span> (map[tmpStr] &gt; maxStringCount) &#123;<br>                    maxStringCount = map[tmpStr];<br>                    maxString = tmpStr;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxStringCount;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-maximum-points-you-can-obtain-from-cards</title>
    <link href="/2024/10/02/Leetcode-maximum-points-you-can-obtain-from-cards/"/>
    <url>/2024/10/02/Leetcode-maximum-points-you-can-obtain-from-cards/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>几张卡牌<strong>排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组<code>cardPoints</code> 给出。</p><p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿<code>k</code> 张卡牌。</p><p>你的点数就是你拿到手中的所有卡牌的点数之和。</p><p>给你一个整数数组 <code>cardPoints</code> 和整数<code>k</code>，请你返回可以获得的最大点数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cardPoints = [1,2,3,4,5,6,1], k = 3<br>输出：12<br>解释：第一次行动，不管拿哪张牌，你的点数总是<span class="hljs-number"> 1 </span>。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 12 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：cardPoints </span>=<span class="hljs-string"> [2,2,2], k = 2</span><br><span class="hljs-string">输出：4</span><br><span class="hljs-string">解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：cardPoints = <span class="hljs-string">[9,7,7,9,7,7,9]</span>, k = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">55</span><br>解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：cardPoints = [<span class="hljs-number">1,1000,1</span>], k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 <span class="hljs-number">1</span> 。 <br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：cardPoints = [<span class="hljs-number">1,79,80,1</span>,<span class="hljs-number">1,1,200,1</span>], k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">202</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= cardPoints.length &lt;= 10^5</code></li><li><code>1 &lt;= cardPoints[i] &lt;= 10^4</code></li><li><code>1 &lt;= k &lt;= cardPoints.length</code></li></ul><h2 id="题解">2 题解</h2><p><strong>思路：</strong></p><p>每次只能从头或者从尾取，说明最后会有中间一部分留下，转换思路，要求的就是剩余nums.size()- k的定长子数组最小和是多少。</p><p><strong>时间复杂的：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cardPoints, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = cardPoints.<span class="hljs-built_in">size</span>();<br>        k = n - k;<br>        <br>        <span class="hljs-comment">// 将题目转换成，从cardPoints中找到长度为k的子数组，但是值最小的结果。</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; k &amp;&amp; right &lt; n) &#123;<br>            sum = sum + cardPoints[right++];<br>        &#125;<br>        ans = sum;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            sum = sum - cardPoints[left++] + cardPoints[right++];<br>            ans = <span class="hljs-built_in">min</span>(ans, sum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(<span class="hljs-built_in">begin</span>(cardPoints), <span class="hljs-built_in">end</span>(cardPoints), <span class="hljs-number">0</span>) - ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-maximum-sum-of-almost-unique-subarray</title>
    <link href="/2024/10/02/Leetcode-maximum-sum-of-almost-unique-subarray/"/>
    <url>/2024/10/02/Leetcode-maximum-sum-of-almost-unique-subarray/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个整数数组 <code>nums</code> 和两个正整数 <code>m</code> 和<code>k</code> 。</p><p>请你返回 <code>nums</code> 中长度为 <code>k</code> 的<strong>几乎唯一</strong> 子数组的 <strong>最大和</strong>，如果不存在几乎唯一子数组，请你返回 <code>0</code> 。</p><p>如果 <code>nums</code> 的一个子数组有至少 <code>m</code>个互不相同的元素，我们称它是 <strong>几乎唯一</strong> 子数组。</p><p>子数组指的是一个数组中一段连续 <strong>非空</strong> 的元素序列。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[2,6,7,3,1,7]</span>, m = <span class="hljs-number">3</span>, k = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">18</span><br>解释：总共有 <span class="hljs-number">3</span> 个长度为 k = <span class="hljs-number">4</span> 的几乎唯一子数组。分别为 <span class="hljs-string">[2, 6, 7, 3]</span> ，<span class="hljs-string">[6, 7, 3, 1]</span> 和 <span class="hljs-string">[7, 3, 1, 7]</span> 。这些子数组中，和最大的是 <span class="hljs-string">[2, 6, 7, 3]</span> ，和为 <span class="hljs-number">18</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,9,9,2,4,5,4]</span>, m = 1, k = 3<br>输出：23<br>解释：总共有 5 个长度为 k = 3 的几乎唯一子数组。分别为 <span class="hljs-comment">[5, 9, 9]</span> ，<span class="hljs-comment">[9, 9, 2]</span> ，<span class="hljs-comment">[9, 2, 4]</span> ，<span class="hljs-comment">[2, 4, 5]</span> 和 <span class="hljs-comment">[4, 5, 4]</span> 。这些子数组中，和最大的是 <span class="hljs-comment">[5, 9, 9]</span> ，和为 23 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,1,2,1,2,1], m = 3, k = 3<br>输出：0<br>解释：输入数组中不存在长度为 k =<span class="hljs-number"> 3 </span>的子数组含有至少  m =<span class="hljs-number"> 3 </span>个互不相同元素的子数组。所以不存在几乎唯一子数组，最大和为<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li><li><code>1 &lt;= m &lt;= k &lt;= nums.length</code></li><li><code>1 &lt;= nums[i] &lt;= 10^9</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>使用sum记录滑动窗口的总和，map记录每种数字的出现次数，count记录有多少种数字。</p><p>先构造初始的窗口并计算答案，之后重复</p><ul><li>读入</li><li>弹出</li><li>计算答案</li></ul><p>但是需要注意的是，读入弹出的过程最好是一步步来。如果left和right指向的元素是同一个时，使用map直接判断个数，容易出错。比如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">count = count - (map[nums[left]] == <span class="hljs-number">1</span>) + (map[nums[right]] == <span class="hljs-number">0</span>); <span class="hljs-comment">// 当nums[left] === nums[right]时，并且map[nums[left]] = 1时，就会存在问题，count会被归零。</span><br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maxSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map; <span class="hljs-comment">// 记录&lt;数字，出现次数&gt;</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 已经存在多少种数字，因为map中可能会存在出现次数为0的情况，erase太麻烦了，直接用count记录更佳。</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (right &lt; k) &#123; <span class="hljs-comment">// 构造基础滑动窗口</span><br>            count = count + (map[nums[right]] == <span class="hljs-number">0</span>);<br>            sum = sum + nums[right];<br>            map[nums[right++]]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count &gt;= m) &#123; <span class="hljs-comment">// 计算答案</span><br>            ans = sum;;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            count = count - (map[nums[left]] == <span class="hljs-number">1</span>); <span class="hljs-comment">// 这部分的内容需要分两步走，因为nums[left]和nums[right]可能相同，每一次使用map[nums[xx]]判定是否等于0或1，就已经假定变化了。</span><br>            map[nums[left]]--;<br>            count = count + (map[nums[right]] == <span class="hljs-number">0</span>); <span class="hljs-comment">// 更新滑动窗口中的数值种类</span><br>            map[nums[right]]++; <span class="hljs-comment">// 更新每种数字的个数</span><br>        <br>            sum = sum - nums[left] + nums[right]; <span class="hljs-comment">// 更新滑动窗口的总和</span><br>            left++;<br>            right++;<br>            <span class="hljs-keyword">if</span> (count &gt;= m) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, sum);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-grumpy-bookstore-owner</title>
    <link href="/2024/10/02/Leetcode-grumpy-bookstore-owner/"/>
    <url>/2024/10/02/Leetcode-grumpy-bookstore-owner/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>有一个书店老板，他的书店开了 <code>n</code>分钟。每分钟都有一些顾客进入这家商店。给定一个长度为 <code>n</code>的整数数组 <code>customers</code> ，其中 <code>customers[i]</code>是在第 <code>i</code> 分钟开始时进入商店的顾客数量，所有这些顾客在第<code>i</code> 分钟结束后离开。</p><p>在某些分钟内，书店老板会生气。 如果书店老板在第 <code>i</code>分钟生气，那么 <code>grumpy[i] = 1</code>，否则<code>grumpy[i] = 0</code>。</p><p>当书店老板生气时，那一分钟的顾客就会不满意，若老板不生气则顾客是满意的。</p><p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续<code>minutes</code> 分钟不生气，但却只能使用一次。</p><p>请你返回 <em>这一天营业下来，最多有多少客户能够感到满意</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3<br>输出：16<br>解释：书店老板在最后<span class="hljs-number"> 3 </span>分钟保持冷静。<br>感到满意的最大客户数量 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 5 </span>= 16.<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：customers = <span class="hljs-comment">[1]</span>, grumpy = <span class="hljs-comment">[0]</span>, minutes = 1<br>输出：1<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == customers.length == grumpy.length</code></li><li><code>1 &lt;= minutes &lt;= n &lt;= 2 * 10^4</code></li><li><code>0 &lt;= customers[i] &lt;= 1000</code></li><li><code>grumpy[i] == 0 or 1</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>需要注意的是，不生气的时候是0，生气的时候是1。</p><p>先计算出所有不生气时候的基础答案是多少，接着将customers和grumpy对应相乘，根据定长滑动窗口进一步求出可以弥补的答案是多少，相加为最终答案。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSatisfied</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; customers, vector&lt;<span class="hljs-type">int</span>&gt;&amp; grumpy, <span class="hljs-type">int</span> minutes)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, n = customers.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 计算出所有本来就能够感到满意的客户。</span><br>            ans = ans + customers[i] * (!grumpy[i]); <span class="hljs-comment">// 这里需要将0和1取反，应该使用!而不是~,~是所有位全部取反。</span><br>            customers[i] = customers[i] * grumpy[i]; <span class="hljs-comment">// 更新customers为所有不会感觉满意的客户。</span><br>        &#125;<br>        <span class="hljs-comment">// 接下来变成找到定长为minutes的滑动窗口，目标数组是customers和grumpy对应相乘的结果，求出最大的结果。</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; minutes &amp;&amp; right &lt; n) &#123;<br>            count = count + customers[right++];<br>        &#125;<br>        res = count; <span class="hljs-comment">// 计算一次答案。</span><br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            count = count - customers[left++] + customers[right++];<br>            res = <span class="hljs-built_in">max</span>(res, count);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans + res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-defuse-the-bomb</title>
    <link href="/2024/10/02/Leetcode-defuse-the-bomb/"/>
    <url>/2024/10/02/Leetcode-defuse-the-bomb/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为<code>n</code> 的 <strong>循环</strong> 数组 <code>code</code>以及一个密钥 <code>k</code> 。</p><p>为了获得正确的密码，你需要替换掉每一个数字。所有数字会<strong>同时</strong> 被替换。</p><ul><li>如果 <code>k &gt; 0</code> ，将第 <code>i</code> 个数字用<strong>接下来</strong> <code>k</code> 个数字之和替换。</li><li>如果 <code>k &lt; 0</code> ，将第 <code>i</code> 个数字用<strong>之前</strong> <code>k</code> 个数字之和替换。</li><li>如果 <code>k == 0</code> ，将第 <code>i</code> 个数字用<code>0</code> 替换。</li></ul><p>由于 <code>code</code> 是循环的， <code>code[n-1]</code> 下一个元素是<code>code[0]</code> ，且 <code>code[0]</code> 前一个元素是<code>code[n-1]</code> 。</p><p>给你 <strong>循环</strong> 数组 <code>code</code> 和整数密钥<code>k</code> ，请你返回解密后的结果来拆除炸弹！</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：code = [5,7,1,4], k = 3<br>输出：[12,10,16,13]<br>解释：每个数字都被接下来 3 个数字之和替换。解密后的密码为 [7<span class="hljs-string">+1</span><span class="hljs-string">+4</span>, 1<span class="hljs-string">+4</span><span class="hljs-string">+5</span>, 4<span class="hljs-string">+5</span><span class="hljs-string">+7</span>, 5<span class="hljs-string">+7</span><span class="hljs-string">+1</span>]。注意到数组是循环连接的。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-tag">code</span> = <span class="hljs-selector-attr">[1,2,3,4]</span>, k = <span class="hljs-number">0</span><br>输出：<span class="hljs-selector-attr">[0,0,0,0]</span><br>解释：当 k 为 <span class="hljs-number">0</span> 时，所有数字都被 <span class="hljs-number">0</span> 替换。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：code = [2,4,9,3], k = <span class="hljs-string">-2</span><br>输出：[12,5,6,13]<br>解释：解密后的密码为 [3<span class="hljs-string">+9</span>, 2<span class="hljs-string">+3</span>, 4<span class="hljs-string">+2</span>, 9<span class="hljs-string">+4</span>] 。注意到数组是循环连接的。如果 k 是负数，那么和为 之前 的数字。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == code.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= code[i] &lt;= 100</code></li><li><code>-(n - 1) &lt;= k &lt;= n - 1</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><h3 id="思路">思路：</h3><p>一开始想比较麻烦的是需要处理k是大于0还是小于0，这需要找出对应下标，然后计算前k个元素的滑动窗口还是后k个元素的滑动窗口，需要分别处理。</p><p>其实只要计算k个元素的滑动窗口，根据k的大小，决定这个滑动窗口是哪个下标的结果即可。并且移动left和right时，注意是环形数组，需要取余操作。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">decrypt</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; code, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = code.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; <span class="hljs-built_in">abs</span>(k)) &#123; <span class="hljs-comment">// 计算出长度为k的滑动窗口值，k需要取绝对值。</span><br>            count = count + code[right++];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>            ans[(left - <span class="hljs-number">1</span> + n) % n] = count; <span class="hljs-comment">// 这里的移位操作可能越界，所以需要先右移n个单位</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans[right] = count;<br>        &#125; <span class="hljs-comment">// 计算一次答案，根据k的大小决定这个滑动窗口的答案是哪个元素的。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// 计算剩余n - 1个答案</span><br>            count = count - code[left++] + code[right++];<br>            left = left % n;<br>            right = right % n;<br>            <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>            ans[(left - <span class="hljs-number">1</span> + n) % n] = count;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans[right] = count;<br>            &#125; <span class="hljs-comment">// 计算一次答案，根据k的大小决定这个滑动窗口的答案是哪个元素的。</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-minimum-recolors-to-get-k-consecutive-black-blocks</title>
    <link href="/2024/10/01/Leetcode-minimum-recolors-to-get-k-consecutive-black-blocks/"/>
    <url>/2024/10/01/Leetcode-minimum-recolors-to-get-k-consecutive-black-blocks/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个长度为 <code>n</code> 下标从 <strong>0</strong> 开始的字符串<code>blocks</code> ，<code>blocks[i]</code> 要么是 <code>'W'</code>要么是 <code>'B'</code> ，表示第 <code>i</code> 块的颜色。字符<code>'W'</code> 和 <code>'B'</code> 分别表示白色和黑色。</p><p>给你一个整数 <code>k</code> ，表示想要 <strong>连续</strong>黑色块的数目。</p><p>每一次操作中，你可以选择一个白色块将它 <strong>涂成</strong>黑色块。</p><p>请你返回至少出现 <strong>一次</strong> 连续 <code>k</code> 个黑色块的<strong>最少</strong> 操作次数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：blocks = &quot;WBBWWBBWBW&quot;, k = 7<br>输出：3<br>解释：<br>一种得到<span class="hljs-number"> 7 </span>个连续黑色块的方法是把第<span class="hljs-number"> 0 </span>，3 和<span class="hljs-number"> 4 </span>个块涂成黑色。<br>得到 blocks = &quot;BBBBBBBWBW&quot; 。<br>可以证明无法用少于<span class="hljs-number"> 3 </span>次操作得到<span class="hljs-number"> 7 </span>个连续的黑块。<br>所以我们返回<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">输入：<span class="hljs-keyword">blocks </span>= <span class="hljs-string">&quot;WBWBBBW&quot;</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">0</span><br>解释：<br>不需要任何操作，因为已经有 <span class="hljs-number">2</span> 个连续的黑块。<br>所以我们返回 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == blocks.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>blocks[i]</code> 要么是 <code>'W'</code> ，要么是<code>'B'</code> 。</li><li><code>1 &lt;= k &lt;= n</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>计算每个长度为k的子字符串中包含的'W'个数。先构建最初始的滑动窗口，并计算答案，因为滑动窗口的长度题目限定小于字符串长度。后续过程重复：</p><ul><li>读入right，如果是'W'，增加计数</li><li>弹出left，如果是'W'，减少计数</li><li>计算答案</li></ul><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumRecolors</span><span class="hljs-params">(string blocks, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>, n = blocks.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">while</span> (right &lt; k) &#123;<br>            count = count + (blocks[right++] == <span class="hljs-string">&#x27;W&#x27;</span>);<br>        &#125;<br>        ans = count; <span class="hljs-comment">// 无条件计算一次答案。</span><br>        <span class="hljs-keyword">while</span>(right &lt; n) &#123;<br>            count = count - (blocks[left++] == <span class="hljs-string">&#x27;W&#x27;</span>) + (blocks[right++] == <span class="hljs-string">&#x27;W&#x27;</span>);<br>            ans = <span class="hljs-built_in">min</span>(ans, count);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-k-radius-subarray-averages</title>
    <link href="/2024/10/01/Leetcode-k-radius-subarray-averages/"/>
    <url>/2024/10/01/Leetcode-k-radius-subarray-averages/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code>，数组中有 <code>n</code> 个整数，另给你一个整数 <code>k</code> 。</p><p><strong>半径为 k 的子数组平均值</strong> 是指：<code>nums</code>中一个以下标 <code>i</code> 为 <strong>中心</strong> 且<strong>半径</strong> 为 <code>k</code>的子数组中所有元素的平均值，即下标在 <code>i - k</code> 和<code>i + k</code> 范围（<strong>含</strong> <code>i - k</code> 和<code>i + k</code>）内所有元素的平均值。如果在下标 <code>i</code>前或后不足 <code>k</code> 个元素，那么 <strong>半径为 k的子数组平均值</strong> 是 <code>-1</code> 。</p><p>构建并返回一个长度为 <code>n</code> 的数组 <code>avgs</code> ，其中<code>avgs[i]</code> 是以下标 <code>i</code> 为中心的子数组的<strong>半径为 k 的子数组平均值</strong> 。</p><p><code>x</code> 个元素的 <strong>平均值</strong> 是 <code>x</code>个元素相加之和除以 <code>x</code> ，此时使用截断式<strong>整数除法</strong> ，即需要去掉结果的小数部分。</p><ul><li>例如，四个元素 <code>2</code>、<code>3</code>、<code>1</code> 和<code>5</code> 的平均值是<code>(2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75</code>，截断后得到<code>2</code> 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [7,4,3,9,1,8,5,2,6], k = 3<br>输出：[-1,-1,-1,5,4,4,-1,-1,-1]<br>解释：<br>- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。<br>- 中心为下标<span class="hljs-number"> 3 </span>且半径为<span class="hljs-number"> 3 </span>的子数组的元素总和是：7 +<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 8 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 37 </span>。<br>  使用截断式 整数除法，avg[3] =<span class="hljs-number"> 37 </span>/<span class="hljs-number"> 7 </span>=<span class="hljs-number"> 5 </span>。<br>- 中心为下标<span class="hljs-number"> 4 </span>的子数组，avg[4] = (4 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 8 </span>+<span class="hljs-number"> 5 </span>+ 2) /<span class="hljs-number"> 7 </span>=<span class="hljs-number"> 4 </span>。<br>- 中心为下标<span class="hljs-number"> 5 </span>的子数组，avg[5] = (3 +<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 8 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 2 </span>+ 6) /<span class="hljs-number"> 7 </span>=<span class="hljs-number"> 4 </span>。<br>- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [100000], k = 0<br>输出：[100000]<br>解释：<br>- 中心为下标<span class="hljs-number"> 0 </span>且半径<span class="hljs-number"> 0 </span>的子数组的元素总和是：100000 。<br>  avg[0] =<span class="hljs-number"> 100000 </span>/<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 100000 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[8]</span>, k = 100000<br>输出：<span class="hljs-comment">[-1]</span><br>解释：<br>- avg<span class="hljs-comment">[0]</span> 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>0 &lt;= nums[i], k &lt;= 10^5</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>先将不可能存在半径k的节点全部设置为-1。</p><p>计算中心点在[k, n - 1 - k]内的所有总和，使用滑动窗口即可 。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getAverages</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k &amp;&amp; i &lt; n; i++) &#123; <span class="hljs-comment">// 先构造两边的-1。</span><br>            ans[i] = <span class="hljs-number">-1</span>;<br>            ans[n - <span class="hljs-number">1</span> - i] = <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, mid = k, right = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(right &lt; n &amp;&amp; right &lt; <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>) <span class="hljs-comment">// 构造初始的定长滑动窗口。</span><br>            count = count + nums[right++];<br>        <span class="hljs-keyword">if</span>(mid &lt; n - k) <span class="hljs-comment">// 结算答案，但是需要保证mid后面有k个位置不能被动。</span><br>            ans[mid++] = count / (<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span>(right &lt; n) &#123;<br>            count = count - nums[left++] + nums[right++];<br>            ans[mid++] = count / (<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold</title>
    <link href="/2024/10/01/Leetcode-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/"/>
    <url>/2024/10/01/Leetcode-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个整数数组 <code>arr</code> 和两个整数 <code>k</code> 和<code>threshold</code> 。</p><p>请你返回长度为 <code>k</code> 且平均值大于等于 <code>threshold</code>的子数组数目。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr = <span class="hljs-comment">[2,2,2,2,5,5,5,8]</span>, k = 3, threshold = 4<br>输出：3<br>解释：子数组 <span class="hljs-comment">[2,5,5]</span>,<span class="hljs-comment">[5,5,5]</span> 和 <span class="hljs-comment">[5,5,8]</span> 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5<br>输出：6<br>解释：前<span class="hljs-number"> 6 </span>个长度为<span class="hljs-number"> 3 </span>的子数组平均值都大于<span class="hljs-number"> 5 </span>。注意平均值不是整数。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= 10^4</code></li><li><code>1 &lt;= k &lt;= arr.length</code></li><li><code>0 &lt;= threshold &lt;= 10^4</code></li></ul><h2 id="题解">2 题解</h2><p><strong>思路：</strong></p><p>定长动态窗口，在构造了窗口之后，计算答案。接着重复：</p><ul><li>读入right</li><li>弹出left</li><li>计算答案</li></ul><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numOfSubarrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> threshold)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>, limit = threshold * k;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, n = arr.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">while</span> (right &lt; k) &#123;<br>            count = count + arr[right++];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count &gt;= limit) ans++;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            count = count - arr[left++] + arr[right++];<br>            <span class="hljs-keyword">if</span> (count &gt;= limit) ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-maximum-average-subarray-i</title>
    <link href="/2024/10/01/Leetcode-maximum-average-subarray-i/"/>
    <url>/2024/10/01/Leetcode-maximum-average-subarray-i/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个由 <code>n</code> 个元素组成的整数数组 <code>nums</code>和一个整数 <code>k</code> 。</p><p>请你找出平均数最大且 <strong>长度为 <code>k</code></strong>的连续子数组，并输出该最大平均数。</p><p>任何误差小于 <code>10-5</code> 的答案都将被视为正确答案。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,12,<span class="hljs-string">-5</span>,<span class="hljs-string">-6</span>,50,3], k = 4<br>输出：12.75<br>解释：最大平均数 (12<span class="hljs-string">-5</span><span class="hljs-string">-6</span><span class="hljs-string">+50</span>)/4 = 51/4 = 12.75<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">5</span>], k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">5.00000</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= k &lt;= n &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li></ul><h2 id="题解">2 题解</h2><p><strong>思路：</strong></p><p>定长滑动窗口题目，构造好初始窗口后，计算答案。接着重复</p><ul><li>读取right</li><li>弹出left</li><li>计算答案</li></ul><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMaxAverage</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">double</span> ans = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">while</span> (right &lt; k) &#123;<br>            count = count + nums[right++];<br>        &#125;<br>        ans = count;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            count = count - nums[left++] + nums[right++] ;<br>            ans = <span class="hljs-built_in">max</span>(ans, count);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans / k;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-maximum-number-of-vowels-in-a-substring-of-given-length</title>
    <link href="/2024/10/01/Leetcode-maximum-number-of-vowels-in-a-substring-of-given-length/"/>
    <url>/2024/10/01/Leetcode-maximum-number-of-vowels-in-a-substring-of-given-length/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你字符串 <code>s</code> 和整数 <code>k</code> 。</p><p>请返回字符串 <code>s</code> 中长度为 <code>k</code>的单个子字符串中可能包含的最大元音字母数。</p><p>英文中的 <strong>元音字母</strong> 为（<code>a</code>,<code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>）。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abciiidef&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：子字符串 <span class="hljs-string">&quot;iii&quot;</span> 包含 <span class="hljs-number">3</span> 个元音字母。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：s = &quot;aeiou&quot;, k = 2<br>输出：2<br>解释：任意长度为<span class="hljs-number"> 2 </span>的子字符串都包含<span class="hljs-number"> 2 </span>个元音字母。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-string">&quot;lee&quot;</span>、<span class="hljs-string">&quot;eet&quot;</span> 和 <span class="hljs-string">&quot;ode&quot;</span> 都包含 <span class="hljs-number">2</span> 个元音字母。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;rhythms&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">0</span><br>解释：字符串 s 中不含任何元音字母。<br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;tryhard&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>s</code> 由小写英文字母组成</li><li><code>1 &lt;= k &lt;= s.length</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>定长滑动窗口题目，构造好初始窗口后，计算答案。接着重复</p><ul><li>读取right</li><li>弹出left</li><li>计算答案</li></ul><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxVowels</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, n = s.<span class="hljs-built_in">size</span>(), memo[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;, ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(right &lt; k) &#123;<br>            memo[s[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        ans = <span class="hljs-built_in">max</span>(ans, memo[<span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>] + memo[<span class="hljs-string">&#x27;e&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>] + memo[<span class="hljs-string">&#x27;i&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>] + memo[<span class="hljs-string">&#x27;o&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>] + memo[<span class="hljs-string">&#x27;u&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>        <span class="hljs-keyword">while</span>(right &lt; n) &#123;<br>            memo[s[left++] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            memo[s[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            ans = <span class="hljs-built_in">max</span>(ans, memo[<span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>] + memo[<span class="hljs-string">&#x27;e&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>] + memo[<span class="hljs-string">&#x27;i&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>] + memo[<span class="hljs-string">&#x27;o&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>] + memo[<span class="hljs-string">&#x27;u&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-count-complete-substring</title>
    <link href="/2024/10/01/Leetcode-count-complete-substring/"/>
    <url>/2024/10/01/Leetcode-count-complete-substring/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个字符串 <code>word</code> 和一个整数 <code>k</code> 。</p><p>如果 <code>word</code> 的一个子字符串 <code>s</code>满足以下条件，我们称它是 <strong>完全字符串：</strong></p><ul><li><code>s</code> 中每个字符 <strong>恰好</strong> 出现 <code>k</code>次。</li><li>相邻字符在字母表中的顺序 <strong>至多</strong> 相差 <code>2</code>。也就是说，<code>s</code> 中两个相邻字符 <code>c1</code> 和<code>c2</code> ，它们在字母表中的位置相差 <strong>至多</strong> 为<code>2</code> 。</li></ul><p>请你返回 <code>word</code> 中 <strong>完全</strong>子字符串的数目。</p><p><strong>子字符串</strong> 指的是一个字符串中一段连续<strong>非空</strong> 的字符序列。</p><p><strong>示例 1：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">word</span> = <span class="hljs-string">&quot;igigee&quot;</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：完全子字符串需要满足每个字符恰好出现 <span class="hljs-number">2</span> 次，且相邻字符相差至多为 <span class="hljs-number">2</span> ：igigee, igigee, igigee 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">word</span> = <span class="hljs-string">&quot;aaabbbccc&quot;</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br>解释：完全子字符串需要满足每个字符恰好出现 <span class="hljs-number">3</span> 次，且相邻字符相差至多为 <span class="hljs-number">2</span> ：aaabbbccc, aaabbbccc, aaabbbccc, aaabbbccc, aaabbbccc, aaabbbccc 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word.length &lt;= 10^5</code></li><li><code>word</code> 只包含小写英文字母。</li><li><code>1 &lt;= k &lt;= word.length</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>思路：</strong></p><p>先根据相邻字符相差不能超过2的性质，找出所有可能成为答案的子字符串。这里需要O(n)。</p><p>对每一个子字符串，进行枚举，假设出现了1种字符、2种字符...26种字符，每个字符都需要k个字母。所以我们就可以转换为定长的滑动窗口问题。这里需要O(26n)。</p><p><strong>时间复杂度：</strong>最终是O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countCompleteSubstrings</span><span class="hljs-params">(string word, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = word.<span class="hljs-built_in">size</span>(), ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; left &lt; n; left++) &#123; <span class="hljs-comment">// 枚举左端点</span><br>            <span class="hljs-type">int</span> right = left + <span class="hljs-number">1</span>; <span class="hljs-comment">// 右端点，起码要两个元素，所以是左端点的下一个元素。</span><br><br>            <span class="hljs-keyword">while</span> (right &lt; n &amp;&amp; <span class="hljs-built_in">abs</span>(word[right] - word[right - <span class="hljs-number">1</span>]) &lt;= <span class="hljs-number">2</span>) <span class="hljs-comment">// 尽可能的移动右端点，得到的结果是[left, right)</span><br>                right++;<br>            ans = ans + <span class="hljs-built_in">calAns</span>(word.<span class="hljs-built_in">substr</span>(left, right - left), k);<br>            left = right - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calAns</span><span class="hljs-params">(string word, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = word.<span class="hljs-built_in">size</span>(), res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">26</span> &amp;&amp; n &gt;= i * k; i++) &#123; <span class="hljs-comment">// 枚举可能出现的字符数量。定长动态窗口问题，长度为i * k。</span><br>            <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, memo[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 右端点和左端点可以从一处出发。</span><br><br>            <span class="hljs-keyword">while</span> (right &lt; i * k) <span class="hljs-comment">// 构建初始的滑动窗口,结束的时候，右指针指向的内容还没有记录。</span><br>                memo[word[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            res = res + <span class="hljs-built_in">check</span>(memo, k); <span class="hljs-comment">// 计算一次答案。</span><br>            <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>                memo[word[left++] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                memo[word[right++] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                res = res + <span class="hljs-built_in">check</span>(memo, k);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> array[], <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>            <span class="hljs-keyword">if</span> (array[i] &gt; <span class="hljs-number">0</span> &amp;&amp; array[i] != k)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="滑动窗口优化">2.2 滑动窗口+优化</h3><p><strong>思路：</strong></p><p>在2.1的基础上，不用check函数，而是使用一个哈希表，记录出现&lt;出现次数，字符种类&gt;的哈希表。这样检测是否满足条件，只要检查定长滑动窗口的情况下，<code>map[k] == i</code>即可。</p><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countCompleteSubstrings</span><span class="hljs-params">(string word, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = word.<span class="hljs-built_in">size</span>(), ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; left &lt; n; left++) &#123; <span class="hljs-comment">// 枚举左端点</span><br>            <span class="hljs-type">int</span> right = left + <span class="hljs-number">1</span>; <span class="hljs-comment">// 右端点，起码要两个元素，所以是左端点的下一个元素。</span><br><br>            <span class="hljs-keyword">while</span> (right &lt; n &amp;&amp; <span class="hljs-built_in">abs</span>(word[right] - word[right - <span class="hljs-number">1</span>]) &lt;= <span class="hljs-number">2</span>) <span class="hljs-comment">// 尽可能的移动右端点，得到的结果是[left, right)</span><br>                right++;<br>            ans = ans + <span class="hljs-built_in">calAns</span>(word.<span class="hljs-built_in">substr</span>(left, right - left), k);<br>            left = right - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calAns</span><span class="hljs-params">(string word, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = word.<span class="hljs-built_in">size</span>(), res = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map; <span class="hljs-comment">// 记录&lt;出现次数, 字符种类数&gt;</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">26</span> &amp;&amp; n &gt;= i * k; i++) &#123; <span class="hljs-comment">// 枚举可能出现的字符数量。定长动态窗口问题，长度为i * k。</span><br>            <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, memo[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 右端点和左端点可以从一处出发。</span><br><br>            <span class="hljs-keyword">while</span> (right &lt; i * k) &#123; <span class="hljs-comment">// 构建初始的滑动窗口,结束的时候，右指针指向的内容还没有记录。</span><br>                memo[word[right] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                map[memo[word[right] - <span class="hljs-string">&#x27;a&#x27;</span>]]++;<br>                right++;<br>            &#125;<br>            res = res + (map[k] == i); <span class="hljs-comment">// 计算一次答案。</span><br>            <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>                map[memo[word[left] - <span class="hljs-string">&#x27;a&#x27;</span>]]--;<br>                memo[word[left] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                memo[word[right] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                map[memo[word[right] - <span class="hljs-string">&#x27;a&#x27;</span>]]++;<br>                left++;<br>                right++;<br>                res = res + (map[k] == i); <span class="hljs-comment">// 计算一次答案。</span><br>            &#125;<br>            map.<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-longest-even-odd-subarray-with-threshold</title>
    <link href="/2024/10/01/Leetcode-longest-even-odd-subarray-with-threshold/"/>
    <url>/2024/10/01/Leetcode-longest-even-odd-subarray-with-threshold/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code>和一个整数 <code>threshold</code> 。</p><p>请你从 <code>nums</code> 的子数组中找出以下标 <code>l</code>开头、下标 <code>r</code> 结尾<code>(0 &lt;= l &lt;= r &lt; nums.length)</code> 且满足以下条件的<strong>最长子数组</strong> ：</p><ul><li><code>nums[l] % 2 == 0</code></li><li>对于范围 <code>[l, r - 1]</code> 内的所有下标 <code>i</code>，<code>nums[i] % 2 != nums[i + 1] % 2</code></li><li>对于范围 <code>[l, r]</code> 内的所有下标 <code>i</code>，<code>nums[i] &lt;= threshold</code></li></ul><p>以整数形式返回满足题目要求的最长子数组的长度。</p><p><strong>注意：子数组</strong> 是数组中的一个连续非空元素序列。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [3,2,5,4], threshold = 5<br>输出：3<br>解释：在这个示例中，我们选择从 l =<span class="hljs-number"> 1 </span>开始、到 r =<span class="hljs-number"> 3 </span>结束的子数组 =&gt; [2,5,4] ，满足上述条件。<br>因此，答案就是这个子数组的长度<span class="hljs-number"> 3 </span>。可以证明<span class="hljs-number"> 3 </span>是满足题目要求的最大长度。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2], threshold = 2<br>输出：1<br>解释：<br>在这个示例中，我们选择从 l =<span class="hljs-number"> 1 </span>开始、到 r =<span class="hljs-number"> 1 </span>结束的子数组 =&gt; [2] 。<br>该子数组满足上述全部条件。可以证明<span class="hljs-number"> 1 </span>是满足题目要求的最大长度。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,4,5], threshold = 4<br>输出：3<br>解释：<br>在这个示例中，我们选择从 l =<span class="hljs-number"> 0 </span>开始、到 r =<span class="hljs-number"> 2 </span>结束的子数组 =&gt; [2,3,4] 。 <br>该子数组满足上述全部条件。<br>因此，答案就是这个子数组的长度<span class="hljs-number"> 3 </span>。可以证明<span class="hljs-number"> 3 </span>是满足题目要求的最大长度。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li><li><code>1 &lt;= threshold &lt;= 100</code></li></ul><h2 id="题解">2 题解</h2><h3 id="滑动窗口">2.1 滑动窗口</h3><p><strong>解法：</strong></p><p>枚举左端点，需要是偶数并且不超过threshold。</p><p>在符合条件的情况下不断移动右指针，当不符合条件，即可计算一次答案。</p><p><strong>时间复杂度：</strong>虽然是双层循环，但是left和right加在一起也只会执行n次，所以时间复杂度是O(n)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestAlternatingSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> threshold)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; left &lt; n; left++) &#123; <span class="hljs-comment">// 枚举左下标</span><br>            <span class="hljs-keyword">if</span> (nums[left] &gt; threshold || nums[left] % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 不能以这个元素开头</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> right = left + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (right &lt; n &amp;&amp; nums[right - <span class="hljs-number">1</span>] % <span class="hljs-number">2</span> != nums[right] % <span class="hljs-number">2</span> &amp;&amp; nums[right] &lt;= threshold) &#123; <span class="hljs-comment">// 移动右指针，找出满足条件的最大范围</span><br>                right++;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left); <span class="hljs-comment">// 在不满足条件的时候计算答案。</span><br>            left = right - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-3sum</title>
    <link href="/2024/10/01/Leetcode-3sum/"/>
    <url>/2024/10/01/Leetcode-3sum/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组<code>[nums[i], nums[j], nums[k]]</code> 满足<code>i != j</code>、<code>i != k</code> 且 <code>j != k</code>，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code>。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-1,0,1,2,-1,-4]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-1,-1,2]</span>,<span class="hljs-comment">[-1,0,1]</span>]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = (-1) + 0 + 1 = 0 。<br>nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[4]</span> = 0 + 1 + (-1) = 0 。<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 <span class="hljs-comment">[-1,0,1]</span> 和 <span class="hljs-comment">[-1,-1,2]</span> 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0,1,1]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：唯一可能的三元组和不为 0 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[0,0,0]]</span><br>解释：唯一可能的三元组和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li></ul><h2 id="题解">2 题解</h2><h3 id="逆向双指针">2.1 逆向双指针</h3><p><strong>思路：</strong></p><p>对原始数组进行升序排序。</p><p>外层对数组进行遍历，在该元素下标之后的范围内进行逆向双指针，等价于两数之和的问题。</p><p>需要注意的是，为了避免出现重复结果，所以在遍历外层遍历或者内层逆向双指针遍历的过程之中，需要跳过重复的数字。</p><p><strong>时间复杂度：</strong>外层遍历元素是O(n)，内层逆向双指针是O(n)，所以最终结果是O(n^2)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">begin</span>(nums), <span class="hljs-built_in">end</span>(nums), [](<span class="hljs-type">int</span> &amp;challenger, <span class="hljs-type">int</span> &amp;challengee) &#123;<br>            <span class="hljs-keyword">return</span> challengee &gt; challenger;<br>        &#125;); <span class="hljs-comment">// 从小到大排序</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[left + <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 最小的三个数字之和都已经大于0，后面不会存在答案。</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[right - <span class="hljs-number">1</span>] + nums[right] &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 最大的三个数字之和都已经小于0，后面不会存在答案。</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i]) &#123; <span class="hljs-comment">// 跳过重复的数字，这只会造成重复结果。</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 移动左指针，扩大结果。</span><br>                    left++;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 移动右指针，减小结果。</span><br>                    right--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    vector&lt;<span class="hljs-type">int</span>&gt; res = &#123;nums[i], nums[left], nums[right]&#125;;<br>                    ans.<span class="hljs-built_in">push_back</span>(res);<br>                    left++;<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left - <span class="hljs-number">1</span>] == nums[left]) left++; <span class="hljs-comment">// 跳过相同的数字，这只会造成重复结果。</span><br>                    right--;<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="hljs-number">1</span>]) right--; <span class="hljs-comment">// 跳过相同的数字，这只会造成重复结果。</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>逆向双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-two-sum</title>
    <link href="/2024/10/01/Leetcode-two-sum/"/>
    <url>/2024/10/01/Leetcode-two-sum/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述">1 题目描述</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值<code>target</code>，请你在该数组中找出 <strong>和为目标值</strong><em><code>target</code></em> 的那 <strong>两个</strong>整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 10^4</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li><li><code>-10^9 &lt;= target &lt;= 10^9</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong>你可以想出一个时间复杂度小于<code>O(n^2)</code> 的算法吗？</p><h2 id="题解">2 题解</h2><h3 id="暴力解法">2.1 暴力解法</h3><p><strong>思路：</strong></p><p>进行双重for循环，在两个指针不重复的前提下计算两个元素之和是否满足条件。</p><p><strong>时间复杂度：</strong>O(n^2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (i != j &amp;&amp; nums[i] + nums[j] == target) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123;i, j&#125;;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="逆向双指针">2.2 逆向双指针</h3><p><strong>思路</strong>：</p><p>创建下标数组，在不破坏原始数组的前提下，对下标数组的内容进行升序排序。</p><p>对下标数组创建左右指针，根据左右指针指向的下标在原始数组中取出对应元素。</p><ul><li>求和后大于target左移右指针</li><li>求和后小于target右移左指针</li><li>求和后等于target返回结果</li></ul><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; index = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">iota</span>(<span class="hljs-built_in">begin</span>(index), <span class="hljs-built_in">end</span>(index), <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">begin</span>(index), <span class="hljs-built_in">end</span>(index), [nums](<span class="hljs-type">int</span> &amp;challenger, <span class="hljs-type">int</span> &amp;challengee) &#123;<br>            <span class="hljs-keyword">return</span> nums[challengee] &gt; nums[challenger];<br>        &#125;); <span class="hljs-comment">// 进行从小到大的排序,注意：不破坏原始的vector。</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (nums[index[left]] + nums[index[right]] &gt; target) &#123;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[index[left]] + nums[index[right]] &lt; target) &#123;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123;index[left], index[right]&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123;index[left], index[right]&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="哈希表">2.3 哈希表</h3><p><strong>解法：</strong></p><p>创建哈希表，记录元素值和下标的映射关系。</p><p>遍历数组的过程中，查看哈希表中是否存在和当前遍历元素相加等于target的键。</p><ul><li>存在，那就返回结果</li><li>不存在，将当前的元素值和下标记录到哈希表中</li></ul><p><strong>时间复杂度：</strong>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map; <span class="hljs-comment">// 映射&lt;num, index&gt;的关系</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">find</span>(target - nums[i]) != <span class="hljs-built_in">end</span>(map)) &#123; <span class="hljs-comment">// 找出target-nums[i]的元素是否记录在哈希表中。</span><br>                <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123;map[target - nums[i]], i&#125;;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(nums[i], i));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123; <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>逆向双指针</tag>
      
      <tag>暴力</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的常见数据结构</title>
    <link href="/2024/09/29/C++%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/09/29/C++%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>使用下述数据结构时，需要的头文件如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="数组">1 数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化:两种构造方法</span><br><span class="hljs-comment"> * 增:</span><br><span class="hljs-comment"> * 删:</span><br><span class="hljs-comment"> * 查:[]、begin、end</span><br><span class="hljs-comment"> * 改:赋值覆盖</span><br><span class="hljs-comment"> * 清空:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-type">int</span> array1[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;; <span class="hljs-comment">// 构造数值型数组的第一种方式。</span><br>    <span class="hljs-type">int</span> array2[n] = &#123;&#125;; <span class="hljs-comment">// 构造数值型数组的第二种方式，全部元素都是0。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        array2[i] = i;<br>    &#125;<br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;hello,world&quot;</span>; <span class="hljs-comment">// 构造字符型数组的第一种方式,自带\0。</span><br>    <span class="hljs-type">char</span> str2[n] = &#123;&#125;; <span class="hljs-comment">// 构造字符型数组的第二种方式,全部元素都是\0。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        str2[i] = <span class="hljs-string">&#x27;a&#x27;</span> + i;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 遍历数组的第一种方式,使用数组的总大小除以数组首个元素的大小就能得到数组的总长度</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(array1) / <span class="hljs-built_in">sizeof</span>(array1[<span class="hljs-number">0</span>]); i++) &#123;<br>        std::cout &lt;&lt; array1[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 遍历数组的第二种方式,使用增强for循环的方式。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> array: array2) &#123;<br>        std::cout &lt;&lt; array &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 遍历数组的第三种方式，使用end和std::begin函数，求出容器的长度。(注意，这种方式只能够用在静态数组上，即一开始就长度已经定死的，不适用变量定义的。)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> *ite = std::<span class="hljs-built_in">begin</span>(array1); ite != std::<span class="hljs-built_in">end</span>(array1); ite++) &#123;<br>        std::cout &lt;&lt; *ite &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 字符型数组遍历的第一种方式,直接用sizeof求出数组的长度进行遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(str2) / <span class="hljs-built_in">sizeof</span>(str2[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>; i++) &#123;<br>        std::cout &lt;&lt; str2[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 字符型数组遍历的第二种方式，使用end和std::begin求出容器的长度。(注意，这种方式只能够用在静态数组上，即一开始就长度已经定死的，不适用变量定义的。)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> *ite = std::<span class="hljs-built_in">begin</span>(str1); ite != std::<span class="hljs-built_in">end</span>(str1) - <span class="hljs-number">1</span>; ite++) &#123;<br>        std::cout &lt;&lt; *ite &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">1 2 3 4 5 6 7 8 9 10 <br>0 1 2 3 4 5 6 7 8 9 <br>1 2 3 4 5 6 7 8 9 10 <br>a b c d e f g h i <br>h e l l o , w o r l d <br></code></pre></td></tr></table></figure><h2 id="vector">2 vector</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">echo</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> count)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;以下为nums&quot;</span> &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot;中的数据&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 普通方式循环。</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;nums&quot;</span> &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;] = &quot;</span> &lt;&lt; nums[i] &lt;&lt; (i == nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;.\n&quot;</span> : <span class="hljs-string">&quot;, &quot;</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num: nums) &#123; <span class="hljs-comment">// 增强for循环。</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;nums&quot;</span> &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;] = &quot;</span> &lt;&lt; nums[i] &lt;&lt; (i == nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;.\n&quot;</span> : <span class="hljs-string">&quot;, &quot;</span>);<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator ite = std::<span class="hljs-built_in">begin</span>(nums); ite != std::<span class="hljs-built_in">end</span>(nums); ite++) &#123; <span class="hljs-comment">// 使用迭代器循环。</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;nums&quot;</span> &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> &lt;&lt; ite - std::<span class="hljs-built_in">begin</span>(nums) &lt;&lt; <span class="hljs-string">&quot;] = &quot;</span> &lt;&lt; *ite &lt;&lt; (ite == std::<span class="hljs-built_in">end</span>(nums) - <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;.\n&quot;</span> : <span class="hljs-string">&quot;, &quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化:三种构造方法</span><br><span class="hljs-comment"> * 增:insert、push_back、emplace_back</span><br><span class="hljs-comment"> * 删:erase</span><br><span class="hljs-comment"> * 查:[]、empty、size、back、begin、end</span><br><span class="hljs-comment"> * 改:赋值覆盖</span><br><span class="hljs-comment"> * 清空:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; nums1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">// 静态构造。</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; nums2 = std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">begin</span>(nums1), std::<span class="hljs-built_in">end</span>(nums1) - <span class="hljs-number">2</span>); <span class="hljs-comment">// 使用迭代器构造。</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; nums3 = std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">9</span>); <span class="hljs-comment">// 创建包含五个9的vector。</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; nums4;<br>    <span class="hljs-built_in">echo</span>(nums1, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">echo</span>(nums2, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">echo</span>(nums3, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">echo</span>(nums4, <span class="hljs-number">4</span>);<br>    nums<span class="hljs-number">4.</span><span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">begin</span>(nums4), <span class="hljs-number">2</span>);<br>    nums<span class="hljs-number">4.</span><span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">begin</span>(nums4), <span class="hljs-number">1</span>);<br>    nums<span class="hljs-number">4.</span><span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">begin</span>(nums4) + <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    nums<span class="hljs-number">4.</span><span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">end</span>(nums4), <span class="hljs-number">4</span>); <span class="hljs-comment">// 插入指定位置。</span><br>    nums<span class="hljs-number">4.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 插入结尾。</span><br>    nums<span class="hljs-number">4.</span><span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">6</span>); <span class="hljs-comment">// 插入结尾，速度更快。</span><br>    <span class="hljs-built_in">echo</span>(nums4, <span class="hljs-number">4</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;删除nums4中的元素4以后&quot;</span> &lt;&lt; std::endl;<br>    nums<span class="hljs-number">4.</span><span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">begin</span>(nums4) + <span class="hljs-number">3</span>); <span class="hljs-comment">// 删除元素。</span><br>    <span class="hljs-built_in">echo</span>(nums4, <span class="hljs-number">4</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;nums4的内容&quot;</span> &lt;&lt; (nums<span class="hljs-number">4.</span><span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;为空&quot;</span> : <span class="hljs-string">&quot;不为空&quot;</span>) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;nums4中包含了&quot;</span> &lt;&lt; nums<span class="hljs-number">4.</span><span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;个元素&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;nums4结尾的元素是&quot;</span> &lt;&lt; nums<span class="hljs-number">4.</span><span class="hljs-built_in">back</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">以下为nums1中的数据<br>nums1[0] = 1, nums1[1] = 2, nums1[2] = 3, nums1[3] = 4, nums1[4] = 5.<br>nums1[0] = 1, nums1[1] = 2, nums1[2] = 3, nums1[3] = 4, nums1[4] = 5.<br>nums1[0] = 1, nums1[1] = 2, nums1[2] = 3, nums1[3] = 4, nums1[4] = 5.<br>以下为nums2中的数据<br>nums2[0] = 1, nums2[1] = 2, nums2[2] = 3.<br>nums2[0] = 1, nums2[1] = 2, nums2[2] = 3.<br>nums2[0] = 1, nums2[1] = 2, nums2[2] = 3.<br>以下为nums3中的数据<br>nums3[0] = 9, nums3[1] = 9, nums3[2] = 9, nums3[3] = 9, nums3[4] = 9.<br>nums3[0] = 9, nums3[1] = 9, nums3[2] = 9, nums3[3] = 9, nums3[4] = 9.<br>nums3[0] = 9, nums3[1] = 9, nums3[2] = 9, nums3[3] = 9, nums3[4] = 9.<br>以下为nums4中的数据<br>以下为nums4中的数据<br>nums4[0] = 1, nums4[1] = 2, nums4[2] = 3, nums4[3] = 4, nums4[4] = 5, nums4[5] = 6.<br>nums4[0] = 1, nums4[1] = 2, nums4[2] = 3, nums4[3] = 4, nums4[4] = 5, nums4[5] = 6.<br>nums4[0] = 1, nums4[1] = 2, nums4[2] = 3, nums4[3] = 4, nums4[4] = 5, nums4[5] = 6.<br>删除nums4中的元素4以后<br>以下为nums4中的数据<br>nums4[0] = 1, nums4[1] = 2, nums4[2] = 3, nums4[3] = 5, nums4[4] = 6.<br>nums4[0] = 1, nums4[1] = 2, nums4[2] = 3, nums4[3] = 5, nums4[4] = 6.<br>nums4[0] = 1, nums4[1] = 2, nums4[2] = 3, nums4[3] = 5, nums4[4] = 6.<br>nums4的内容不为空<br>nums4中包含了5个元素<br>nums4结尾的元素是6<br></code></pre></td></tr></table></figure><h2 id="队列">3 队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化:一种构造方法</span><br><span class="hljs-comment"> * 增:push</span><br><span class="hljs-comment"> * 删:pop</span><br><span class="hljs-comment"> * 查:empty、size、front、back</span><br><span class="hljs-comment"> * 改:</span><br><span class="hljs-comment"> * 清空:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>);<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 将新元素压入队尾</span><br>    std::cout &lt;&lt; q.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 查看队列是否为空</span><br>        std::cout &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; q.<span class="hljs-built_in">back</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 查看队首以及队尾的元素</span><br>        q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 弹出队首元素</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">4<br>1 3<br>4 3<br>2 3<br>3 3<br></code></pre></td></tr></table></figure><h2 id="双端队列">4 双端队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化:一种构造方法</span><br><span class="hljs-comment"> * 增:push_front、push_back</span><br><span class="hljs-comment"> * 删:pop_front、pop_back</span><br><span class="hljs-comment"> * 查:empty、size、front、back</span><br><span class="hljs-comment"> * 改:</span><br><span class="hljs-comment"> * 清空:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::deque&lt;<span class="hljs-type">int</span>&gt; q;<br>    <br>    q.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 向队首插入元素</span><br>    q.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">4</span>);<br>    <br>    q.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 向队尾插入元素</span><br>    q.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    <br>    std::cout &lt;&lt; q.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 给出双端队列的长度</span><br>    <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 判断双端队列是否为空</span><br>        std::cout &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; q.<span class="hljs-built_in">back</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 查询双端队列的队首和队尾元素</span><br><br>        q.<span class="hljs-built_in">pop_front</span>(); <span class="hljs-comment">// 弹出双端队列的指定端。</span><br>        q.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">4<br>4 2<br>1 3<br></code></pre></td></tr></table></figure><h2 id="优先队列堆">5 优先队列（堆）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化:一种构造方法</span><br><span class="hljs-comment"> * 增:push</span><br><span class="hljs-comment"> * 删:pop</span><br><span class="hljs-comment"> * 查:empty、size、top</span><br><span class="hljs-comment"> * 改:</span><br><span class="hljs-comment"> * 清空:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>&gt; max_heap; <span class="hljs-comment">// 构建优先队列。</span><br>    max_heap.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 往优先队列中插入内容，同时会自动排序，默认是大顶堆。</span><br>    max_heap.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>);<br>    max_heap.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    max_heap.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>    std::cout &lt;&lt; max_heap.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 查看堆中有多少个元素。</span><br>    <span class="hljs-keyword">while</span>(!max_heap.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 查看堆是否为空。</span><br>        std::cout &lt;&lt; max_heap.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 查看堆顶的元素。</span><br>        max_heap.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 弹出堆顶元素。</span><br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-type">bool</span>(*)(<span class="hljs-type">int</span> &amp;, <span class="hljs-type">int</span> &amp;)&gt; <span class="hljs-built_in">min_heap</span>([](<span class="hljs-type">int</span> &amp;challenger, <span class="hljs-type">int</span> &amp;challengee)&#123;<br>        <span class="hljs-keyword">return</span> challenger &gt; challengee;<br>    &#125;); <span class="hljs-comment">// 构建最小堆,优先队列的比较函数和普通的sort函数中逻辑是不同的，优先队列的比较函数返回true时代表challenger的优先级更低，需要排到后面的位置。普通sort函数中返回true表示challenger应当和challengee交换位置。</span><br>    min_heap.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    min_heap.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    min_heap.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>    min_heap.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">while</span>(!min_heap.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; min_heap.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        min_heap.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">4<br>4 3 2 1 <br>1 2 3 4<br></code></pre></td></tr></table></figure><h2 id="栈">6 栈</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化:一种构造方法</span><br><span class="hljs-comment"> * 增:push</span><br><span class="hljs-comment"> * 删:pop</span><br><span class="hljs-comment"> * 查:empty、size、top</span><br><span class="hljs-comment"> * 改:</span><br><span class="hljs-comment"> * 清空:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; stack; <span class="hljs-comment">// 初始化栈。</span><br>    stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>);<br>    stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>    stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 压栈。</span><br>    std::cout &lt;&lt; stack.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 查看栈中有多少个元素。</span><br>    <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 判断栈是否为空。</span><br>        std::cout &lt;&lt; stack.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 查看栈顶元素。</span><br>        stack.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 出栈。</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">4<br>2<br>3<br>4<br>1<br></code></pre></td></tr></table></figure><h2 id="unordered_map">7 unordered_map</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化:一种构造方法</span><br><span class="hljs-comment"> * 增:insert、[]</span><br><span class="hljs-comment"> * 删:erase</span><br><span class="hljs-comment"> * 查:[]、empty、size、find、begin、end</span><br><span class="hljs-comment"> * 改:赋值覆盖</span><br><span class="hljs-comment"> * 清空:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hashmap; <span class="hljs-comment">// 初始化。</span><br>    hashmap.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// 插入键值对元素方式一。</span><br>    hashmap[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>; <span class="hljs-comment">// 插入键值对方式二。</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;总长度为:&quot;</span> &lt;&lt; hashmap.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// hashmap的长度。</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;是否为空为:&quot;</span> &lt;&lt; hashmap.<span class="hljs-built_in">empty</span>() &lt;&lt; std::endl; <span class="hljs-comment">// hashmap是否为空。</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ite = std::<span class="hljs-built_in">begin</span>(hashmap); ite != std::<span class="hljs-built_in">end</span>(hashmap); ++ite) &#123; <span class="hljs-comment">// 遍历哈希表。</span><br>        std::cout &lt;&lt; ite-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ite-&gt;second &lt;&lt; std::endl; <span class="hljs-comment">// 分别获取当前键值对中的key和value。</span><br>        std::cout &lt;&lt; (hashmap.<span class="hljs-built_in">find</span>(ite-&gt;first) != std::<span class="hljs-built_in">end</span>(hashmap)) &lt;&lt; std::endl; <span class="hljs-comment">// 根据key查询元素</span><br>    &#125;<br>    hashmap.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 删除key为1的键值对。</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;删除了键为1的内容以后，还剩下&quot;</span> &lt;&lt; hashmap.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;对元素&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">总长度为:2<br>是否为空为:0<br>2 2<br>1<br>1 1<br>1<br>删除了键为1的内容以后，还剩下1对元素<br></code></pre></td></tr></table></figure><h2 id="unordered_set">8 unordered_set</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化:一种构造方法</span><br><span class="hljs-comment"> * 增:insert</span><br><span class="hljs-comment"> * 删:erase</span><br><span class="hljs-comment"> * 查:empty、size、find、begin、end</span><br><span class="hljs-comment"> * 改:</span><br><span class="hljs-comment"> * 清空:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unordered_set&lt;<span class="hljs-type">int</span>&gt; hashset;<br>    hashset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);<br>    hashset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>);<br>    hashset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>    hashset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 插入内容</span><br>    std::cout &lt;&lt; hashset.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 获取元素个数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;是否为空为:&quot;</span> &lt;&lt; hashset.<span class="hljs-built_in">empty</span>() &lt;&lt; std::endl; <span class="hljs-comment">// hashmap是否为空。</span><br>    <span class="hljs-keyword">for</span>(std::unordered_set&lt;<span class="hljs-type">int</span>&gt;::iterator ite = std::<span class="hljs-built_in">begin</span>(hashset); ite != std::<span class="hljs-built_in">end</span>(hashset); ite++) &#123;<br>        std::cout &lt;&lt; (hashset.<span class="hljs-built_in">find</span>(*ite) != <span class="hljs-built_in">end</span>(hashset)) &lt;&lt; std::endl; <span class="hljs-comment">// 查询目标元素是否存在</span><br>        hashset.<span class="hljs-built_in">erase</span>(hashset.<span class="hljs-built_in">find</span>(*ite)); <span class="hljs-comment">// 删除目标元素</span><br>    &#125;<br>    std::cout &lt;&lt; hashset.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">4<br>1<br>3<br></code></pre></td></tr></table></figure><h2 id="bitset">9 bitset</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::bitset&lt;5&gt; <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    std::cout &lt;&lt; num &lt;&lt; std::endl;<br>    num.<span class="hljs-built_in">set</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 下标第i位变成1。</span><br>    std::cout &lt;&lt; num &lt;&lt; std::endl;<br>    num.<span class="hljs-built_in">set</span>();  <span class="hljs-comment">// 全部变为1</span><br>    std::cout &lt;&lt; num &lt;&lt; std::endl;<br>    num.<span class="hljs-built_in">reset</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 下标第i位复位。</span><br>    std::cout &lt;&lt; num &lt;&lt; std::endl;<br>    num.<span class="hljs-built_in">reset</span>();  <span class="hljs-comment">// 全体复位。</span><br>    std::cout &lt;&lt; num &lt;&lt; std::endl;<br>    std::cout &lt;&lt; num.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 该bitset的大小。</span><br>    num.<span class="hljs-built_in">set</span>(<span class="hljs-number">3</span>);<br>    std::cout &lt;&lt; num.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 有几个1。</span><br>    std::cout &lt;&lt; num.<span class="hljs-built_in">any</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 是否至少含有一个1吗。</span><br>    std::cout &lt;&lt; num.<span class="hljs-built_in">none</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 是否不含1。</span><br>    std::cout &lt;&lt; num.<span class="hljs-built_in">all</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 是否全部为1。</span><br>    std::cout &lt;&lt; num.<span class="hljs-built_in">test</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 下标为3的位置上是否是1。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">00001<br>00011<br>11111<br>11101<br>00000<br>5<br>1<br>1<br>0<br>0<br>1<br></code></pre></td></tr></table></figure><h2 id="string">10 string</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化:三种初始化方法</span><br><span class="hljs-comment"> * 增:</span><br><span class="hljs-comment"> * 删:erase（原地）</span><br><span class="hljs-comment"> * 查:[]、find、substr、compare、size、regex_match</span><br><span class="hljs-comment"> * 改:replace(原地)、regex_replace(非原地)</span><br><span class="hljs-comment"> * 清空:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>std::string str = <span class="hljs-string">&quot;hello,world!&quot;</span>; <span class="hljs-comment">// 初始化方式1</span><br>std::string str1 = std::<span class="hljs-built_in">string</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// 初始化方式2</span><br>std::string str2 = str1; <span class="hljs-comment">// 初始化方式3</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;str1=&quot;</span> &lt;&lt; str1 &lt;&lt; <span class="hljs-string">&quot;,str2=&quot;</span> &lt;&lt; str2 &lt;&lt; std::endl;<br><br><span class="hljs-type">int</span> e_pos = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;e&#x27;</span>);<br><span class="hljs-type">int</span> a_pos = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;ahead&quot;</span>); <span class="hljs-comment">// 查询方法</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;字符串的内容为:&quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;e_pos:&quot;</span> &lt;&lt; e_pos &lt;&lt; <span class="hljs-string">&quot;，是否等于std::string::npos===&gt;&quot;</span> &lt;&lt; (e_pos == std::string::npos) &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;ahead_pos:&quot;</span> &lt;&lt; a_pos &lt;&lt; <span class="hljs-string">&quot;，是否等于std::string::npos===&gt;&quot;</span> &lt;&lt; (a_pos == std::string::npos) &lt;&lt; std::endl;<br><span class="hljs-type">int</span> erase_len = <span class="hljs-number">3</span>;<br>str.<span class="hljs-built_in">erase</span>(e_pos, erase_len); <span class="hljs-comment">// 删除包含起始点的多个字符。</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;str删除内容以后，字符串内容变为:&quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;截取出[3,6]范围内的子串内容为:&quot;</span> &lt;&lt; str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>, <span class="hljs-number">6</span> - <span class="hljs-number">3</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 截取子串</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;替换了[3,6]范围内的字串内容为&#x27;abcde&#x27;,结果为&quot;</span> &lt;&lt; str.<span class="hljs-built_in">replace</span>(<span class="hljs-number">3</span>, <span class="hljs-number">6</span> - <span class="hljs-number">3</span>, <span class="hljs-string">&quot;abcde&quot;</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 替换子串</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;比较字符串str和str1的大小&quot;</span> &lt;&lt; str.<span class="hljs-built_in">compare</span>(<span class="hljs-number">0</span>, str.<span class="hljs-built_in">size</span>(), str1) &lt;&lt; std::endl; <span class="hljs-comment">// 字符串比较</span><br><br>std::smatch result;<br><span class="hljs-function">std::regex <span class="hljs-title">pattern</span><span class="hljs-params">(<span class="hljs-string">&quot;(h|w)o.*&quot;</span>)</span></span>;<br><span class="hljs-built_in">regex_match</span>(str, result, pattern); <span class="hljs-comment">// 进行正则匹配,必须要整串字符都可以匹配上。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; result.<span class="hljs-built_in">size</span>(); i++) &#123;<br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;的内容是:&quot;</span> &lt;&lt; result[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>std::cout &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;替换以后的内容为:&quot;</span> &lt;&lt; <span class="hljs-built_in">regex_replace</span>(str, pattern, <span class="hljs-string">&quot;clean&quot;</span>) &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">str1=aaaaaaaaaa,str2=aaaaaaaaaa<br>字符串的内容为:hello,world!<br>e_pos:1，是否等于std::string::npos===&gt;0<br>ahead_pos:-1，是否等于std::string::npos===&gt;1<br>str删除内容以后，字符串内容变为:ho,world!<br>截取出[3,6]范围内的子串内容为:wor<br>替换了[3,6]范围内的字串内容为<span class="hljs-string">&#x27;abcde&#x27;</span>,结果为ho,abcdeld!<br>比较字符串str和str1的大小1<br>0的内容是:ho,abcdeld! 1的内容是:h<br>替换以后的内容为:clean<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Usage</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令grep详解</title>
    <link href="/2024/09/07/Linux%E5%91%BD%E4%BB%A4grep%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/09/07/Linux%E5%91%BD%E4%BB%A4grep%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="grep基本命令格式">1 grep基本命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep [options] pattern [input]<br></code></pre></td></tr></table></figure><p>这条命令的功能就是对<strong>输入源</strong>按照设定的<strong>正则表达式</strong>进行过滤，根据<strong>选项</strong>对结果进行强化，当一段内容已经找到一部分后，会立即从该位置接着重新进行过滤任务，也即前面已经匹配的内容是不再使用的。</p><h2 id="输入源">2 输入源</h2><p>输入源的情况共分为三种，分别是文件、管道符带来的输入、键盘带来的标准输入。为了进行后续测试，我预先创建了两个文件，内容如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> user1.txt <br>user1.txt<br>name: feng.<br>telephone number: 177****2269.<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> user2.txt <br>user2.txt<br>name: lijian.<br>qq: 123456789.<br></code></pre></td></tr></table></figure><h3 id="使用文件">2.1 使用文件</h3><p>grep可以同时指定<strong>任意多个文件</strong>作为输入源，以下是对两个预先准备好的文件执行grep的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ grep <span class="hljs-string">&#x27;1&#x27;</span> user1.txt user2.txt <span class="hljs-comment"># 对多个文件进行过滤，过滤条件很简单，只要目标行包含了&quot;1&quot;这个字符，就会被筛选出来。</span><br>user1.txt:user1.txt<br>user1.txt:telephone number: 177****2269.<br>user2.txt:qq: 123456789.<br></code></pre></td></tr></table></figure><p>若给定的输入源包含<strong>目录</strong>，此时就需要使用选项<code>-r</code>递归地在目录及其子目录下的所有文件中搜索。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ grep -r <span class="hljs-string">&#x27;1&#x27;</span> user1.txt user2.txt ../tmp <span class="hljs-comment"># 不仅在user1.txt和user2.txt两个文件进行过滤，还在tmp这个目录下进行了递归的过滤，所以从结果中可以发现，过滤结果是翻了一倍。</span><br>user1.txt:user1.txt<br>user1.txt:telephone number: 177****2269.<br>user2.txt:qq: 123456789.<br>../tmp/user2.txt:qq: 123456789.<br>../tmp/user1.txt:user1.txt<br>../tmp/user1.txt:telephone number: 177****2269.<br></code></pre></td></tr></table></figure><h3 id="使用管道符">2.2 使用管道符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> user1.txt user2.txt | grep <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-comment"># 通过cat命令读取这两个文件的内容，并以管道符的形式发送给grpe命令。我们可以发现，过滤以后的结果较2.1相比，少了来源文件的信息。</span><br>user1.txt<br>telephone number: 177****2269.<br>qq: 123456789.<br></code></pre></td></tr></table></figure><h3 id="使用标准输入">2.3 使用标准输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ grep <span class="hljs-string">&#x27;1&#x27;</span> - <span class="hljs-comment"># 当需要对键盘输入进行过滤时，只需要将输入源设置为&#x27;-&#x27;即可，若输入的内容符合正则表达式，会重新在界面上输出目标语句。</span><br>user1.txt<br>user1.txt<br>name: feng.<br>telephone number: 177****2269.<br>telephone number: 177****2269.<br></code></pre></td></tr></table></figure><h2 id="正则表达式">3 正则表达式</h2><p>因为以下的部分内容是拓展正则，所以建议使用正则时最好都加上选项<strong>-E</strong>，使用拓展正则的模式。</p><h3 id="锚点">3.1 锚点</h3><ul><li><strong>^word</strong>：匹配的内容必须以word开头。</li><li><strong>word$</strong>：匹配的内容必须以$结尾。</li></ul><h3 id="字符类">3.2 字符类</h3><ul><li><p><strong>[list]</strong>：将list字符串中的每个字符看作是单个元素，进而得到一个集合，匹配的内容必须包含集合中的某个元素。</p></li><li><p><strong>[n1-n2]</strong>：将一个范围内的同类型字符组合为list，例如[0-9]、[a-z]、[A-Z]。还可以和list混用，例如[abc0-2]代表abc012组成的集合。</p></li><li><p><strong>[^list]</strong>：对于集合取反。</p></li><li><p><strong>\w</strong>:英文字母和数字组成的集合。</p></li><li><p><strong>\W</strong>:对<strong>\w</strong>取反以后的结果。</p></li><li><p><strong>(|)</strong>：相较于<strong>[]</strong>使用单个字符作为元素，<strong>()</strong>使用字符串作为元素，进而组成集合，划分元素的方法是使用符合，这里匹配到的结果可以作为<strong>捕获</strong>，在后续根据<strong>\number</strong>取出第number个捕获的结果进行复用。</p></li><li><p>为了匹配一些特殊字符，<strong>[]</strong>中还提供了一些特殊的写法。</p><ul><li><p><strong>[:alnum:]</strong>：文字数字，这里的文字还包含了中文。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> user1.txt <br>user1.txt<br>name: feng.<br>telephone number: 177****2269.<br><br>西江月·世事一场大梦<br>    作者：苏轼<br>世事一场大梦，人生几度新〔秋〕凉？夜来风叶已鸣廊，看取眉头鬓上。<br>酒贱常愁客少，月明多被云妨。中秋谁与共孤光，把盏凄然北望。<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> user1.txt | grep -E <span class="hljs-string">&#x27;[[:alnum:]]*&#x27;</span><br>user1.txt<br>name: feng.<br>telephone number: 177****2269.<br><br>西江月·世事一场大梦<br>    作者：苏轼<br>世事一场大梦，人生几度新〔秋〕凉？夜来风叶已鸣廊，看取眉头鬓上。<br>酒贱常愁客少，月明多被云妨。中秋谁与共孤光，把盏凄然北望。<br></code></pre></td></tr></table></figure></li><li><p><strong>[:alpha:]</strong>：文字，这里的文字也包含中文。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> user1.txt <br>user1.txt<br>name: feng.<br>telephone number: 177****2269.<br><br>西江月·世事一场大梦<br>    作者：苏轼<br>世事一场大梦，人生几度新〔秋〕凉？夜来风叶已鸣廊，看取眉头鬓上。<br>酒贱常愁客少，月明多被云妨。中秋谁与共孤光，把盏凄然北望。<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> user1.txt | grep -E <span class="hljs-string">&#x27;[[:alpha:]]*&#x27;</span><br>user1.txt<br>name: feng.<br>telephone number: 177****2269.<br><br>西江月·世事一场大梦<br>    作者：苏轼<br>世事一场大梦，人生几度新〔秋〕凉？夜来风叶已鸣廊，看取眉头鬓上。<br>酒贱常愁客少，月明多被云妨。中秋谁与共孤光，把盏凄然北望。<br></code></pre></td></tr></table></figure></li><li><p><strong>[:punct:]</strong>：标点符号</p></li><li><p><strong>[:digit:]</strong>：数字</p></li><li><p><strong>[:xdigit:]</strong>：十六进制数字（0-9，a-f，A-F）</p></li><li><p><strong>[:graph:]</strong>：非空字符（不包括空格，不包括控制字符）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> user3.txt <br>namelibai<br>age 13<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ grep -E <span class="hljs-string">&#x27;[[:graph:]]*[[:cntrl:]][[:graph:]]*&#x27;</span> user3.txt -x <span class="hljs-comment"># 中间的制表符用cntrl匹配了，说明两边的graph，不仅不带空格，还不带控制字符。</span><br>namelibai<br></code></pre></td></tr></table></figure></li><li><p><strong>[:print:]</strong>：非空字符（包括空格，不包括控制字符）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> user3.txt <br>namelibai<br>age 13<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ grep -E <span class="hljs-string">&#x27;[[:print:]]*&#x27;</span> user3.txt -x <span class="hljs-comment"># 整行都匹配上的情况只有第二行，也就是集合中有空格，但是没有控制字符。</span><br>age 13<br></code></pre></td></tr></table></figure></li><li><p><strong>[:space:]</strong>：所有空白字符（换行，空格，制表符）</p></li><li><p><strong>[:lower:]</strong>：小写字符</p></li><li><p><strong>[:upper:]</strong>：大写字符</p></li><li><p><strong>[:cntrl:]</strong>：控制字符</p></li></ul></li></ul><h3 id="通配符">3.3 通配符</h3><ul><li><strong>.</strong>：用于匹配任意的单个字符</li><li><strong>\&lt;hell</strong>：用于匹配hello开头的单词。</li><li><strong>llo\&gt;</strong>：用于匹配llo结尾的单词。</li></ul><h3 id="量词">3.4 量词</h3><ul><li><strong>{N}</strong>：匹配前一个集合N次。集合的情况包含单个字符，使用<strong>[]</strong>组成以单个字符为元素的集合，使用<strong>()</strong>组成的以字符串为元素的集合。</li><li><strong>{N,M}</strong>：匹配前一个集合，至少N次，至多M次。</li><li><strong>{N,}</strong>：匹配前一个集合，至少N次，不设置上限。</li><li><strong>?</strong>：匹配前一个集合，零次或一次。</li><li><strong>*</strong>：匹配前一个集合，零次或多次。</li><li><strong>+</strong>：匹配前一个集合，一次或多次。</li></ul><h2 id="选项">4 选项</h2><p>接下来将会对<strong>/etc/hosts</strong>中的内容进行过滤，内容如下，后续不再赘述：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts<br>127.0.0.1localhost<br>127.0.1.1ubuntu<br>20.205.243.166  github.com<br><span class="hljs-comment"># The following lines are desirable for IPv6 capable hosts</span><br>::1     ip6-localhost ip6-loopback<br>fe00::0 ip6-localnet<br>ff00::0 ip6-mcastprefix<br>ff02::1 ip6-allnodes<br>ff02::2 ip6-allrouters<br></code></pre></td></tr></table></figure><ul><li><p><strong>-a</strong>或<strong>--text</strong>：不要忽略二进制的内容。</p></li><li><p><strong>-Anumber</strong>或<strong>--after-context=number</strong>：在查询到匹配行之后，顺势给出后number行的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;github&#x27;</span> -A 3<br>20.205.243.166  github.com<br><span class="hljs-comment"># The following lines are desirable for IPv6 capable hosts</span><br>::1     ip6-localhost ip6-loopback<br>fe00::0 ip6-localnet<br></code></pre></td></tr></table></figure></li><li><p><strong>-b</strong>或<strong>--byte-offset</strong>：查询到结果时，给出该行第一个字符在整个文件中的字符偏移量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;localhost&#x27;</span> -b<br>0:127.0.0.1localhost<br>123:::1     ip6-localhost ip6-loopback<br></code></pre></td></tr></table></figure></li><li><p><strong>-Bnumber</strong>或<strong>--before-context=number</strong>：查询到结果时，顺势给出前number行的内容，与-A相反。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;loopback&#x27;</span> -B 3<br>127.0.1.1ubuntu<br>20.205.243.166  github.com<br><span class="hljs-comment"># The following lines are desirable for IPv6 capable hosts</span><br>::1     ip6-localhost ip6-loopback<br></code></pre></td></tr></table></figure></li><li><p><strong>-c</strong>或<strong>--count</strong>：计算匹配成功的行数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;localhost&#x27;</span> -c<br>2<br></code></pre></td></tr></table></figure></li><li><p><strong>-Cnumber</strong>或<strong>--context=number</strong>：查询到结果时，顺势给出上下各number行的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;loopback&#x27;</span> -C 3<br>127.0.1.1ubuntu<br>20.205.243.166  github.com<br><span class="hljs-comment"># The following lines are desirable for IPv6 capable hosts</span><br>::1     ip6-localhost ip6-loopback<br>fe00::0 ip6-localnet<br>ff00::0 ip6-mcastprefix<br>ff02::1 ip6-allnodes<br></code></pre></td></tr></table></figure></li><li><p><strong>-d动作</strong>或<strong>--directories=动作</strong>：当指定要查找的是目录而非文件时，必须使用此参数，动作一般使用recurse。但是这一项不怎么使用，可以直接使用-r实现该效果。</p></li><li><p><strong>-e正则表达式</strong>或<strong>--regexp=正则表达式</strong>：指定字符串做为查找文件内容的样式。这个选项的主要作用是可以同时使用多个正则表达式做匹配，进而获取并集的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E -e <span class="hljs-string">&#x27;local&#x27;</span>  -e <span class="hljs-string">&#x27;1&#x27;</span><br>127.0.0.1localhost<br>127.0.1.1ubuntu<br>20.205.243.166  github.com<br>::1     ip6-localhost ip6-loopback<br>fe00::0 ip6-localnet<br>ff02::1 ip6-allnodes<br></code></pre></td></tr></table></figure></li><li><p><strong>-E</strong>或<strong>--extended-regexp</strong>：本次使用的正则表达式按照拓展正则进行解析。</p></li><li><p><strong>-f文件名字</strong>或<strong>--file=文件名字</strong>：指定规则文件，其内容含有一个或多个正则表达式样式，让grep查找符合条件的文件内容。注意，写到规则文件中的内容，并不需要单引号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> regul.txt <br><span class="hljs-built_in">local</span><br>1<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E -f regul.txt <br>127.0.0.1localhost<br>127.0.1.1ubuntu<br>20.205.243.166  github.com<br>::1     ip6-localhost ip6-loopback<br>fe00::0 ip6-localnet<br>ff02::1 ip6-allnodes<br></code></pre></td></tr></table></figure></li><li><p><strong>-F</strong>或<strong>--fixed-regexp</strong>：将匹配模式视为固定字符串的列表，而不当作正则表达式使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;u.*tu&#x27;</span> <span class="hljs-comment"># 直接使用这个正则表达式时是可以匹配成功的。</span><br>127.0.1.1ubuntu<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E -F <span class="hljs-string">&#x27;u.*tu&#x27;</span> <span class="hljs-comment"># 同时使用-E和-F存在冲突。</span><br>grep: conflicting matchers specified<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -F <span class="hljs-string">&#x27;u.*tu&#x27;</span> <span class="hljs-comment"># 使用-F匹配该表达式以后，就匹配失败了，因为没有这样的字符串。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>-G</strong>或<strong>--basic-regexp</strong>：将匹配模式当作普通的正则表达式使用，并不会按照拓展模式使用。</p></li><li><p><strong>-h</strong>或<strong>--no-filename</strong>：在显示匹配成功的结果时，不标识该行属于哪个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;u.*tu&#x27;</span> -h<br>127.0.1.1ubuntu<br></code></pre></td></tr></table></figure></li><li><p><strong>-H</strong>或<strong>--with-filename</strong>：在显示匹配成功的结果时，标识该行属于哪个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;u.*tu&#x27;</span> -H <span class="hljs-comment"># 这里给定的是管道符的输入，所以标识的来源为标准输入。</span><br>(standard input):127.0.1.1ubuntu<br></code></pre></td></tr></table></figure></li><li><p><strong>-i</strong>或<strong>--ignore-case</strong>：忽略字符串大小写的匹配。</p></li><li><p><strong>-l</strong>或<strong>--file-with-matches</strong>：在匹配成功后，并不是给出匹配成功的行，而是直接给文件的名称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;u.*tu&#x27;</span> -l<br>(standard input)<br></code></pre></td></tr></table></figure></li><li><p><strong>-L</strong>或<strong>--files-without-match</strong>：找出没有一处匹配成功的文件。</p></li><li><p><strong>-n</strong>或<strong>--line-number</strong>：在显示匹配成功的结果之前，标识该行所处的行数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;u.*tu&#x27;</span> -n<br>2:127.0.1.1ubuntu<br></code></pre></td></tr></table></figure></li><li><p><strong>-o</strong>或<strong>--only-matching</strong>：仅显示匹配成功的结果，而不是显示一整行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;u.*tu&#x27;</span> -o<br>ubuntu<br></code></pre></td></tr></table></figure></li><li><p><strong>-P</strong>：进入Perl风格的正则表达式，功能更加强大可以额外使用的功能包含如下几点：</p><ol type="1"><li><p><code>\K</code>用于需要匹配一部分内容，但是只想返回特定部分时，避免使用捕获组的场景。</p><p>例如，需要查询前缀前跟着的后缀值的场景，当只关心后缀值的情况下，可以使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;age: 13&quot;</span> | grep -P -o <span class="hljs-string">&quot;age: \K\d+&quot;</span> <span class="hljs-comment"># 此时会匹配到整段内容，虽然加了-o,但是也应该显示一段全部的内容，所以加了\k,可以忽略\K前面的内容。</span><br>13<br></code></pre></td></tr></table></figure></li></ol></li><li><p><strong>-q</strong>或<strong>--quiet</strong>或<strong>--silent</strong>：不显示任何信息，即便匹配成功。</p></li><li><p><strong>-r</strong>或<strong>--recursive</strong>：在输入源包含<strong>目录</strong>时使用，递归处理目录中的每一个文件。</p></li><li><p><strong>-v</strong>或<strong>--invert-match</strong>：将结果取反，匹配成功的不要了，只取匹配失败的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;u.*tu&#x27;</span> -v<br>127.0.0.1localhost<br>20.205.243.166  github.com<br><span class="hljs-comment"># The following lines are desirable for IPv6 capable hosts</span><br>::1     ip6-localhost ip6-loopback<br>fe00::0 ip6-localnet<br>ff00::0 ip6-mcastprefix<br>ff02::1 ip6-allnodes<br>ff02::2 ip6-allrouters<br></code></pre></td></tr></table></figure></li><li><p><strong>-w</strong>或<strong>--word-regexp</strong>：只有整个单词都匹配上了，才算匹配成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;ubun&#x27;</span><br>127.0.1.1ubuntu<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;ubun&#x27;</span> -w <span class="hljs-comment"># 这里虽然能找到127.0.1.1ubuntu存在ubun，但没有匹配上整个单词，所以还是匹配失败。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>-x</strong>或<strong>--line-regexp</strong>：只有整行匹配上了，才算匹配成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;127\.0\.1\.1[[:space:]]ubu&#x27;</span><br>127.0.1.1ubuntu<br><span class="hljs-built_in">test</span>@ubuntu:~/tmp$ <span class="hljs-built_in">cat</span> /etc/hosts | grep -E <span class="hljs-string">&#x27;127\.0\.1\.1[[:space:]]ubu&#x27;</span> -x <span class="hljs-comment"># 这里虽然能够匹配上部分，但是没有匹配成功一整行，所以匹配失败。</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub个人网站搭建,使用fluid主题</title>
    <link href="/2024/09/07/GitHub%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/09/07/GitHub%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="安装node.jsgithexopandoc">1 安装node.js、git、hexo、pandoc</h2><h3 id="安装node.js以及npm">1.1 安装node.js以及npm</h3><p>在</p><p>下载对应的windows系统下安装包一路安装后，会附带npm的安装。</p><p>安装完成后，使用<code>node -v</code>测试node.js的安装情况，使用<code>npm -v</code>测试npm的安装情况。</p><h3 id="修改npm的配置路径">1.2 修改npm的配置路径</h3><p>使用命令<code>npm list -global</code>查看当前npm的默认存储位置。</p><p>在自定义的位置下新建两个文件夹node_global以及node_cache。</p><p>使用以下命令设置，并再次使用<code>npm list -global</code>检查。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> prefix <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;node_gloabl文件夹的全路径&#125;</span>&quot;</span><br>npm config <span class="hljs-built_in">set</span> cache <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;node_cache文件夹的全路径&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><p>使用命令<code>npm install express -g</code>测试，如果下载过程中出现问题，改用管理员身份进行下载，安装完成后使用再次使用<code>npm list -global</code>发现结果发生改变，并且在node_global文件夹下也出现了安装的内容，说明以后安装的内容都会在这个文件夹中。</p><h3 id="修改npm环境变量">1.3 修改npm环境变量</h3><p>打开windows下的环境变量设置，对<strong>Administrator的用户变量</strong>中Path进行修改，将原始的npm路径修改为node_global的路径；对<strong>系统变量</strong>进行新增，插入变量名为NODE_PATH，变量值为node_global下node_modules文件夹的全路径。</p><h3 id="安装git">1.4 安装git</h3><p>设置ssh，起码可以拉取自己的仓库，这部分不做详述。</p><h3 id="安装hexo以及依赖">1.5 安装hexo以及依赖</h3><p>使用命令<code>npm install hexo -g</code>安装hexo，使用命令<code>hexo -v</code>检验。</p><p>使用命令<code>npm install --save hexo-deployer-git</code>安装hexo依赖。</p><p>使用命令<code>npm install hexo-renderer-pandoc --save</code>安装pandoc渲染的依赖。</p><h3 id="安装pandoc">1.6 安装pandoc</h3><p>因为使用默认的markdown渲染工具可能会存在渲染不达预期的情况，比如粗体斜体或者公式等等，所以这里安装一下<strong>pandoc</strong>。</p><p>下载<ahref="https://github.com/jgm/pandoc/releases/tag/3.3">pandoc-3.3-windows-x86_64.zip</a>，在解压缩之后，将执行路径加入到环境变量的用户变量中。也即在用户变量的Path中新建一个pandoc.exe的全路径即可。</p><h2 id="建立个人博客">2 建立个人博客</h2><h3 id="创建git项目">2.1 创建git项目</h3><p>创建一个名为<code>$&#123;username&#125;.github.io</code>的git项目,并记录其<strong>ssh</strong>地址。</p><h3 id="初始化hexo">2.2 初始化hexo</h3><p>在系统上创建博客文件夹，并在其目录下执行<code>hexo init</code>,这会将hexo的项目从github上拉取下来。</p><p>接着将项目中的<strong>_config.yml</strong>配置文件中的deploy配置项按照如下规则进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">$&#123;2.1步中记录的ssh地址&#125;</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">$&#123;需要部署的分支的名字，自己决定是main还是master&#125;</span><br></code></pre></td></tr></table></figure><h3 id="设置网站主题">2.3 设置网站主题</h3><p>找一个自己喜欢的hexo主题，进行自定义设置。</p><p>可以在<a href="https://hexo.io/themes/">Themes |Hexo</a>搜索，也可以直接在GitHub上搜索hexo-theme开头的仓库，一般都是hexo的主题仓库。一般仓库中都会给出对应的安装教程。</p><h4 id="设置hexo-theme-fluid主题过程">2.3.1设置hexo-theme-fluid主题过程</h4><p>下载<ahref="https://github.com/fluid-dev/hexo-theme-fluid/releases">1.9.8版本的fluid</a>解压到<strong>themes</strong>目录下，并将解压出的文件夹重命名为<code>fluid</code>。</p><p>修改_config.yml中的相关配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><p>执行命令<code>hexo new page "about"</code>新建<strong>关于页</strong>，进而在<strong>/source/about/index.md</strong>中编辑<strong>关于页</strong>的内容，按照如下修改<strong>front-matter</strong>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br></code></pre></td></tr></table></figure><p>执行命令<code>hexo new page "archives"</code>，创建<strong>归档</strong>页面，按照如下修改<strong>front-matter</strong>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">archives</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">archive</span><br></code></pre></td></tr></table></figure><p>执行命令<code>hexo new page "tags"</code>，创建<strong>标签</strong>页面，后续在文章中使用标签tags，即可在<strong>标签</strong>页分类，按照如下修改<strong>front-matter</strong>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">tags</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">tag</span><br></code></pre></td></tr></table></figure><p>执行命令<code>hexo new page "categories"</code>，创建<strong>目录</strong>页面，后续在文章中使用标签categories，即可在<strong>目录</strong>页分类，按照如下修改<strong>front-matter</strong>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">categories</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">category</span><br></code></pre></td></tr></table></figure><p>执行命令<code>npm install --save hexo-theme-fluid</code>，替换为<strong>fluid</strong>主题。</p><h3 id="发布博客">2.4 发布博客</h3><h4 id="建立新的博客">2.4.1 建立新的博客</h4><p>执行命令<code>hexo new $&#123;博客名字&#125;</code>，即可在<strong>source/_posts</strong>下创建文章，进而编写自己的博客内容。</p><h4 id="发布博客-1">2.4.2 发布博客</h4><p>执行命令<code>hexo clean</code>清除缓存。</p><p>执行命令<code>hexo generate</code>生成静态文件。</p><p>执行命令<code>hexo deploy</code>推送项目到自己的github仓库中。</p><p>只要执行以上三步，就可以将本地的博客文件夹下的内容全部推送到刚刚新建的个人博客仓库中去。</p><h4 id="访问页面">2.4.3 访问页面</h4><p>此时，只要访问<code>$&#123;username&#125;.github.io</code>即可得到最终的结果。</p><h2 id="fluid主题优化">3 fluid主题优化</h2><h3 id="创建配置文件_config.fluid.yml">3.1创建配置文件<code>_config.fluid.yml</code></h3><p>因为_config.fluid.yml中的配置项优先级比_config.yml中更高，所以一些自定义修改内容，以后直接在这个配置文件中进行修改即可。如果修改完配置，并提交到了github仓库，可能并不会立即生效，可以稍等一会。</p><h3 id="网站通用配置">3.2 网站通用配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">index:</span> <span class="hljs-comment"># 首页资源</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/bg/index_background.png</span> <span class="hljs-comment"># 背景图的路径,默认拼接到/source目录下</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">100</span> <span class="hljs-comment"># 背景图的高度，范围是[0, 100]</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.0</span> <span class="hljs-comment"># 背景图的透明度</span><br>  <span class="hljs-attr">slogan:</span> <span class="hljs-comment"># 设置首页大图中的标题文字，就是打字机打出来的那个。</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">text:</span> <span class="hljs-string">Hi</span><br>  <span class="hljs-attr">auto_excerpt:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 设置是否显示摘要，以下是编写摘要的格式</span><br><br><span class="hljs-attr">post:</span> <span class="hljs-comment"># 博客页面的设置</span><br>  <span class="hljs-attr">default_index_img:</span> <span class="hljs-string">/img/bg/blog_index_background.png</span> <span class="hljs-comment"># 博客页面在首页显示的封面图,在front-matter中设置的优先级更高。</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/bg/blog_banner_background.png</span> <span class="hljs-comment"># 博客页面的背景图，在front-matter中设置的优先级更高。</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">100</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br>  <span class="hljs-attr">meta:</span><br>    <span class="hljs-attr">author:</span>  <span class="hljs-comment"># 作者，优先根据 front-matter 里 author 字段，其次是 hexo 配置中 author 值</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">date:</span>  <span class="hljs-comment"># 文章日期，优先根据 front-matter 里 date 字段，其次是 md 文件日期</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;dddd, MMMM Do YYYY, h:mm a&quot;</span>  <span class="hljs-comment"># 格式参照 ISO-8601 日期格式化</span><br>    <span class="hljs-attr">wordcount:</span>  <span class="hljs-comment"># 字数统计</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 字&quot;</span>  <span class="hljs-comment"># 显示的文本，&#123;&#125;是数字的占位符（必须包含)，下同</span><br>    <span class="hljs-attr">min2read:</span>  <span class="hljs-comment"># 阅读时间</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 分钟&quot;</span><br><br>  <span class="hljs-attr">category_bar:</span> <span class="hljs-comment"># 侧边栏展示当前分类下的文章</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 开启后，只有在文章 Front-matter 里指定 `category_bar: true` 才会展示分类，也可以通过 `category_bar: [&quot;分类A&quot;]` 来指定分类</span><br>    <span class="hljs-comment"># If true, only set `category_bar: true` in Front-matter will enable sidebar of category, also set `category_bar: [&quot;CategoryA&quot;]` to specify categories</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># 置于板块的左侧或右侧</span><br>    <span class="hljs-comment"># place in the board</span><br>    <span class="hljs-comment"># Options: left | right</span><br>    <span class="hljs-attr">placement:</span> <span class="hljs-string">right</span><br><br>    <span class="hljs-comment"># 文章的排序字段，前面带减号是倒序，不带减号是正序</span><br>    <span class="hljs-comment"># Sort field for posts, with a minus sign is reverse order</span><br>    <span class="hljs-comment"># Options: date | title | or other field of front-matter</span><br>    <span class="hljs-attr">post_order_by:</span> <span class="hljs-string">&quot;title&quot;</span><br><br>    <span class="hljs-comment"># 单个分类中折叠展示文章数的最大值，超过限制会显示 More，0 则不限制</span><br>    <span class="hljs-comment"># The maximum number of posts in a single category. If the limit is exceeded, it will be displayed More. If 0 no limit</span><br>    <span class="hljs-attr">post_limit:</span> <span class="hljs-number">0</span><br><br>  <span class="hljs-comment"># 侧边栏展示文章目录</span><br>  <span class="hljs-comment"># Table of contents (TOC) in the sidebar</span><br>  <span class="hljs-attr">toc:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 置于板块的左侧或右侧</span><br>    <span class="hljs-comment"># place in the board</span><br>    <span class="hljs-comment"># Options: left | right</span><br>    <span class="hljs-attr">placement:</span> <span class="hljs-string">left</span><br><br>    <span class="hljs-comment"># 目录会选择这些节点作为标题</span><br>    <span class="hljs-comment"># TOC will select these nodes as headings</span><br>    <span class="hljs-attr">headingSelector:</span> <span class="hljs-string">&quot;h1,h2,h3,h4,h5,h6&quot;</span><br><br>    <span class="hljs-comment"># 层级的折叠深度，0 是全部折叠，大于 0 后如果存在下级标题则默认展开</span><br>    <span class="hljs-comment"># Collapse depth. If 0, all headings collapsed. If greater than 0, it will be expanded by default if there are sub headings</span><br>    <span class="hljs-attr">collapseDepth:</span> <span class="hljs-number">6</span><br><br>  <span class="hljs-comment"># 版权声明，会显示在每篇文章的结尾</span><br>  <span class="hljs-comment"># Copyright, will be displayed at the end of each post</span><br>  <span class="hljs-attr">copyright:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># CreativeCommons license</span><br>    <span class="hljs-comment"># Options: BY | BY-SA | BY-ND | BY-NC | BY-NC-SA | BY-NC-ND</span><br>    <span class="hljs-attr">license:</span> <span class="hljs-string">&#x27;BY&#x27;</span><br><br>    <span class="hljs-comment"># 显示作者</span><br>    <span class="hljs-attr">author:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 显示发布日期</span><br>    <span class="hljs-comment"># Show post date</span><br>    <span class="hljs-attr">post_date:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;LL&quot;</span><br><br>    <span class="hljs-comment"># 显示更新日期</span><br>    <span class="hljs-comment"># Show update date</span><br>    <span class="hljs-attr">update_date:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;LL&quot;</span><br><br>  <span class="hljs-comment"># 文章底部上一篇下一篇功能</span><br>  <span class="hljs-comment"># Link to previous/next post</span><br>  <span class="hljs-attr">prev_next:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 文章图片标题</span><br>  <span class="hljs-comment"># Image caption</span><br>  <span class="hljs-attr">image_caption:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 文章图片可点击放大</span><br>  <span class="hljs-comment"># Zoom feature of images</span><br>  <span class="hljs-attr">image_zoom:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># 放大后图片链接替换规则，可用于将压缩图片链接替换为原图片链接，如 [&#x27;-slim&#x27;, &#x27;&#x27;] 是将链接中 `-slim` 移除；如果想使用正则请使用 `re:` 前缀，如 [&#x27;re:\\d&#123;3,4&#125;\\/\\d&#123;3,4&#125;\\/&#x27;, &#x27;&#x27;]</span><br>    <span class="hljs-comment"># The image url replacement when zooming, the feature can be used to replace the compressed image to the original image, eg: [&#x27;-slim&#x27;, &#x27;&#x27;] removes `-slim` from the image url when zooming; if you want to use regular, use prefix `re:`, eg: [&#x27;re:\\d&#123;3,4&#125;\\/\\d&#123;3,4&#125;\\/&#x27;,&#x27;&#x27;]</span><br>    <span class="hljs-attr">img_url_replace:</span> [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>]<br><br><span class="hljs-attr">archive:</span> <span class="hljs-comment"># 归档页面</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/bg/archives_background.png</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">100</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br><span class="hljs-attr">category:</span> <span class="hljs-comment"># 分类页面</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/bg/categories_background.png</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">60</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br><span class="hljs-attr">tag:</span> <span class="hljs-comment"># 标签页面</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/bg/tags_background.png</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br>  <span class="hljs-attr">tagcloud:</span> <span class="hljs-comment"># 改变标签显示的方式。</span><br>    <span class="hljs-attr">min_font:</span> <span class="hljs-number">15</span><br>    <span class="hljs-attr">max_font:</span> <span class="hljs-number">30</span><br>    <span class="hljs-attr">unit:</span> <span class="hljs-string">px</span><br>    <span class="hljs-attr">start_color:</span> <span class="hljs-string">&quot;#BBBBEE&quot;</span> <span class="hljs-comment"># 最开始的颜色</span><br>    <span class="hljs-attr">end_color:</span> <span class="hljs-string">&quot;#337ab7&quot;</span> <span class="hljs-comment"># 鼠标移上去以后的颜色</span><br><br><span class="hljs-attr">about:</span> <span class="hljs-comment"># 关于页面</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/bg/about_background.png</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">60</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br>  <span class="hljs-attr">avatar:</span> <span class="hljs-string">/img/bg/avatar.png</span> <span class="hljs-comment"># 设置头像</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;锋&quot;</span><br>  <span class="hljs-attr">intro:</span> <span class="hljs-string">&quot;Hi&quot;</span><br>  <span class="hljs-attr">icons:</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&quot;iconfont icon-github-fill&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;https://github.com/Astronaut-diode&quot;</span>, <span class="hljs-attr">tip:</span> <span class="hljs-string">&quot;GitHub&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&quot;iconfont icon-bilibili-fill&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;https://space.bilibili.com/415812264&quot;</span>, <span class="hljs-attr">tip:</span> <span class="hljs-string">&quot;Bilibili&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&quot;iconfont icon-wechat-fill&quot;</span>, <span class="hljs-attr">qrcode:</span> <span class="hljs-string">&quot;/img/bg/wechat_qrcode.jpg&quot;</span> &#125;<br><br><span class="hljs-attr">navbar:</span> <span class="hljs-comment"># 导航栏设置</span><br>  <span class="hljs-attr">blog_title:</span> <span class="hljs-string">锋的博客</span> <span class="hljs-comment"># 博客标题</span><br><br><span class="hljs-attr">footer:</span><br>  <span class="hljs-comment"># 页脚第一行文字的 HTML，最好是不设置，但是有点强迫症，还是隐了。</span><br>  <span class="hljs-attr">content:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-attr">code:</span> <span class="hljs-comment"># 代码块的配置</span><br>  <span class="hljs-attr">copy_btn:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否开启复制代码的按钮</span><br>  <span class="hljs-attr">highlight:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否开启代码高亮</span><br>    <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否开启行号</span><br>    <span class="hljs-attr">lib:</span> <span class="hljs-string">&quot;highlightjs&quot;</span> <span class="hljs-comment"># 高亮的代码风格</span><br>    <span class="hljs-attr">highlightjs:</span><br>      <span class="hljs-attr">style:</span> <span class="hljs-string">&#x27;Github Gist&#x27;</span><br>      <span class="hljs-attr">bg_color:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">prismjs:</span><br>      <span class="hljs-attr">style:</span> <span class="hljs-string">&quot;default&quot;</span><br>      <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br><br><br><span class="hljs-comment"># 用于浏览器标签的图标</span><br><span class="hljs-comment"># Icon for browser tab</span><br><span class="hljs-attr">favicon:</span> <span class="hljs-string">/img/bg/favicon.png</span><br><br><span class="hljs-comment"># 用于苹果设备的图标</span><br><span class="hljs-comment"># Icon for Apple touch</span><br><span class="hljs-attr">apple_touch_icon:</span> <span class="hljs-string">/img/bg/favicon.png</span><br></code></pre></td></tr></table></figure><h3 id="front-matter配置">3.3 front-matter配置</h3><p>front-matter指的就是每篇博客前面写的那段配置内容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">author:</span> <span class="hljs-string">作者名字</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">博客标题</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">摘要内容</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2035-04-07 00:00:00</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/bg/blog_index_background.png</span> <span class="hljs-comment"># 博客在首页的封面图</span><br><span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/bg/blog_banner_background.png</span> <span class="hljs-comment"># 博客页面的背景图</span><br><span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">100</span><br><span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><span class="hljs-attr">tags:</span> <span class="hljs-comment"># 这里的标签是同级别的</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">标签A</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">标签B</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">标签C</span><br><span class="hljs-attr">categories:</span> <span class="hljs-comment"># 这里是多级分类的写法</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">分类1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">分类1的子分类1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">分类1的子分类1的子分类1</span><br></code></pre></td></tr></table></figure><h3 id="config.yml">3.4 _config.yml</h3><p>这里保存一下改动过的_config.yml，以作备份。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Hexo Configuration</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="hljs-comment">## Source: https://github.com/hexojs/hexo/</span><br><br><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">锋的博客</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">keywords:</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">锋</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://astronaut-diode.github.io/</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br><span class="hljs-attr">permalink_defaults:</span><br><span class="hljs-attr">pretty_urls:</span><br>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br><br><span class="hljs-comment"># Directory</span><br><span class="hljs-attr">source_dir:</span> <span class="hljs-string">source</span><br><span class="hljs-attr">public_dir:</span> <span class="hljs-string">public</span><br><span class="hljs-attr">tag_dir:</span> <span class="hljs-string">tags</span><br><span class="hljs-attr">archive_dir:</span> <span class="hljs-string">archives</span><br><span class="hljs-attr">category_dir:</span> <span class="hljs-string">categories</span><br><span class="hljs-attr">code_dir:</span> <span class="hljs-string">downloads/code</span><br><span class="hljs-attr">i18n_dir:</span> <span class="hljs-string">:lang</span><br><span class="hljs-attr">skip_render:</span><br><br><span class="hljs-comment"># Writing</span><br><span class="hljs-attr">new_post_name:</span> <span class="hljs-string">:title.md</span> <span class="hljs-comment"># File name of new posts</span><br><span class="hljs-attr">default_layout:</span> <span class="hljs-string">post</span><br><span class="hljs-attr">titlecase:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Transform title into titlecase</span><br><span class="hljs-attr">external_link:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Open external links in new tab</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">site</span> <span class="hljs-comment"># Apply to the whole site</span><br>  <span class="hljs-attr">exclude:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">filename_case:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">render_drafts:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">relative_link:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">future:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">syntax_highlighter:</span> <span class="hljs-string">highlight.js</span><br><span class="hljs-attr">highlight:</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">auto_detect:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">wrap:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">hljs:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">prismjs:</span><br>  <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-comment"># Home page setting</span><br><span class="hljs-comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class="hljs-comment"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="hljs-comment"># order_by: Posts order. (Order by date descending by default)</span><br><span class="hljs-attr">index_generator:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">order_by:</span> <span class="hljs-string">-date</span><br><br><span class="hljs-comment"># Category &amp; Tag</span><br><span class="hljs-attr">default_category:</span> <span class="hljs-string">uncategorized</span><br><span class="hljs-attr">category_map:</span><br><span class="hljs-attr">tag_map:</span><br><br><span class="hljs-comment"># Metadata elements</span><br><span class="hljs-comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span><br><span class="hljs-attr">meta_generator:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># Date / Time format</span><br><span class="hljs-comment">## Hexo uses Moment.js to parse and display date</span><br><span class="hljs-comment">## You can customize the date format as defined in</span><br><span class="hljs-comment">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="hljs-attr">date_format:</span> <span class="hljs-string">YYYY-MM-DD</span><br><span class="hljs-attr">time_format:</span> <span class="hljs-string">HH:mm:ss</span><br><span class="hljs-comment">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span><br><span class="hljs-attr">updated_option:</span> <span class="hljs-string">&#x27;mtime&#x27;</span><br><br><span class="hljs-comment"># Pagination</span><br><span class="hljs-comment">## Set per_page to 0 to disable pagination</span><br><span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">pagination_dir:</span> <span class="hljs-string">page</span><br><br><span class="hljs-comment"># Include / Exclude file(s)</span><br><span class="hljs-comment">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><span class="hljs-attr">include:</span><br><span class="hljs-attr">exclude:</span><br><span class="hljs-attr">ignore:</span><br><br><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br><br><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:Astronaut-diode/Astronaut-diode.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>部署安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>Fluid</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
